@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f algebra

@c
/*
 * @a Peter Boncz, Martin Kersten, Niels Nes
 * @v 2.0
 * @+ BAT Algebra
 * This modules contains the most common algebraic BAT manipulation
 * commands. We call them algebra, because all operations take
 * values as parameters, and produce new result values, but
 * do not modify their parameters.
 *
 * Unlike the previous Monet versions, we reduce the number
 * of functions returning a BAT reference. This was previously needed
 * to simplify recursive bat-expression and manage reference counts.
 * In the current version we return only a BAT identifier when a new
 * bat is being created.
 *
 * All parameters to the modules are passed by reference.
 * In particular, this means that
 * string values are passed to the module layer as (str *)
 * and we have to de-reference them before entering the gdk library.
 * This calls for knowlegde on the underlying BAT typs`s
 */
@= derefStr
{int _tpe= ATOMstorage(@1->@2type);
 if( _tpe >= TYPE_str )
 { if(@3== 0 || *(str*)@3==0) @3 = (str)str_nil;
   else @3 = *(str *)@3;
}}

@
@mal
# We split between selections that return one value, and selections
# that return a BAT.
# @+ Value Selections
module algebra;

command exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist
comment "Returns whether 'h' occurs as a head value in b.";

command exist(b:bat[:any_1,:any_2], h:any_1, t:any_2):bit 
address ALGexistBUN
comment "Returns true when 'h,t' occurs as a bun in b.";

command find(b:bat[:any_1,:any_2], h:any_1):any_2 
address ALGfind
comment "Returns the tail value 't' for which some [h,t] BUN 
	exists in b.  If no such BUN exists, an error occurs." ;

command position(b:bat[:any_1,:any_2], v:any_1):wrd
address ALGposition
comment "Returns BAT position [0.. b.count] of 'v' in the head 
	column of b. It Return an error if 'v' does not exist.";

command position(b:bat[:any_1,:any_2], val:any_1, tval:any_2) :wrd 
address ALGpositionBUN
comment "Returns the position of the value pair It returns an 
	error if 'val' does not exist.";

command fetch(b:bat[:any_2,:any_1], x:oid) :any_1 
address ALGfetchoid;
command fetch(b:bat[:any_2,:any_1], x:lng) :any_1 
address ALGfetch;
command fetch(b:bat[:any_2,:any_1], x:int) :any_1 
address ALGfetchint
comment "Returns the tail value of the BUN at x-th position 
	with 0 <= x < b.count";

# @+ BAT Selections
# The operations are grouped by positional and range selections.
# A simple sampling operation is also provided.
# @- Positional selection
command fetch(b:bat[:any_1,:any_2], s:bat[:int,:any_3]) :bat[:any_1,:any_2] 
address ALGfetchbat;
command fetch(b:bat[:any_1,:any_2], s:bat[:lng,:any_3] ) :bat[:any_1,:any_2] 
address ALGfetchbat;
command fetch(b:bat[:any_1,:any_2], s:bat[:oid,:any_3]) :bat[:any_1,:any_2] 
address ALGfetchbat
comment "Returns a positional selection of b by the oid 
	head values of s";

# @- Range selection
# The range selections are targeted at the tail of the BAT.
command subselect(b:bat[:oid,:any_1], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid,:oid]
address ALGsubselect1
comment "Select all head values for which the tail value is in range.
	Input is a dense-headed BAT, output is a dense-headed BAT with in
	the tail the head value of the input BAT for which the tail value
	is between the values low and high (inclusive if li respectively
	hi is set).  The output BAT is sorted on the tail value.  If low
	or high is nil, the boundary is not considered (effectively - and
	+ infinity).  If anti is set, the result is the complement.  Nil
	values in the tail are never matched, unless low=nil, high=nil,
	li=1, hi=1, anti=0.  All non-nil values are returned if low=nil,
	high=nil, and li, hi are not both 1, or anti=1.
	Note that the output is suitable as second input for the other
	version of this function.";

command subselect(b:bat[:oid,:any_1], s:bat[:oid,:oid], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid,:oid]
address ALGsubselect2
comment "Select all head values of the first input BAT for which the tail value
	is in range and for which the head value occurs in the tail of the
	second input BAT.
	The first input is a dense-headed BAT, the second input is a
	dense-headed BAT with sorted tail, output is a dense-headed BAT
	with in the tail the head value of the input BAT for which the
	tail value is between the values low and high (inclusive if li
	respectively hi is set).  The output BAT is sorted on the tail
	value.  If low or high is nil, the boundary is not considered
	(effectively - and + infinity).  If anti is set, the result is the
	complement.  Nil values in the tail are never matched, unless
	low=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are
	returned if low=nil, high=nil, and li, hi are not both 1, or anti=1.
	Note that the output is suitable as second input for this
	function.";

command thetasubselect(b:bat[:oid,:any_1], val:any_1, op:str) :bat[:oid,:oid]
address ALGthetasubselect1
comment "Select all head values for which the tail value obeys the relation
	value OP VAL.
	Input is a dense-headed BAT, output is a dense-headed BAT with in
	the tail the head value of the input BAT for which the
	relationship holds.  The output BAT is sorted on the tail value.";

command thetasubselect(b:bat[:oid,:any_1], s:bat[:oid,:oid], val:any_1, op:str) :bat[:oid,:oid]
address ALGthetasubselect2
comment "Select all head values of the first input BAT for which the tail value
	obeys the relation value OP VAL and for which the head value occurs in
	the tail of the second input BAT.
	Input is a dense-headed BAT, output is a dense-headed BAT with in
	the tail the head value of the input BAT for which the
	relationship holds.  The output BAT is sorted on the tail value.";

command select(b:bat[:any_1,:any_2], low:any_2, high:any_2) 
		:bat[:any_1,:any_2] 
address ALGselect
comment "Select all BUNs that have tail values: {v| low <= v <= high}.
	NIL boundary values have a special meaning.
		+ low  == nil means: no lower bound
		+ high == nil means: no upper bound.
		NOTE 1: you should cast the nil to the appropriate type, 
				e.g. int(nil) in order to circumvent type clashes.
		NOTE 2: as the 'nil' element has no clear place in the 
				ordered domain of values, tuples with 'nil' values 
				are NEVER returned by the range select.";

command thetaselect(b:bat[:any_1,:any_2], val:any_2, op:str) :bat[:any_1,:any_2]
address ALGthetaselect
comment "The theta (<=,<,=,>,>=) select()";

command select(b:bat[:any_1,:any_2], low:any_2, 
	high:any_2, li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGselectInclusive
comment "Select all BUNs that have tail values: {v| low <{=} v <{=} high}.
	Boundary inclusion is indicated separately.
	NIL boundary values have a special meaning.
	+ low  == nil means: no lower bound
	+ high == nil means: no upper bound.";

command select(b:bat[:any_1,:any_2],value:any_2) :bat[:any_1,:any_2] 
address ALGselect1
comment "Select all BUNs of a BAT with a certain 
	tail value. Selection on NIL is also 
	possible (it should be properly casted, 
	e.g.:int(nil)).";

command selectNotNil(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address ALGselectNotNil
comment "Select all not-nil values";

# The second group uses the head to perform the range selection.
command selectH(b:bat[:any_1,:any_2], low:any_1, high:any_1) 
			:bat[:any_1,:any_2] 
address ALGselectHead;

command selectH(b:bat[:any_1,:any_2], low:any_1, 
	high:any_1, li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGselectInclusiveHead;

command selectH(b:bat[:any_1,:any_2],value:any_1) :bat[:any_1,:any_2] 
address ALGselect1Head;

# A special case for this set are the void tailed bats.
command select(b:bat[:any_2,:void], low:any_2) 
		:bat[:any_2,:void] 
address ALGselect1Head;

command select(b:bat[:any_2,:void], low:any_2, high:any_2) 
		:bat[:any_2,:void] 
address ALGselectHead;
command select(b:bat[:any_2,:void], low:any_2, high:any_2,li:bit, hi:bit) 
		:bat[:any_2,:void] 
address ALGselectInclusiveHead;

# The second group uses the head to perform the range selection

command fragment ( b:bat[:any_1,:any_2], hlow:any_1, hhigh:any_1,
		tlow:any_2, thigh:any_2 ) :bat[:any_1,:any_2] 
address ALGfragment
comment "Select both on head and tail range.";

command slice(b:bat[:any_1,:any_2], x:oid, y:oid) :bat[:any_1,:any_2] 
address ALGslice_oid
comment "Return the slice based on head oid x till y (exclusive).";

command slice(b:bat[:any_1,:any_2], x:lng, y:lng) :bat[:any_1,:any_2] 
address ALGslice
comment "Return the slice with the BUNs at position x till y.";

command slice(b:bat[:any_1,:any_2], x:int, y:int) :bat[:any_1,:any_2] 
address ALGslice_int
comment "Return the slice with the BUNs at position x till y.";

command slice(b:bat[:any_1,:any_2], x:wrd, y:wrd) :bat[:any_1,:any_2] 
address ALGslice_wrd
comment "Return the slice with the BUNs at position x till y.";

command subslice(b:bat[:oid,:any_1], x:wrd, y:wrd) :bat[:oid,:oid] 
address ALGsubslice_wrd
comment "Return the oids of the slice with the BUNs at position x till y.";

command topN( b:bat[:any_1,:any_2], top:lng ) :bat[:any_1,:any_2]
address ALGtopN
comment "Trim all but the top N tuples.";

command groupby(gids:bat[:oid,:oid], cnts:bat[:oid,:wrd]) :bat[:oid,:oid] 
address ALGgroupby
comment "Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.";

command uselect(b:bat[:any_1,:any_2], low:any_2, high:any_2, 
		li:bit, hi:bit) :bat[:any_1,:void] 
address ALGuselectInclusive
comment "See select() but limited to head values";

command thetauselect(b:bat[:any_1,:any_2], val:any_2, op:str) :bat[:any_1,:void] 
address ALGthetauselect
comment "The theta (<=,<,=,>,>=) select() limited to head values";

command uselect(b:bat[:any_1,:any_2], low:any_2, high:any_2):bat[:any_1,:void] 
address ALGuselect;
command uselect(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1,:void] 
address ALGuselect1
comment "Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)";

command antiuselect(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1,:void] 
address ALGantiuselect1
comment "Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)";

command antiuselect(b:bat[:any_1,:any_2], low:any_2, high:any_2, 
		li:bit, hi:bit) :bat[:any_1,:void] 
address ALGantiuselectInclusive
comment "See select() but limited to head values";
# @- Pattern matching
command like(b:bat[:any_1,:str], substr:str) :bat[:any_1,:str]
address ALGlike
comment "Selects all elements that have 'substr' as in the tail.";

# @- Sampling
command sample ( b:bat[:oid,:any_2], num:int ) :bat[:oid,:any_2] 
address ALGsample
comment "Produce a random selection of size 'num' from the input BAT.";

command subsample(b:bat[:oid,:any_1], num:int ) :bat[:oid,:oid] 
address ALGsubsample
comment "Return the oids of a random selection of size 'num' from the input BAT.";

# @+ BAT copying
command copy( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGcopy
comment "Returns physical copy of a BAT.";
# @- Sorted copy
command sort( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhsort
comment "Returns a BAT copy sorted on the head column.";
command sortReverse( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhsort_rev
comment "Returns a BAT copy reversely sorted on the head column.";

command sortTail( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGtsort
comment "Returns a BAT copy sorted on the tail column.";
command sortReverseTail( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGtsort_rev
comment "Returns a BAT copy reversely sorted on the tail column.";

command sortHT( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhtsort
comment "Returns a lexicographically sorted copy on head,tail.";
command sortTH( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGthsort
comment "Returns a lexicographically sorted copy on tail,head.";

command ssort( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGssort
comment "Returns copy of a BAT with the BUNs sorted on ascending head values.
         This is a stable sort.";
command ssort_rev( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGssort_rev
comment "Returns copy of a BAT with the BUNs sorted on descending head values.
         This is a stable sort.";

command subsort(b:bat[:oid,:any_1], reverse:bit, stable:bit) :bat[:oid,:any_1]
address ALGsubsort11
comment "Returns a copy of the BAT sorted on tail values.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], reverse:bit, stable:bit) (:bat[:oid,:any_1], :bat[:oid,:oid])
address ALGsubsort12
comment "Returns a copy of the BAT sorted on tail values and a BAT that
         specifies how the input was reordered.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], reverse:bit, stable:bit) (:bat[:oid,:any_1], :bat[:oid,:oid], :bat[:oid,:oid])
address ALGsubsort13
comment "Returns a copy of the BAT sorted on tail values, a BAT that specifies
         how the input was reordered, and a BAT with group information.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], o:bat[:oid,:oid], reverse:bit, stable:bit) :bat[:oid,:any_1]
address ALGsubsort21
comment "Returns a copy of the BAT sorted on tail values.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], o:bat[:oid,:oid], reverse:bit, stable:bit) (:bat[:oid,:any_1], :bat[:oid,:oid])
address ALGsubsort22
comment "Returns a copy of the BAT sorted on tail values and a BAT that
         specifies how the input was reordered.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], o:bat[:oid,:oid], reverse:bit, stable:bit) (:bat[:oid,:any_1], :bat[:oid,:oid], :bat[:oid,:oid])
address ALGsubsort23
comment "Returns a copy of the BAT sorted on tail values, a BAT that specifies
         how the input was reordered, and a BAT with group information.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], o:bat[:oid,:oid], g:bat[:oid,:oid], reverse:bit, stable:bit) :bat[:oid,:any_1]
address ALGsubsort31
comment "Returns a copy of the BAT sorted on tail values.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], o:bat[:oid,:oid], g:bat[:oid,:oid], reverse:bit, stable:bit) (:bat[:oid,:any_1], :bat[:oid,:oid])
address ALGsubsort32
comment "Returns a copy of the BAT sorted on tail values and a BAT that
         specifies how the input was reordered.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";
command subsort(b:bat[:oid,:any_1], o:bat[:oid,:oid], g:bat[:oid,:oid], reverse:bit, stable:bit) (:bat[:oid,:any_1], :bat[:oid,:oid], :bat[:oid,:oid])
address ALGsubsort33
comment "Returns a copy of the BAT sorted on tail values, a BAT that specifies
         how the input was reordered, and a BAT with group information.
         The input and output are (must be) dense headed.
         The order is descending if the reverse bit is set.
		 This is a stable sort if the stable bit is set.";

command revert( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGrevert
comment "Returns a BAT copy with buns in reverse order";

# @+ Set operations
# Sets in Monet can be viewed in two ways:
# @itemize
# @item
# by looking at both columns of a BAT together (Set-, or s-operators).
# @item
# by looking at the head column only (Key- or k-operators).
# by looking at the tail column only (Tail key- or t-operators).
# @end itemize
# For this reason, all standard set operations come in three flavors:
# k-@emph{operand} series, which look only at the head column,
# t-@emph{operand} series, which look only at the tail column, and
# s-@emph{operand} series, that look at the whole BUN.
#
# @noindent Operands provided are:
# @itemize
# @item [s,k,t]unique(bat[:any_1,:any_2]) :bat[:any_1,:any_2]
# produces a copy of the bat, with double elimination
# @item [s,k,t]union(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
# bat union.
# @item [s,k,t]difference(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
# bat difference.
# @item [s,k,t]intersection(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
# bat intersection.
# @end itemize
# Implementations typically take two forms: if the input relation(s) is/are
# ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
# on demand for the hash-based algorithms.
# The [k,s]intersect(l,r) operations result in all BUNs of @emph{l} that
# are also in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.
# The [k,s]difference(l,r) operations result in all BUNs of @emph{l} that are
# not in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.
# The [k,s]union(l,r) operations result in all BUNs of l, plus all BUNs
# of @emph{r} that are not in @emph{l}. They do not do double-elimination
# over the @emph{l} nor @emph{r} BUNs.
# Operations with double-elimination can be formed by performing
# [k,s]unique(l) on their operands.
# The kintersect(l,r) is used also as implementation for the
# @emph{semijoin()}.
#
# The t-@emph{operand} series are cast into a k-@emph{operand}
# expression enclosing it with a BATmirror.
# @- Bun-unique elements
command unique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGsunique;
command sunique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGsunique
comment "Select unique tuples from the input BAT. Double elimination is 
		done over BUNs as a whole (head and tail).  Result is a BAT 
	with real set() semantics.";
# @- Head-unique elements
command kunique ( b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGkunique
comment "Select unique tuples from the input BAT.  Double elimination is 
		done only looking at the head column. The result is a BAT with
		property hkeyed() == true.";

command tunique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGtunique
comment "Select unique tuples from the input BAT. Double elimination is 
		done over the BUNs tail. The result is a BAT with property
		tkeyd()== true";

# @- Bun-intersecting elements
command intersect ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsintersect;
command sintersect ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsintersect
comment "Returns the intersection taken over *both* columns of two BATs. 
		Results in all BUNs of 'left' that are also in 'right'. Does *not* 
		do double-elimination over the 'left' BUNs, If you want this, use:
	 'sintersect(sunique(left),sunique(right))' 
	or: 'sunique(sintersect(left,right))'.";

# @- Head-intersecting elements (a.k.a. semijoin)
command semijoin( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGsemijoin
comment "Returns the intersection taken over only the *head* columns of 
		two BATs.  Results in all BUNs of 'left' that are also in 'right'. 
		Does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use: 'kintersect(kunique(left),kunique(right))' 
	or: 'kunique(kintersect(left,right))'.";

command kintersect( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGsemijoin
comment "Returns the intersection taken over only the *head* columns of two BATs. 
	Results in all BUNs of 'left' that are also in 'right'. 
		Does *not* do double- elimination over the 'left' BUNs.
		If you want this, use: 'kintersect(kunique(left),kunique(right))' 
	or: 'kunique(kintersect(left,right))'.";
command tintersect( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGtintersect;
command tinter( left:bat[:oid,:oid], right:bat[:oid,:oid] ) :bat[:oid,:oid] 
address ALGtinter;

# @- Bun-differing elements
command difference( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2] ) 
		:bat[:any_1,:any_2] 
address ALGsdiff;
command sdifference( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2] ) 
		:bat[:any_1,:any_2] 
address ALGsdiff
comment "Returns the difference taken over *both* columns of two BATs. 
		Results in all BUNs of 'left' that are *not* in 'right'. 
		Does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use:
		 'sdifference(left.sunique,right.sunique)' 
	or: 'sdifference(left,right).sunique'.";
# @- Head-differing elements
command kdifference ( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGkdiff
comment "Returns the difference taken over only the *head* columns of two BATs. 
		Results in all BUNs of 'left' that are *not* in 'right'. 
		It does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use:
	 'kdifference(left.kunique,right.kunique)' 
	or: 'kdifference(left,right).kunique'.";
command tdifference ( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGtdifference;
command tdiff( left:bat[:oid,:oid], right:bat[:oid,:oid] ) :bat[:oid,:oid] 
address ALGtdiff;
# @- Unions on bun
command union ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsunion;
command sunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsunion
comment "Returns the union of two BATs; looking at both columns of both BATs.
		Results in all BUNs of 'left' that are  not in 'right', plus all 
		BUNs of 'right'.  *no* double-elimination is done. 
		If you want this, do:
	 'sunion(left.sunique,right.sunique)' 
	or: 'sunion(left,right).sunique'.";
# @- Union on head
command kunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2])
		:bat[:any_1,:any_2] 
address ALGkunion
comment "Returns the union of two BATs; looking at head-columns only. 
		Results in all BUNs of 'left' that are  not in 'right', plus 
	all BUNs of 'right'.  *no* double-elimination is done. 
		If you want this, do:
	'kunion(left.kunique,right.kunique)' 
	or: 'sunion(left,right).kunique'.";
command tunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2])
		:bat[:any_1,:any_2] 
address ALGtunion;


# @+ Join operations
# The core of every relational engine.
# The join collection provided by the GDK kernel.
command antijoin( left:bat[:oid,:any_1], right:bat[:oid,:any_1])
		(l:bat[:oid,:oid],r:bat[:oid,:oid])
address ALGantijoin2
comment "Returns 2 columns with all BUNs, consisting of the head-oids 
	  from 'left' and 'right' for which there are BUNs in 'left' 
	  and 'right' with equal tails";

command join( left:bat[:oid,:any_1], right:bat[:oid,:any_1])
		(l:bat[:oid,:oid],r:bat[:oid,:oid])
address ALGjoin2
comment "Returns 2 columns with all BUNs, consisting of the head-oids 
	  from 'left' and 'right' for which there are BUNs in 'left' 
	  and 'right' with equal tails";

# @- Theta Join
command thetajoin( left:bat[:oid,:any_1], right:bat[:oid,:any_1], opname:int)
		(l:bat[:oid,:oid],r:bat[:oid,:oid])
address ALGthetajoin2
comment "Returns 2 columns with all BUNs, consisting of the head-oids 
	  from 'left' and 'right' for which there are BUNs in 'left' 
	  and 'right' with equal tails";

command crossproduct( left:bat[:oid,:any_1], right:bat[:oid,:any_2])
		(l:bat[:oid,:oid],r:bat[:oid,:oid])
address ALGcrossproduct2
comment "Returns 2 columns with all BUNs, consisting of the head-oids 
	  from 'left' and 'right' for which there are BUNs in 'left' 
	  and 'right' with equal tails";

command bandjoin( outer:bat[:oid,:any_2], inner:bat[:oid,:any_2], minus:any_2 , plus:any_2, li:bit, hi:bit ) 
		(l:bat[:oid,:oid],r:bat[:oid,:oid])
address ALGbandjoin2
comment "This is a join() for which the predicate is that two BUNs match 
		if the left-tail value is within the range [right-head - minus, 
		right-head + plus], depending on (l_in/h_in), the bounds 
		are included. Works only for the builtin numerical types, 
		and their derivates.";

command join(left:bat[:oid,:any_2], rl:bat[:oid,:any_2], rh:bat[:oid,:any_2], li:bit, hi:bit) 
		(l:bat[:oid,:oid],r:bat[:oid,:oid])
address ALGrangejoin2;

# Note that joins over void columns are handled as if they are oids.
command crossproduct(left:bat[:any_1,:any_2], right:bat[:any_3,:any_4])
	:bat[:any_1,:any_4]
address ALGcross
comment "Returns the cross product";

command antijoin(left:bat[:any_1,:any_2], right:bat[:any_2,:any_4])
	:bat[:any_1,:any_4]
address ALGantijoin
comment "Returns the antijoin";

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin
comment "Returns all BUNs, consisting of a head-value from 'left' and 
		a tail-value from 'right' for which there are BUNs in 'left' 
		and 'right' with equal tail- resp. head-value (i.e. the join
	columns are projected out).";

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin;
command leftjoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGleftjoin;

command leftjoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGleftjoinestimate;

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGjoinestimate;

command fetchjoin ( left:bat[:any_1,:oid], right:bat[:oid,:any_3] )
		:bat[:any_1,:any_3] 
address ALGfetchjoin
comment "Hook directly into the fetch implementation of the join.";

command leftfetchjoin ( left:bat[:any_1,:oid], right:bat[:oid,:any_3] )
		:bat[:any_1,:any_3] 
address ALGleftfetchjoin
comment "Hook directly into the left fetch join implementation.";

command mergejoin (left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGmergejoin
comment "Hook directly into the merge implementation of the join.";

command hashjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGhashjoin
comment "Hook directly into the hash implementation of the join.";

command indexjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGindexjoin
comment "Hook directly into the index implementation of the join.";

# @- Outer Join
command outerjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
		the tail and the head-values of 'outer' whose tail-value does 
		not match an head-value in 'inner'.";
command outerjoin( outer:bat[:any_1,:oid], inner:bat[:oid,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
		the tail and the head-values of 'outer' whose tail-value does 
		not match an head-value in 'inner'.";
command outerjoin( outer:bat[:any_1,:oid], inner:bat[:oid,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
		the tail and the head-values of 'outer' whose tail-value does 
		not match an head-value in 'inner'.";

command outerjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGouterjoinestimate;

# @- Theta Join
command thetajoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		opname:int) :bat[:any_1,:any_3] 
address ALGthetajoin
comment "Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.  JOIN_EQ is 
		just the same as join(). All other options do merge algorithms. 
		Either using the fact that they are ordered() already (left on tail, 
	right on head), or by using/creating binary search trees on the 
		join columns. ";

command thetajoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		opname:int,estimate:lng) :bat[:any_1,:any_3] 
address ALGthetajoinEstimate;
# @- Band Join (approximate match)
command bandjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		   minus:any_2 , plus:any_2 ) :bat[:any_1,:any_3] 
address ALGbandjoin_default
comment "This is a join() for which the predicate is that two BUNs match 
		if the left-tail value is within the range [right-head - minus, 
		right-head + plus]. Works only for the builtin numerical types, 
		and their derivates.";

command bandjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		   minus:any_2 , plus:any_2, li:bit, hi:bit ) :bat[:any_1,:any_3] 
address ALGbandjoin
comment "This is a join() for which the predicate is that two BUNs match 
		if the left-tail value is within the range [right-head - minus, 
		right-head + plus], depending on (l_in/h_in), the bounds 
		are included. Works only for the builtin numerical types, 
		and their derivates.";

command join(l:bat[:any_1,:any_2], rl:bat[:any_3,:any_2], rh:bat[:any_3,:any_2], li:bit, hi:bit) :bat[:any_1,:any_3] 
address ALGrangejoin;

command subleftjoin(l:bat[:oid,:any_1],r:bat[:oid,:any_1]) (:bat[:oid,:oid],:bat[:oid,:oid])
address ALGsubleftjoin
comment "Left join";
command subleftjoin(l:bat[:oid,:any_1],r:bat[:oid,:any_1],sl:bat[:oid,:oid],sr:bat[:oid,:oid]) (:bat[:oid,:oid],:bat[:oid,:oid])
address ALGsubleftjoin4
comment "Left join with candidate lists";

command subouterjoin(l:bat[:oid,:any_1],r:bat[:oid,:any_1]) (:bat[:oid,:oid],:bat[:oid,:oid])
address ALGsubouterjoin
comment "Left outer join";
command subouterjoin(l:bat[:oid,:any_1],r:bat[:oid,:any_1],sl:bat[:oid,:oid],sr:bat[:oid,:oid]) (:bat[:oid,:oid],:bat[:oid,:oid])
address ALGsubouterjoin4
comment "Left outer join with candidate lists";

command subthetajoin(l:bat[:oid,:any_1],r:bat[:oid,:any_1],op:str) (:bat[:oid,:oid],:bat[:oid,:oid])
address ALGsubthetajoin
comment "Theta join";
command subthetajoin(l:bat[:oid,:any_1],r:bat[:oid,:any_1],sl:bat[:oid,:oid],sr:bat[:oid,:oid],op:str) (:bat[:oid,:oid],:bat[:oid,:oid])
address ALGsubthetajoin4
comment "Theta join with candidate lists";

# @+ Projection operations
command project(b:bat[:any_1,:any_2]) :bat[:any_1,:void]
address ALGprojectNIL
comment "Extract the head of a BAT.";

pattern project(v:any_3,b:bat[:any_2,:any_1]) :bat[:any_3,:any_1]
address ALGprojecthead
comment "Fill the head with a constant, e.g. [0~b]";
pattern project(b:bat[:any_2,:any_1],v:any_3) :bat[:any_2,:any_3]
address ALGprojecttail
comment "Fill the tail with a constant, e.g. [0~b]";

# @+ OID Introducing Commands
# For relational processing, some operators are necessary to produce newly
# initiated OID columns, for representing n-ary (intermediary) relations.
command markT( b:bat[:any_1,:any_2], base:oid ) :bat[:any_1,:oid] 
address ALGtmark
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
		the tail that starts at base (i.e. [base,..base+b.count()-1] ).";

command markT( b:bat[:any_1,:any_2] ) :bat[:any_1,:oid] 
address ALGtmark_default
comment "Produces a BAT with fresh unique OIDs in the tail starting at 0@0.";

command markT( b:bat[:any_1,:any_2], nr_parts:int, part_nr:int ) :bat[:any_1,:oid] 
address ALGtmarkp
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
	the tail that starts at base (i.e. [base,..base+b.count()-1] ).
	The base is uniquely defined by the part_nr (ie we set the highest
	bits based on the part_nr/nr_parts) ";


command markH( b:bat[:any_1,:any_2] ) :bat[:oid,:any_2] 
address ALGmarkHead_default
comment "Produces a BAT with fresh OIDs in the head starting at 0@0.";

command markH( b:bat[:any_1,:any_2], base:oid ) :bat[:oid,:any_2] 
address ALGmarkHead
comment "Produces a new BAT with fresh unique dense sequense of OIDs in 
		the head that starts at base (i.e. [base,..base+b.count()-1] ).";

command markH( b:bat[:any_1,:any_2], nr_parts:int, part_nr:int ) :bat[:oid,:any_2] 
address ALGhmarkp
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
	the head that starts at base (i.e. [base,..base+b.count()-1] ).
	The base is uniquely defined by the part_nr (ie we set the highest
	bits based on the part_nr/nr_parts) ";


command mark_grp( b:bat[:any_1,:oid], g:bat[:oid,:oid]) :bat[:any_1,:oid]
address ALGmark_grp_1
comment "\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequence of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extent, i.e., the head is the unique list of group IDs
 from b's tail. The tail of g gives for each group the base value for the new
 OID sequence.";

command mark_grp(b:bat[:any_1,:oid], g:bat[:oid,:any_2], s:oid) :bat[:any_1,:oid]
address ALGmark_grp_2
comment "\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extent, i.e., the head is the unique list of group IDs
 from b's tail. The third argument (s) gives the base value for the new
 OID sequence of each group.";

command merge(b:bat[:oid,:oid]):bat[:lng,:oid]
address ALGmerge
comment "Merge head and tail into a single value";

command split(b:bat[:lng,:oid]):bat[:oid,:oid]
address ALGsplit
comment "Split head into two values";

# @+ BAT fragmentation commands
# Various operations for splitting BATs into useful fragments.
#
# @- Variable management
# It is sometimes needed to cast a type at runtime
command materialize(b:bat[:oid,:any_1]):bat[:oid,:any_1]
address ALGmaterialize
comment "Materialize the void column";

command reuse(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address ALGreuse
comment "Reuse a temporary BAT if you can. Otherwise,
	allocate enough storage to accept result of an
 	operation (not involving the heap)";

# @+ Common BAT Aggregates
# These operations examine a BAT, and compute some simple aggregate result
# over it.
# @- BAT size
module aggr;

command count( b:bat[:any_1,:any] ) :wrd 
address ALGcount_bat
comment "Return the current size (in number of elements) in a BAT.";
command count ( b:bat[:any_1,:any], ignore_nils:bit ) :wrd 
address ALGcount_nil
comment "Return the number of elements currently in a BAT ignores 
		BUNs with nil-tail iff ignore_nils==TRUE.";
command count_no_nil ( b:bat[:any_1,:any_2]) :wrd
address ALGcount_no_nil
comment "Return the number of elements currently 
	in a BAT ignoring BUNs with nil-tail";
# @- Histogram on Tail
command histogram ( b:bat[:any_1,:any_2]) :bat[:any_2,:int] 
address ALGhistogram
comment "Produce a BAT containing the histogram over the tail values.";

# @- Default Min and Max
# Implementations a generic Min and Max routines get declared first. The
# @emph{min()} and @emph{max()} routines below catch any tail-type.
# The type-specific routines defined later are faster, and will
# override these any implementations.
command cardinality( b:bat[:any_1,:any_2] ) :lng 
address ALGcard
comment "Return the cardinality of the BAT tail values.";

# Implementations a generic Min and Max routines get declared first. The
# @emph{ min()} and @emph{ max()} routines below catch any tail-type.
# The type-specific routines defined later are faster, and will
# override these any implementations.

command min(b:bat[:any_1,:any_2]):any_2 
address ALGminany
comment "Return the lowest tail value or nil.";

command max(b:bat[:any_1,:any_2]):any_2 
address ALGmaxany
comment "Return the highest tail value or nil.";

@= avg_definition
command avg (b:bat[:any_1,:@1] ) :dbl
address ALGavg
comment "Gives the avg of all tail values";
@
@mal
@:avg_definition(bte)@
@:avg_definition(sht)@
@:avg_definition(int)@
@:avg_definition(wrd)@
@:avg_definition(lng)@
@:avg_definition(flt)@
@:avg_definition(dbl)@

# @- Standard deviation
# The standard deviation of a set is the square root of its variance.
# The variance is the sum of squares of the deviation of each value in the set
# from the mean (average) value, divided by the population of the set.
@= stdev_definition
command stdev (b:bat[:any_1,:@1] ) :dbl
address ALGstdev
comment "Gives the standard deviation of all tail values";
command stdevp (b:bat[:any_1,:@1] ) :dbl
address ALGstdevp
comment "Gives the standard deviation of all tail values";
command variance (b:bat[:any_1,:@1] ) :dbl
address ALGvariance
comment "Gives the variance of all tail values";
command variancep (b:bat[:any_1,:@1] ) :dbl
address ALGvariancep
comment "Gives the variance of all tail values";
@
@mal
@:stdev_definition(bte)@
@:stdev_definition(sht)@
@:stdev_definition(int)@
@:stdev_definition(wrd)@
@:stdev_definition(lng)@
@:stdev_definition(flt)@
@:stdev_definition(dbl)@

@= aggregate_definition
command @1 ( b:bat[:any_1,:@2] ) :@2 
address ALG@1_@2 comment @3;
@= aggregate
@:aggregate_definition(@1,bte,@2)@
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,wrd,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@
@mal
@:aggregate(max,"Give the highest tail value.")@
@:aggregate(min,"Give the lowest tail value. ")@

# @+ Exented selection predicates
# For SQL convenience we provide a serie of interval selectors.
module algebra;
# @+ Modeling With Properties
# The Monet kernel performs run-time optimizations. To choose between
# alternative algorithms in a sensible way, it maintains knowledge about
# each BAT, sometimes as a BAT property, sometimes as two
# column properties for each column (head and tail)
# of a BAT. An example of the former is size(bat):int
# (which gives the number of BUNs in a BAT), an example
# of the latter is ordered(column) :bit, indicating
# whether the column contains its valued stored in ascending order.
# The convention is to use a BAT as operand also for the column
# properties; which then is supposed to be valid for the head
# column (ordered(BAT)). Tail columns can be described by
# using the mirror BAT with the minus operator (ordered(-BAT)).
#
# @- Column Properties
# @table @code
# @item [ordered(BAT) :bit]
# 	TRUE if the head column is stored in ascending order, else FALSE.
# @item [keyed(BAT) :bit]
# 	TRUE if no duplicates are present in the head column, else FALSE.
# @item [idx(BAT) :bit]
# 	TRUE if a binary index tree search accelerator is present on
# 	the head column of the BAT, else FALSE.
# @item [hashtab(BAT) :bit]
# 	presence of hash table on the head column of
# 	a BAT. TRUE if a bucket-chained hash table search accelerator is
# 	present on the head column of the BAT, else FALSE.
# @item [subcol(BAT, BAT) :bit]
# 	TRUE if the bag of all values in the head column of the left BAT is
# 	a bag-subset of the bag of all values in the head column of the
# 	right BAT, else FALSE.
# @item [sync(BAT) :oid]
# 	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
# 	sequence of values. If two columns have the same sync-OID, then they
# 	are guaranteed to contain the same values, in the same sequence.
#
# @item [size(BAT) :int]
# 	The (estimated) length of a column.
# @item [unique(BAT) :int]
# 	The (estimated) number of distinct values in one column.
# @item [subset(BAT, BAT) :bit]
# 	TRUE if the left BAT is a subset of the BUNs of the right BAT,
# 	else FALSE.
# @item [setunique(BAT) :bit]
# 	TRUE if the BAT contains no duplicate BUNs, else FALSE.
# @end table
#
# @- Property Propagation Rules
# At database creation time, the properties of the BATs in the database
# can be derived directly from the database schema.
#
# When queries are executed, they will produce @emph{intermediate results},
# which in terms are operands for further execution. Hence it is necessary
# to @emph{propagate properties} from the operands of an algebraic operator,
# to its result.
#
# This process can be captured by having a series of @emph{propagation rules}
# for each algebraic operand. Since each algebraic operands may apply
# different strategies, according to different status in its operand properties,
# each algebraic operator may have different propagation rules with these
# different situations as conditions.

@h
#ifndef ALGEBRA_H
#define ALGEBRA_H

#include <gdk.h>
#include "mal_exception.h"
#include "mal_interpreter.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define algebra_export extern __declspec(dllimport)
#else
#define algebra_export extern __declspec(dllexport)
#endif
#else
#define algebra_export extern
#endif

algebra_export ptr BATmax(BAT *b, ptr aggr);
algebra_export ptr BATmin(BAT *b, ptr aggr);

algebra_export str ALGavg(dbl *res, int *bid);

algebra_export str ALGstdev(dbl *res, int *bid);
algebra_export str ALGstdevp(dbl *res, int *bid);
algebra_export str ALGvariance(dbl *res, int *bid);
algebra_export str ALGvariancep(dbl *res, int *bid);

@= ALGaggregate_export
algebra_export str ALGmin_@1(@1* res, int *bid) ;
algebra_export str ALGmax_@1(@1* res, int *bid) ;
@
@h
@:ALGaggregate_export(bte)@
@:ALGaggregate_export(sht)@
@:ALGaggregate_export(int)@
@:ALGaggregate_export(wrd)@
@:ALGaggregate_export(lng)@
@:ALGaggregate_export(flt)@
@:ALGaggregate_export(dbl)@

algebra_export str ALGminany(ptr result, int *bid);
algebra_export str ALGmaxany(ptr result, int *bid);
algebra_export str ALGtopN(int *res, int *bid, lng *top);
algebra_export str ALGgroupby(int *res, int *gids, int *cnts);
algebra_export str ALGcard(lng *result, int *bid);
algebra_export str ALGBATminimum(ptr *result, int *bid);
algebra_export str ALGBATmaximum(ptr *result, int *bid);
algebra_export str ALGsubselect1(bat *result, bat *bid, const void *low, const void *high, const bit *li, const bit *hi, const bit *anti);
algebra_export str ALGsubselect2(bat *result, bat *bid, bat *sid, const void *low, const void *high, const bit *li, const bit *hi, const bit *anti);
algebra_export str ALGthetasubselect1(bat *result, bat *bid, const void *val, const char **op);
algebra_export str ALGthetasubselect2(bat *result, bat *bid, bat *sid, const void *val, const char **op);
algebra_export str ALGselect1(int *result, int *bid, ptr value);
algebra_export str ALGselect1Head(int *result, int *bid, ptr value);
algebra_export str ALGuselect1(int *result, int *bid, ptr value);
algebra_export str ALGthetauselect(int *result, int *bid, ptr value, str *op);
algebra_export str ALGantiuselect1(int *result, int *bid, ptr value);
algebra_export str ALGselect(int *result, int *bid, ptr low, ptr high);
algebra_export str ALGthetaselect(int *result, int *bid, ptr low, str *op);
algebra_export str ALGselectHead(int *result, int *bid, ptr low, ptr high);
algebra_export str ALGuselect(int *result, int *bid, ptr low, ptr high);
algebra_export str ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGselectInclusiveHead(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGantiuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGfragment(int *result, int *bid, ptr hlow, ptr hhigh, ptr tlow, ptr thigh);

algebra_export str ALGantijoin2(int *l, int *r, int *lid, int *rid);
algebra_export str ALGjoin2(int *l, int *r, int *lid, int *rid);
algebra_export str ALGthetajoin2(int *l, int *r, int *lid, int *rid, int *opc);
algebra_export str ALGcrossproduct2(int *l, int *r, int *lid, int *rid);
algebra_export str ALGbandjoin2(int *l, int *r, int *lid, int *rid, ptr *minus, ptr *plus, bit *li, bit *hi);
algebra_export str ALGrangejoin2(int *l, int *r, int *lid, int *rlid, int *rhid, bit *li, bit *hi);

algebra_export str ALGthetajoinEstimate(int *result, int *lid, int *rid, int *opc, lng *estimate);
algebra_export str ALGthetajoin(int *result, int *lid, int *rid, int *opc);
algebra_export str ALGbandjoin_default(int *result, int *lid, int *rid, ptr *minus, ptr *plus);
algebra_export str ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus, bit *li, bit *hi);
algebra_export str ALGrangejoin(int *result, int *lid, int *rlid, int *rhid, bit *li, bit *hi);
algebra_export str ALGsubleftjoin(bat *r1, bat *r2, bat *l, bat *r);
algebra_export str ALGsubleftjoin4(bat *r1, bat *r2, bat *l, bat *r, bat *sl, bat *sr);
algebra_export str ALGsubouterjoin(bat *r1, bat *r2, bat *l, bat *r);
algebra_export str ALGsubouterjoin4(bat *r1, bat *r2, bat *l, bat *r, bat *sl, bat *sr);
algebra_export str ALGsubthetajoin(bat *r1, bat *r2, bat *l, bat *r, str *op);
algebra_export str ALGsubthetajoin4(bat *r1, bat *r2, bat *l, bat *r, bat *sl, bat *sr, str *op);

@= ALGunaryExport
algebra_export str ALG@1(int *result, int *bid);
@= ALGunaryintExport
algebra_export str ALG@1(int *result, int *bid);
@= ALGbinaryExport
algebra_export str ALG@1(int *result, int *lid, int *rid) ;
@= ALGbinaryintExport
algebra_export str ALG@1(int *result, int* bid, int *param) ;
@= ALGbinaryestimateExport
algebra_export str ALG@1estimate(int *result, int *lid, int *rid, lng *estimate);
algebra_export str ALG@1(int *result, int* lid, int *rid);
@
@h
@:ALGunaryExport(histogram)@
@:ALGunaryExport(merge)@
@:ALGunaryExport(split)@
@:ALGunaryExport(copy)@
@:ALGunaryExport(kunique)@
@:ALGunaryExport(sunique)@
@:ALGunaryExport(tunique)@
@:ALGbinaryExport(cross)@
@:ALGbinaryExport(antijoin)@
@:ALGbinaryestimateExport(join)@
@:ALGbinaryestimateExport(fetchjoin)@
@:ALGbinaryestimateExport(leftjoin)@
@:ALGbinaryestimateExport(leftfetchjoin)@
@:ALGbinaryestimateExport(outerjoin)@
@:ALGbinaryExport(semijoin)@
@:ALGbinaryExport(sunion)@
@:ALGbinaryExport(kunion)@
@:ALGbinaryExport(tunion)@
@:ALGbinaryExport(sintersect)@
@:ALGbinaryExport(tintersect)@
@:ALGbinaryExport(tinter)@
@:ALGbinaryExport(sdiff)@
@:ALGbinaryExport(kdiff)@
@:ALGbinaryExport(tdifference)@
@:ALGbinaryExport(tdiff)@
@:ALGbinaryintExport(sample)@
@:ALGbinaryintExport(subsample)@

algebra_export str ALGtunique(int *result, int *bid);
algebra_export str ALGtsort(int *result, int *bid);
algebra_export str ALGtsort_rev(int *result, int *bid);
algebra_export str ALGhsort(int *result, int *bid);
algebra_export str ALGhsort_rev(int *result, int *bid);
algebra_export str ALGhtsort(int *result, int *lid);
algebra_export str ALGthsort(int *result, int *lid);
algebra_export str ALGssort(int *result, int *bid);
algebra_export str ALGssort_rev(int *result, int *bid);
algebra_export str ALGsubsort11(bat *result, bat *bid, bit *reverse, bit *stable);
algebra_export str ALGsubsort12(bat *result, bat *norder, bat *bid, bit *reverse, bit *stable);
algebra_export str ALGsubsort13(bat *result, bat *norder, bat *ngroup, bat *bid, bit *reverse, bit *stable);
algebra_export str ALGsubsort21(bat *result, bat *bid, bat *order, bit *reverse, bit *stable);
algebra_export str ALGsubsort22(bat *result, bat *norder, bat *bid, bat *order, bit *reverse, bit *stable);
algebra_export str ALGsubsort23(bat *result, bat *norder, bat *ngroup, bat *bid, bat *order, bit *reverse, bit *stable);
algebra_export str ALGsubsort31(bat *result, bat *bid, bat *order, bat *group, bit *reverse, bit *stable);
algebra_export str ALGsubsort32(bat *result, bat *norder, bat *bid, bat *order, bat *group, bit *reverse, bit *stable);
algebra_export str ALGsubsort33(bat *result, bat *norder, bat *ngroup, bat *bid, bat *order, bat *group, bit *reverse, bit *stable);
algebra_export str ALGrevert(int *result, int *bid);
algebra_export str ALGcount_bat(wrd *result, int *bid);
algebra_export str ALGcount_nil(wrd *result, int *bid, bit *ignore_nils);
algebra_export str ALGcount_no_nil(wrd *result, int *bid);
algebra_export str ALGtmark(int *result, int *bid, oid *base);
algebra_export str ALGtmark_default(int *result, int *bid);
algebra_export str ALGtmarkp(int *result, int *bid, int *nr_parts, int *part_nr);
algebra_export str ALGmarkHead(int *result, int *bid, oid *base);
algebra_export str ALGmarkHead_default(int *result, int *bid);
algebra_export str ALGhmarkp(int *result, int *bid, int *nr_parts, int *part_nr);
algebra_export str ALGmark_grp_1(int *result, int *bid, int *gid);
algebra_export str ALGmark_grp_2(int *result, int *bid, int *gid, oid *base);
algebra_export str ALGhistogram_rev(int *result, int *bid);
algebra_export str ALGlike(int *ret, int *bid, str *k);
algebra_export str ALGslice(int *ret, bat *bid, lng *start, lng *end);
algebra_export str ALGslice_int(int *ret, bat *bid, int *start, int *end);
algebra_export str ALGslice_wrd(int *ret, bat *bid, wrd *start, wrd *end);
algebra_export str ALGslice_oid(int *ret, bat *bid, oid *start, oid *end);
algebra_export str ALGsubslice_wrd(int *ret, bat *bid, wrd *start, wrd *end);
algebra_export str ALGposition(wrd *retval, int *bid, ptr val);
algebra_export str ALGpositionBUN(wrd *retval, int *bid, ptr val, ptr tval);
algebra_export str ALGfetch(ptr ret, int *bid, lng *pos);
algebra_export str ALGfetchoid(int *ret, int *bid, oid *pos);
algebra_export str ALGfetchint(int *ret, int *bid, int *pos);
algebra_export str ALGfetchbat(int *ret, int *bid, int *sid);
algebra_export str ALGexist(bit *ret, int *bid, ptr val);
algebra_export str ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval);
algebra_export str ALGfind(ptr ret, int *bid, ptr val);
algebra_export str ALGhashjoin(int *result, int *lid, int *rid);
algebra_export str ALGmergejoin(int *result, int *lid, int *rid);
algebra_export str ALGindexjoin(int *result, int *lid, int *rid);
algebra_export str ALGprojectNIL(int *ret, int *bid);
algebra_export str ALGselectNotNil(int *result, int *bid);

algebra_export str ALGprojecthead(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
algebra_export str ALGprojecttail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

algebra_export str ALGidentity(int *ret, int *bid);
algebra_export str ALGmaterialize(int *ret, int *bid);
algebra_export str ALGreuse(int *ret, int *bid);
#endif
@c
#include "monetdb_config.h"
#include "algebra.h"
#include "gdk_rangejoin.h"
#include <math.h>

/*
 * @* Command Implementations in C
 * This module contains just a wrapper implementations; since all described
 * operations are part of the GDK kernel.
 *
 * @+ BAT sum operation
 * The sum aggregate only works for int and float fields.
 * The routines below assumes that the caller knows what type
 * is large enough to prevent overflow.
 */

/* @+ Minimum and Maximum
 * The routines @`BATmin@5(b) and @`BATmax@5(b) compute the minimum and
 * maximum value of the tail column of a BAT.
 * Aggregate values are calculated just before they are requested by
 * the user. They are not maintained continuously, because we expect
 * them to be used sparsely.
 */
@= aggregate_implementation
static int
CMDmin_@1(@1* result, BAT *b)
{
	return BATmin(b, result)?GDK_SUCCEED:GDK_FAIL;
}
static int
CMDmax_@1(@1* result, BAT *b)
{
	return BATmax(b, result)?GDK_SUCCEED:GDK_FAIL;
}
@= atomaggr
	if (s > 0 && !BATtordered(b)) {
		char* nil = BATatoms[t].atomNull;
		BUN p,q;

		if (b->T->nonil) {
			BATloop(b, p, q) {
				x = (ptr) BUNt@2(bi, p);
				if (@3_@5(x, v, @4)) {
					v = x;
				}
			}
		} else {
			BATloop(b, p, q) {
				x = (ptr) BUNt@2(bi, p);
				if (@3_CMP(x, nil, @4) == 0) {
					v = nil;
					break;
				}
				if (@3_@5(x, v, @4)) {
					v = x;
				}
			}
		}
	}
	if (aggr) {
		memcpy(aggr, x=v, ATOMsize(t));
	} else {
		/* alloc new space and copy the atom into it */
		s = ATOMlen(t, v);
		x = GDKmalloc(s);
		if (x)
			memcpy(x, v, s);
	}
@= voidaggr
	if (aggr) {
		*(oid *) aggr = *(oid *) (x=v);
	} else {
		/* alloc new space and copy the atom into it */
		x = GDKmalloc(sizeof(oid));
		if (x)
			memcpy(x, v, s);
	}
@= aggrmin
	v = (s == 0)?ATOMnilptr(t):BUNtail(bi, BUNfirst(b));
	@:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
	v = (s == 0)?ATOMnilptr(t):BUNtail(bi, BUNlast(b)-1);
	@:@5aggr(@1,@2,@3,@4,GT)@

@= BATaggr
ptr
BAT@1(BAT *b, ptr aggr)
{
	BATiter bi = bat_iterator(b);
	int t;
	BUN s;
	ptr v, x;

	BATcheck(b, "BAT@1");
	s = BATcount(b);
	t = b->ttype;
	if (BATtvoid(b)) {
		@:aggr@1(bte,loc,simple,bte,void)@
	} else {
		switch(ATOMstorage(t)) {
		case TYPE_bte:
			@:aggr@1(bte,loc,simple,bte,atom)@
			break;
		case TYPE_sht:
			@:aggr@1(sht,loc,simple,sht,atom)@
			break;
		case TYPE_int:
			@:aggr@1(int,loc,simple,int,atom)@
			break;
		case TYPE_flt:
			@:aggr@1(flt,loc,simple,flt,atom)@
			break;
		case TYPE_dbl:
			@:aggr@1(dbl,loc,simple,dbl,atom)@
			break;
		case TYPE_lng:
			@:aggr@1(lng,loc,simple,lng,atom)@
			break;
		default:
			if (b->tvarsized) {
				@:aggr@1(bte,var,atom,t,atom)@
				break;
			} else {
				@:aggr@1(bte,loc,atom,t,atom)@
				break;
			}
		}
	}
	return x;
}
@
@c
@:BATaggr(min)@
@:BATaggr(max)@

@:aggregate_implementation(bte)@
@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(wrd)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

static int
CMDminany(ptr result, BAT *b)
{
	if (!ATOMlinear(b->ttype))
		return GDKerror("CMDminANY: atom '%s' cannot be ordered linearly\n", ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		return (*(ptr *) result = BATmin(b, NULL)) ? GDK_SUCCEED : GDK_FAIL;
	}
	if (BATmin(b, result)) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

static int
CMDmaxany(ptr result, BAT *b)
{
	if (!ATOMlinear(b->ttype))
		return GDKerror("CMDmaxANY: atom '%s' cannot be ordered linearly\n", ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		return (*(ptr *) result = BATmax(b, NULL)) ? GDK_SUCCEED : GDK_FAIL;
	}
	if (BATmax(b, result)) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

/*
 * @* Command Implementations in C
 * This module contains just a wrapper implementations; since all described
 * operations are part of the GDK kernel.
 */
static int
CMDselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATselect_(b, low, high, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

static int
CMDuselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDuselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDuselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATuselect_(b, low, high, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

static int
CMDantiuselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDantiuselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDantiuselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATantiuselect_(b, low, high, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

static int
CMDgen_group(BAT **result, BAT *gids, BAT *cnts )
{
	wrd j, gcnt = BATcount(gids);
	BAT *r = BATnew(TYPE_void, TYPE_oid, BATcount(gids)*2);

	BATseqbase(r, 0);
	if (gids->ttype == TYPE_void) {
		oid id = gids->hseqbase;
		wrd *cnt = (wrd*)Tloc(cnts, 0);
		for(j = 0; j < gcnt; j++) {
			wrd i, sz = cnt[j];
			for(i = 0; i < sz; i++) {
				if (BUNappend(r, &id, FALSE) == NULL) {
					BBPreclaim(r);
					return GDK_FAIL;
				}
			}
			id++;
		}
	} else {
		oid *id = (oid*)Tloc(gids, 0);
		wrd *cnt = (wrd*)Tloc(cnts, 0);
		for(j = 0; j < gcnt; j++) {
			wrd i, sz = cnt[j];
			for(i = 0; i < sz; i++) {
				if (BUNappend(r, id, FALSE) == NULL) {
					BBPreclaim(r);
					return GDK_FAIL;
				}
			}
			id++;
		}
	}
	r -> hdense = TRUE;
	r -> hsorted = TRUE;
	r -> hrevsorted = FALSE;
	r -> tsorted = BATtordered(gids);
	r -> trevsorted = BATtrevordered(gids);
	r -> T ->nonil = gids->T->nonil;
	*result = r;
	return GDK_SUCCEED;
}


/*
 * @- Substring Select
 * The string pattern matching routine has been added. It should be
 * dynamically linked.
 * A simple string matcher is included. It should be refined later on
 */
static inline int
like(char *x, char *y, BUN ylen)
{
	char *r;

	if (x == (char *) NULL) {
		return 0;
	}
	for (r = x + strlen(x) - ylen; x <= r; x++) {
		int ok = 1;
		char *s = x;
		char *q;

		for (q = y; *q; q++, s++)
			if (*q != tolower(*s)) {
				ok = 0;
				break;
			}
		if (ok)
			return 1;
	}
	return 0;
}

static int
CMDlike(BAT **ret, BAT *b, str s)
{
	BATiter bi = bat_iterator(b);
	BAT *c = BATnew(BAThtype(b), TYPE_str, BATcount(b) / 10);
	str t;
	BUN u, v;
	BUN yy = 0;

	if (c == NULL)
		return GDK_FAIL;
	t = GDKstrdup(s);
	for (s = t; *s; s++, yy++)
		*s = tolower(*s);

	if (b->hvarsized) {
		BATloop(b, u, v)
			if (like(BUNtvar(bi, u), t, yy) &&
				BUNfastins(c, BUNhvar(bi, u), BUNtvar(bi, u)) == NULL) {
				BBPreclaim(c);
				GDKfree(t);
				return GDK_FAIL;
			}
	} else {
		BATloop(b, u, v)
			if (like(BUNtvar(bi, u), t, yy) &&
				BUNfastins(c, BUNhloc(bi, u), BUNtvar(bi, u)) == NULL) {
				BBPreclaim(c);
				GDKfree(t);
				return GDK_FAIL;
			}
	}
	c->hsorted = BAThordered(b);
	c->hrevsorted = BAThrevordered(b);
	c->tsorted = BATtordered(b);
	c->trevsorted = BATtrevordered(b);
	c->H->nonil = b->H->nonil;
	c->T->nonil = b->T->nonil;
	*ret = c;
	GDKfree(t);
	return GDK_SUCCEED;
}

/*
 * @- BAT slice
 */
static int
slice(BAT **retval, BAT *b, lng start, lng end)
{
	/* the internal BATslice requires exclusive end */
	if (start < 0) {
		GDKerror("CMDslice: start position of slice should >= 0\n");
		return GDK_FAIL;
	}
	if (end == lng_nil) 
		end = BATcount(b);
	if (start > (lng) BUN_MAX || end >= (lng) BUN_MAX) {
		GDKerror("CMDslice: argument out of range\n");
		return GDK_FAIL;
	}

	return (*retval = BATslice(b, (BUN) start, (BUN) end + 1)) ? GDK_SUCCEED : GDK_FAIL;
}

/*
 * @- BUN Get/Fetch
 */
static int
CMDposition(wrd *retval, BAT *b, ptr val)
{
	BUN v = BUNfnd(b, val);

	if (v == BUN_NONE)
		return GDK_FAIL;
	*retval = (wrd) (v - BUNfirst(b));
	return GDK_SUCCEED;
}

static int
CMDpositionBUN(wrd *retval, BAT *b, ptr val, ptr tval)
{
	BUN v = BUNlocate(b, val, tval);

	if (v == BUN_NONE)
		return GDK_FAIL;
	*retval = (wrd) (v - BUNfirst(b));
	return GDK_SUCCEED;
}

static int
CMDexist(bit *ret, BAT *b, ptr val)
{
	BUN q = BUNfnd(b, val);

	*ret = (q != BUN_NONE) ? 1 : 0;
	return GDK_SUCCEED;
}
static int
CMDexistBUN(bit *ret, BAT *b, ptr val, ptr tval)
{
	BUN q = BUNlocate(b, val, tval);

	*ret = (q != BUN_NONE) ? 1 : 0;
	return GDK_SUCCEED;
}

static BAT *
BATmerge(BAT *b)
{
	BUN n = BATcount(b);
	BAT *bn = BATnew(TYPE_lng, TYPE_void, n);
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	BUN p, q;
	lng *r = (lng *) BUNhead(bni, BUNfirst(bn));

	BATloop(b, p, q) {
		oid hp = *(oid *) BUNhead(bi, p);
		oid tp = *(oid *) BUNtail(bi, p);

		*r++ = (((lng) hp) << 32) + tp;
	}
	BATsetcount(bn, p);
	if (!bn->batDirty)
		bn->batDirty = TRUE;

	bn->hsorted = BAThordered(b) && (BATtordered(b) || BAThkey(b));
	bn->hrevsorted = BAThrevordered(b) && (BATtrevordered(b) || BAThkey(b));
	bn->tsorted = FALSE ;
	bn->trevsorted = FALSE ;
	bn->tdense = FALSE ;
	BATkey(bn, BAThkey(b) || BATtkey(b)) ;
	BATkey(BATmirror(bn), FALSE) ;

	return bn;
}

static BAT *
BATsplit(BAT *b)
{
	BATiter bi = bat_iterator(b);
	BUN n = BATcount(b);
	BAT *bn = BATnew(TYPE_oid, TYPE_oid, n);
	BUN i;
	lng *r = (lng *) BUNhead(bi, BUNfirst(b));

	for (i = 0; i < n; i++, r++) {
		oid hp = (int) (*r >> 32);
		oid tp = (int) *r;

		bunfastins(bn, &hp, &tp);
	}

	bn->hsorted = BAThordered(b) ;
	bn->hrevsorted = BAThrevordered(b) ;
	bn->tsorted = FALSE ;
	bn->trevsorted = FALSE ;
	bn->hdense = FALSE ;
	bn->tdense = FALSE ;
	bn->H->nonil = FALSE ;
	bn->T->nonil = FALSE ;
	BATkey(bn, FALSE) ;
	BATkey(BATmirror(bn), FALSE) ;

	return bn;
bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

/*
 * @- Wrapper
 * The remainder of this file contains the wrapper around the V4 code base
 * The BAT identifiers passed through this module may indicate
 * that the 'reverse' view applies. This should be taken into
 * account while resolving them.
 * @+ BAT sum and product aggregation
 * The sum aggregate only works for int and float fields.
 * The routines below assumes that the caller knows what type
 * is large enough to prevent overflow.
 */

@= ALGaggregate_implementation
str ALGmin_@1(@1* res, int *bid) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if( CMDmin_@1(res,b)) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.min", GDK_EXCEPTION);
}
str ALGmax_@1(@1* res, int *bid) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if( CMDmax_@1(res,b)) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.max", GDK_EXCEPTION);
}
@
@c
@:ALGaggregate_implementation(bte)@
@:ALGaggregate_implementation(sht)@
@:ALGaggregate_implementation(int)@
@:ALGaggregate_implementation(wrd)@
@:ALGaggregate_implementation(lng)@
@:ALGaggregate_implementation(flt)@
@:ALGaggregate_implementation(dbl)@


str
ALGminany(ptr result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if (CMDminany(result, b) == GDK_SUCCEED) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.min", GDK_EXCEPTION);
}

str
ALGmaxany(ptr result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.max", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmaxany(result, b) == GDK_SUCCEED) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.max", GDK_EXCEPTION);
}

str
ALGtopN(int *res, int *bid, lng *top)
{
	BAT *b;

	b = BATdescriptor(*bid);
	if (b == NULL) {
		throw(MAL, "algebra.top", RUNTIME_OBJECT_MISSING);
	}
	/* TOP N works inplace, ie deletes ... */
	(void) BATtopN(b, (BUN) *top);
	*res = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGgroupby(int *res, int *gids, int *cnts)
{
	BAT *bn, *g, *c;

	g = BATdescriptor(*gids);
	if (g == NULL) {
		throw(MAL, "algebra.groupby", RUNTIME_OBJECT_MISSING);
	}
	c = BATdescriptor(*cnts);
	if (c == NULL) {
		BBPreleaseref(g->batCacheid);
		throw(MAL, "algebra.groupby", RUNTIME_OBJECT_MISSING);
	}
	if( CMDgen_group(&bn, g, c) == GDK_FAIL){
		BBPreleaseref(g->batCacheid);
		BBPreleaseref(c->batCacheid);
		throw(MAL, "algebra.groupby",GDK_EXCEPTION);
	}
	if( bn){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*res = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
	}
	BBPreleaseref(g->batCacheid);
	BBPreleaseref(c->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcard(lng *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.card", RUNTIME_OBJECT_MISSING);
	}
	bn = (BAT *) BATkunique(BATmirror(b));
	if (bn == NULL) {
		throw(MAL, "algebra.card", GDK_EXCEPTION);
	}
	*result = BATcount(bn);
	BBPunfix(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGBATminimum(ptr *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	BATmin(b, result);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGBATmaximum(ptr *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.max", RUNTIME_OBJECT_MISSING);
	}
	BATmax(b, result);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGsubselect2(bat *result, bat *bid, bat *sid, const void *low, const void *high, const bit *li, const bit *hi, const bit *anti)
{
	BAT *b, *s = NULL, *bn;
	const void *nilptr;

	if ((*li != 0 && *li != 1) ||
		(*hi != 0 && *hi != 1) ||
		(*anti != 0 && *anti != 1)) {
		throw(MAL, "algebra.subselect", ILLEGAL_ARGUMENT);
	}
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	if (sid && (s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	nilptr = ATOMnilptr(b->ttype);
	if (*li == 1 && *hi == 1 && 
		ATOMcmp(b->ttype, low, nilptr) == 0 &&
		ATOMcmp(b->ttype, high, nilptr) == 0) {
		/* special case: equi-select for NIL */
		high = NULL;
	}
	bn = BATsubselect(b, s, low, high, *li, *hi, *anti);
	BBPreleaseref(b->batCacheid);
	if (s)
		BBPreleaseref(s->batCacheid);
	if (bn == NULL)
		throw(MAL, "algebra.subselect", GDK_EXCEPTION);
	*result = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

str
ALGsubselect1(bat *result, bat *bid, const void *low, const void *high, const bit *li, const bit *hi, const bit *anti)
{
	return ALGsubselect2(result, bid, NULL, low, high, li, hi, anti);
}

str
ALGthetasubselect2(bat *result, bat *bid, bat *sid, const void *val, const char **op)
{
	BAT *b, *s = NULL, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	if (sid && (s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,val)@
	bn = BATthetasubselect(b, s, val, *op);
	BBPreleaseref(b->batCacheid);
	if (s)
		BBPreleaseref(s->batCacheid);
	if (bn == NULL)
		throw(MAL, "algebra.subselect", GDK_EXCEPTION);
	*result = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

str
ALGthetasubselect1(bat *result, bat *bid, const void *val, const char **op)
{
	return ALGthetasubselect2(result, bid, NULL, val, op);
}

str
ALGselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,value)@
	bn = BATselect(b, value, 0);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGselect1Head(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	b = BATmirror(b);
	@:derefStr(b,t,value)@
	bn = BATselect(b, value, 0);
	bn = BATmirror(bn);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGuselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.uselect", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,value)@
	bn = BATuselect(b, value, NULL);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2))
			bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGantiuselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.antiuselect", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,value)@
	bn = BATantiuselect_(b, value, NULL, TRUE, TRUE);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.antiuselect", GDK_EXCEPTION);
}

str
ALGselect(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	bn = BATselect(b, low, high);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGthetaselect(int *result, int *bid, ptr val, str *OP)
{
	ptr nilptr;
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.thetaselect", RUNTIME_OBJECT_MISSING);
	}
	nilptr = ATOMnilptr(b->ttype);
	@:derefStr(b,t,val);@
	if (ATOMcmp(b->ttype, val, nilptr) == 0) {
		bn = BATnew(b->htype,b->ttype, 0);
	} else {
		char *op = *OP; 
		bit lin = TRUE, rin = TRUE;
		ptr low = nilptr, high = nilptr;
	
		if (op[0] == '=') {
			low = val; 
			high = val;
		} else if (op[0] == '<') {
			high = val;
			rin = (op[1] == '=');
		} else if (op[0] == '>') {
			low = val;
			lin = (op[1] == '=');
		} else {
			BBPreleaseref(b->batCacheid);
			throw(MAL, "algebra.thetaselect", ILLEGAL_ARGUMENT " Unknown operator");
		}
		CMDselect_(&bn, b, low, high, &lin, &rin);
	}
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.thetaselect", GDK_EXCEPTION);
}

str
ALGselectNotNil(int *result, int *bid)
{
	BAT *b, *bn = NULL;
	ptr low,high;
	bit bound=FALSE;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "algebra.selectNotNil", RUNTIME_OBJECT_MISSING);

	if( BATcount_no_nil(b) != BATcount(b) ){
		low=high= ATOMnilptr(b->ttype);
		CMDselect_(&bn, b, low, high, &bound, &bound);
		if (bn) {
			if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
			*result = bn->batCacheid;
			BBPkeepref(*result);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.select", GDK_EXCEPTION);
	}
	/* just pass on the result */
	*result = b->batCacheid;
	BBPkeepref(*result);
	return MAL_SUCCEED;
}

str
ALGselectHead(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	b = BATmirror(b);
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	bn = BATselect(b, low, high);
	bn = BATmirror(bn);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGuselect(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.uselect", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	bn = BATuselect(b, low, high);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGthetauselect(int *result, int *bid, ptr val, str *OP)
{
	ptr nilptr;
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.thetauselect", RUNTIME_OBJECT_MISSING);
	}
	nilptr = ATOMnilptr(b->ttype);
	@:derefStr(b,t,val);@
	if (ATOMcmp(b->ttype, val, nilptr) == 0) {
		bn = BATnew(b->htype,TYPE_void, 0);
	} else {
		char *op = *OP; 
		bit lin = TRUE, rin = TRUE;
		ptr low = nilptr, high = nilptr;
	
		if (op[0] == '=') {
			low = val; 
			high = val;
		} else if (op[0] == '<') {
			high = val;
			rin = (op[1] == '=');
		} else if (op[0] == '>') {
			low = val;
			lin = (op[1] == '=');
		} else {
			BBPreleaseref(b->batCacheid);
			throw(MAL, "algebra.thetauselect", ILLEGAL_ARGUMENT " Unknown operator");
		}
		CMDuselect_(&bn, b, low, high, &lin, &rin);
	}
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.thetauselect", GDK_EXCEPTION);
}

str
ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn, b, low, high, lin, rin);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGselectInclusiveHead(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	b = BATmirror(b);
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn, b, low, high, lin, rin);
	bn = BATmirror(bn);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect_(&bn, b, low, high, lin, rin);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGantiuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDantiuselect_(&bn, b, low, high, lin, rin);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGfragment(int *result, int *bid, ptr hlow, ptr hhigh, ptr tlow, ptr thigh)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.fragment", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,hlow);@
	@:derefStr(b,h,hhigh);@
	@:derefStr(b,t,tlow);@
	@:derefStr(b,t,thigh);@
	bn = BATrestrict(b, hlow, hhigh, tlow, thigh);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.fragment", GDK_EXCEPTION);
}

str
ALGthetajoinEstimate(int *result, int *lid, int *rid, int *opc, lng *estimate)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.thetajoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.thetajoin", RUNTIME_OBJECT_MISSING);
	}
	if( *opc == -3 ){
		/* The NE case is not supported in the kernel */
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		throw(MAL, "algebra.thetajoin", ILLEGAL_ARGUMENT " Theta comparison <> not yet supported");
	}
	bn = BATthetajoin(left, right, *opc, *estimate == lng_nil || *estimate < 0 ? BUN_NONE : (*estimate >= (lng) BUN_MAX ? BUN_MAX : (BUN) *estimate));
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.thetajoin", GDK_EXCEPTION);
}

str
ALGthetajoin(int *result, int *lid, int *rid, int *opc)
{
	return ALGthetajoinEstimate(result, lid, rid, opc, (ptr)&lng_nil);
}

str
ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus, bit *li, bit *hi)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.bandjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.bandjoin", RUNTIME_OBJECT_MISSING);
	}
	bn = BATbandjoin(left, right, minus, plus, *li, *hi);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.bandjoin", GDK_EXCEPTION);
}

str
ALGbandjoin_default(int *result, int *lid, int *rid, ptr *minus, ptr *plus)
{
	bit li = TRUE;
	bit hi = TRUE;
	return ALGbandjoin(result, lid, rid, minus, plus, &li, &hi);
}

str 
ALGrangejoin(int *result, int *lid, int *rlid, int *rhid, bit *li, bit *hi)
{
	BAT *left, *rightl, *righth, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.rangejoin", RUNTIME_OBJECT_MISSING);
	}
	if ((rightl = BATdescriptor(*rlid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.rangejoin", RUNTIME_OBJECT_MISSING);
	}
	if ((righth = BATdescriptor(*rhid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(rightl->batCacheid);
		throw(MAL, "algebra.rangejoin", RUNTIME_OBJECT_MISSING);
	}
	bn = BATrangejoin(left, rightl, righth, *li, *hi);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(rightl->batCacheid);
		BBPreleaseref(righth->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(rightl->batCacheid);
	BBPreleaseref(righth->batCacheid);
	throw(MAL, "algebra.rangejoin", GDK_EXCEPTION);
}

str
ALGsubleftjoin4(bat *r1, bat *r2, bat *lid, bat *rid, bat *slid, bat *srid)
{
	BAT *left = NULL, *right = NULL, *candleft = NULL, *candright = NULL;
	BAT *result1, *result2;

	if ((left = BATdescriptor(*lid)) == NULL)
		goto fail;
	if ((right = BATdescriptor(*rid)) == NULL)
		goto fail;
	if (slid && (candleft = BATdescriptor(*slid)) == NULL)
		goto fail;
	if (srid && (candright = BATdescriptor(*srid)) == NULL)
		goto fail;

	if (BATsubleftjoin(&result1, &result2, left, right, candleft, candright, BUN_NONE) == GDK_FAIL)
		goto fail;
	*r1 = result1->batCacheid;
	*r2 = result2->batCacheid;
	BBPkeepref(*r1);
	BBPkeepref(*r2);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if (candleft)
		BBPreleaseref(candleft->batCacheid);
	if (candright)
		BBPreleaseref(candright->batCacheid);
	return MAL_SUCCEED;

  fail:
	if (left)
		BBPreclaim(left);
	if (right)
		BBPreclaim(right);
	if (candleft)
		BBPreclaim(candleft);
	if (candright)
		BBPreclaim(candright);
	throw(MAL, "algebra.subleftjoin", RUNTIME_OBJECT_MISSING);
}

str
ALGsubleftjoin(bat *r1, bat *r2, bat *l, bat *r)
{
	return ALGsubleftjoin4(r1, r2, l, r, NULL, NULL);
}

str
ALGsubouterjoin4(bat *r1, bat *r2, bat *lid, bat *rid, bat *slid, bat *srid)
{
	BAT *left = NULL, *right = NULL, *candleft = NULL, *candright = NULL;
	BAT *result1, *result2;

	if ((left = BATdescriptor(*lid)) == NULL)
		goto fail;
	if ((right = BATdescriptor(*rid)) == NULL)
		goto fail;
	if (slid && (candleft = BATdescriptor(*slid)) == NULL)
		goto fail;
	if (srid && (candright = BATdescriptor(*srid)) == NULL)
		goto fail;

	if (BATsubouterjoin(&result1, &result2, left, right, candleft, candright, BUN_NONE) == GDK_FAIL)
		goto fail;
	*r1 = result1->batCacheid;
	*r2 = result2->batCacheid;
	BBPkeepref(*r1);
	BBPkeepref(*r2);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if (candleft)
		BBPreleaseref(candleft->batCacheid);
	if (candright)
		BBPreleaseref(candright->batCacheid);
	return MAL_SUCCEED;

  fail:
	if (left)
		BBPreclaim(left);
	if (right)
		BBPreclaim(right);
	if (candleft)
		BBPreclaim(candleft);
	if (candright)
		BBPreclaim(candright);
	throw(MAL, "algebra.subouterjoin", RUNTIME_OBJECT_MISSING);
}

str
ALGsubouterjoin(bat *r1, bat *r2, bat *l, bat *r)
{
	return ALGsubouterjoin4(r1, r2, l, r, NULL, NULL);
}

str
ALGsubthetajoin4(bat *r1, bat *r2, bat *lid, bat *rid, bat *slid, bat *srid, str *op)
{
	BAT *left = NULL, *right = NULL, *candleft = NULL, *candright = NULL;
	BAT *result1, *result2;

	if ((left = BATdescriptor(*lid)) == NULL)
		goto fail;
	if ((right = BATdescriptor(*rid)) == NULL)
		goto fail;
	if (slid && (candleft = BATdescriptor(*slid)) == NULL)
		goto fail;
	if (srid && (candright = BATdescriptor(*srid)) == NULL)
		goto fail;

	if (BATsubthetajoin(&result1, &result2, left, right, candleft, candright, *op, BUN_NONE) == GDK_FAIL)
		goto fail;
	*r1 = result1->batCacheid;
	*r2 = result2->batCacheid;
	BBPkeepref(*r1);
	BBPkeepref(*r2);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if (candleft)
		BBPreleaseref(candleft->batCacheid);
	if (candright)
		BBPreleaseref(candright->batCacheid);
	return MAL_SUCCEED;

  fail:
	if (left)
		BBPreclaim(left);
	if (right)
		BBPreclaim(right);
	if (candleft)
		BBPreclaim(candleft);
	if (candright)
		BBPreclaim(candright);
	throw(MAL, "algebra.subthetajoin", RUNTIME_OBJECT_MISSING);
}

str
ALGsubthetajoin(bat *r1, bat *r2, bat *l, bat *r, str *op)
{
	return ALGsubthetajoin4(r1, r2, l, r, NULL, NULL, op);
}

static str
ALGunary(int *result, int *bid, BAT *(*func)(BAT *), const char *name)
{
	BAT *b,*bn;

	if ((b= BATdescriptor(*bid)) == NULL) {
		throw(MAL, name, RUNTIME_OBJECT_MISSING);
	}
	bn = (*func)(b);
	BBPreleaseref(b->batCacheid);
	if (bn == NULL)
		throw(MAL, "algebra.@1", GDK_EXCEPTION);
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ);
	*result = bn->batCacheid;
	BBPkeepref(*result);
	return MAL_SUCCEED;
}

static str
ALGbinary(int *result, int *lid, int *rid, BAT *(*func)(BAT *, BAT *), const char *name)
{
	BAT *left, *right,*bn= NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, name, RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, name, RUNTIME_OBJECT_MISSING);
	}
	bn = (*func)(left, right);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if (bn == NULL)
		throw(MAL, name, GDK_EXCEPTION);
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ);
	*result = bn->batCacheid;
	BBPkeepref(*result);
	return MAL_SUCCEED;
}

static str
ALGbinaryint(bat *result, bat *bid, int *param, BAT *(*func)(BAT *, BUN), const char *name)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, name, RUNTIME_OBJECT_MISSING);
	}
	bn = (*func)(b, *param);
	BBPreleaseref(b->batCacheid);
	if (bn == NULL)
		throw(MAL, name, GDK_EXCEPTION);
	if (!(bn->batDirty & 2))
		bn = BATsetaccess(bn, BAT_READ);
	*result = bn->batCacheid;
	BBPkeepref(*result);
	return MAL_SUCCEED;
}

static str
ALGbinaryestimate(int *result, int *lid, int *rid, lng *estimate,
				  BAT *(*func)(BAT *, BAT *, BUN), const char *name)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, name, RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, name, RUNTIME_OBJECT_MISSING);
	}
	bn = (*func)(left, right, estimate ? (BUN) *estimate : BUN_NONE);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if (bn == NULL)
		throw(MAL, name, GDK_EXCEPTION);
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ);
	*result = bn->batCacheid;
	BBPkeepref(*result);
	return MAL_SUCCEED;
}

str
ALGhistogram(bat *result, bat *bid)
{
	return ALGunary(result, bid, BAThistogram, "algebra.histogram");
}

str
ALGmerge(bat *result, bat *bid)
{
	return ALGunary(result, bid, BATmerge, "algebra.merge");
}

str
ALGsplit(bat *result, bat *bid)
{
	return ALGunary(result, bid, BATsplit, "algebra.split");
}

static BAT *
BATwcopy(BAT *b)
{
	return BATcopy(b, b->htype, b->ttype, 1);
}

str
ALGcopy(bat *result, bat *bid)
{
	return ALGunary(result, bid, BATwcopy, "algebra.copy");
}

str
ALGkunique(bat *result, bat *bid)
{
	return ALGunary(result, bid, BATkunique, "algebra.kunique");
}

str
ALGsunique(bat *result, bat *bid)
{
	return ALGunary(result, bid, BATsunique, "algebra.sunique");
}

str
ALGcross(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATcross, "algebra.cross");
}

str
ALGantijoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATantijoin, "algebra.antijoin");
}

str
ALGantijoin2( bat *l, bat *r, bat *left, bat *right)
{
	BAT *L, *R, *j;

	if ((L = BATdescriptor(*left)) == NULL) {
		throw(MAL, "algebra.antijoin", RUNTIME_OBJECT_MISSING);
	}
	if ((R = BATdescriptor(*right)) == NULL) {
		BBPunfix(L->batCacheid);
		throw(MAL, "algebra.antijoin", RUNTIME_OBJECT_MISSING);
	}

	/* j = antijoin(left,reverse(right))
	   l = reverse(mark(j))
	   r = reverse(mark(reverse(j)))
	*/
	j = BATantijoin(L, BATmirror(R));
	if (!j)
		throw(MAL, "algebra.antijoin", GDK_EXCEPTION);
	BBPunfix(L->batCacheid);
	BBPunfix(R->batCacheid);
	L = BATmirror(BATmark(j,0));
	R = BATmirror(BATmark(BATmirror(j),0));
	BBPunfix(j->batCacheid);
	BBPkeepref(*l = L->batCacheid);
	BBPkeepref(*r = R->batCacheid);
	return MAL_SUCCEED;
}

str
ALGjoin2( bat *l, bat *r, bat *left, bat *right)
{
	BAT *L, *R, *j;

	if ((L = BATdescriptor(*left)) == NULL) {
		throw(MAL, "algebra.join", RUNTIME_OBJECT_MISSING);
	}
	if ((R = BATdescriptor(*right)) == NULL) {
		BBPunfix(L->batCacheid);
		throw(MAL, "algebra.join", RUNTIME_OBJECT_MISSING);
	}

	/* j = join(left,reverse(right))
	   l = reverse(mark(j))
	   r = reverse(mark(reverse(j)))
	*/
	j = BATjoin(L, BATmirror(R), BUN_NONE);
	if (!j)
		throw(MAL, "algebra.join", GDK_EXCEPTION);
	BBPunfix(L->batCacheid);
	BBPunfix(R->batCacheid);
	L = BATmirror(BATmark(j,0));
	R = BATmirror(BATmark(BATmirror(j),0));
	BBPunfix(j->batCacheid);
	BBPkeepref(*l = L->batCacheid);
	BBPkeepref(*r = R->batCacheid);
	return MAL_SUCCEED;
}

str
ALGthetajoin2( bat *l, bat *r, bat *left, bat *right, int *opc)
{
	BAT *L, *R, *j;

	if ((L = BATdescriptor(*left)) == NULL) {
		throw(MAL, "algebra.thetajoin", RUNTIME_OBJECT_MISSING);
	}
	if ((R = BATdescriptor(*right)) == NULL) {
		BBPunfix(L->batCacheid);
		throw(MAL, "algebra.thetajoin", RUNTIME_OBJECT_MISSING);
	}

	/* j = thetajoin(left,reverse(right), opc)
	   l = reverse(mark(j))
	   r = reverse(mark(reverse(j)))
	*/
	j = BATthetajoin(L, BATmirror(R), *opc, BUN_NONE);
	if (!j)
		throw(MAL, "algebra.thetajoin", GDK_EXCEPTION);
	BBPunfix(L->batCacheid);
	BBPunfix(R->batCacheid);
	L = BATmirror(BATmark(j,0));
	R = BATmirror(BATmark(BATmirror(j),0));
	BBPunfix(j->batCacheid);
	BBPkeepref(*l = L->batCacheid);
	BBPkeepref(*r = R->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcrossproduct2( bat *l, bat *r, bat *left, bat *right)
{
	BAT *L, *R, *j;

	if ((L = BATdescriptor(*left)) == NULL) {
		throw(MAL, "algebra.crossproduct", RUNTIME_OBJECT_MISSING);
	}
	if ((R = BATdescriptor(*right)) == NULL) {
		BBPunfix(L->batCacheid);
		throw(MAL, "algebra.crossproduct", RUNTIME_OBJECT_MISSING);
	}

	/* j = crossproduct(left,reverse(right))
	   l = reverse(mark(j))
	   r = reverse(mark(reverse(j)))
	*/
	j = BATcross(L, BATmirror(R));
	if (!j)
		throw(MAL, "algebra.crossproduct", GDK_EXCEPTION);
	BBPunfix(L->batCacheid);
	BBPunfix(R->batCacheid);
	L = BATmirror(BATmark(j,0));
	R = BATmirror(BATmark(BATmirror(j),0));
	BBPunfix(j->batCacheid);
	BBPkeepref(*l = L->batCacheid);
	BBPkeepref(*r = R->batCacheid);
	return MAL_SUCCEED;
}
str
ALGbandjoin2(bat *l, bat *r, bat *left, bat *right, ptr *minus, ptr *plus, bit *li, bit *hi)
{
	BAT *L, *R, *j;

	if ((L = BATdescriptor(*left)) == NULL) {
		throw(MAL, "algebra.bandjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((R = BATdescriptor(*right)) == NULL) {
		BBPunfix(L->batCacheid);
		throw(MAL, "algebra.bandjoin", RUNTIME_OBJECT_MISSING);
	}

	/* j = bandjoin(left,reverse(right), minus, plus, li, hi)
	   l = reverse(mark(j))
	   r = reverse(mark(reverse(j)))
	*/
	j = BATbandjoin(L, BATmirror(R), minus, plus, *li, *hi);
	if (!j)
		throw(MAL, "algebra.bandjoin", GDK_EXCEPTION);
	BBPunfix(L->batCacheid);
	BBPunfix(R->batCacheid);
	L = BATmirror(BATmark(j,0));
	R = BATmirror(BATmark(BATmirror(j),0));
	BBPunfix(j->batCacheid);
	BBPkeepref(*l = L->batCacheid);
	BBPkeepref(*r = R->batCacheid);
	return MAL_SUCCEED;
}

str 
ALGrangejoin2(int *l, int *r, int *left, int *rightl, int *righth, bit *li, bit *hi)
{
	BAT *L, *R, *RL, *RH, *j;

	if ((L = BATdescriptor(*left)) == NULL) {
		throw(MAL, "algebra.join", RUNTIME_OBJECT_MISSING);
	}
	if ((RL = BATdescriptor(*rightl)) == NULL) {
		BBPunfix(L->batCacheid);
		throw(MAL, "algebra.join", RUNTIME_OBJECT_MISSING);
	}
	if ((RH = BATdescriptor(*righth)) == NULL) {
		BBPunfix(L->batCacheid);
		BBPunfix(RL->batCacheid);
		throw(MAL, "algebra.join", RUNTIME_OBJECT_MISSING);
	}

	/* j = join(left,rightl,righth, li, hi)
	   l = reverse(mark(j))
	   r = reverse(mark(reverse(j)))
	*/
	j = BATrangejoin(L, RL, RH, *li, *hi);
	if (!j)
		throw(MAL, "algebra.join", GDK_EXCEPTION);
	BBPunfix(L->batCacheid);
	BBPunfix(RL->batCacheid);
	BBPunfix(RH->batCacheid);
	L = BATmirror(BATmark(j,0));
	R = BATmirror(BATmark(BATmirror(j),0));
	BBPunfix(j->batCacheid);
	BBPkeepref(*l = L->batCacheid);
	BBPkeepref(*r = R->batCacheid);
	return MAL_SUCCEED;
}

str
ALGjoinestimate(bat *result, bat *lid, bat *rid, lng *estimate)
{
	return ALGbinaryestimate(result, lid, rid, estimate, BATjoin, "algebra.join");
}

str
ALGjoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinaryestimate(result, lid, rid, NULL, BATjoin, "algebra.join");
}

str
ALGfetchjoinestimate(bat *result, bat *lid, bat *rid, lng *estimate)
{
	return ALGbinaryestimate(result, lid, rid, estimate, BATfetchjoin, "algebra.fetchjoin");
}

str
ALGfetchjoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinaryestimate(result, lid, rid, NULL, BATfetchjoin, "algebra.fetchjoin");
}

str
ALGleftjoinestimate(bat *result, bat *lid, bat *rid, lng *estimate)
{
	return ALGbinaryestimate(result, lid, rid, estimate, BATleftjoin, "algebra.leftjoin");
}

str
ALGleftjoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinaryestimate(result, lid, rid, NULL, BATleftjoin, "algebra.leftjoin");
}

str
ALGleftfetchjoinestimate(bat *result, bat *lid, bat *rid, lng *estimate)
{
	return ALGbinaryestimate(result, lid, rid, estimate, BATleftfetchjoin, "algebra.leftfetchjoin");
}

str
ALGleftfetchjoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinaryestimate(result, lid, rid, NULL, BATleftfetchjoin, "algebra.leftfetchjoin");
}

str
ALGouterjoinestimate(bat *result, bat *lid, bat *rid, lng *estimate)
{
	return ALGbinaryestimate(result, lid, rid, estimate, BATouterjoin, "algebra.outerjoin");
}

str
ALGouterjoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinaryestimate(result, lid, rid, NULL, BATouterjoin, "algebra.outerjoin");
}

str
ALGsemijoin(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATsemijoin, "algebra.semijoin");
}

str
ALGsunion(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATsunion, "algebra.sunion");
}

str
ALGkunion(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATkunion, "algebra.kunion");
}

str
ALGsintersect(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATsintersect, "algebra.sintersect");
}

str
ALGsdiff(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATsdiff, "algebra.sdiff");
}

str
ALGkdiff(bat *result, bat *lid, bat *rid)
{
	return ALGbinary(result, lid, rid, BATkdiff, "algebra.kdiff");
}

str
ALGsample(bat *result, bat *bid, int *param)
{
	return ALGbinaryint(result, bid, param, BATsample, "algebra.sample");
}

str
ALGsubsample(bat *result, bat *bid, int *param)
{
	return ALGbinaryint(result, bid, param, BATsample_, "algebra.subsample");
}

/* add items missing in the kernel */
str
ALGtunique(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tunique", RUNTIME_OBJECT_MISSING);
	}
	bn = BATkunique(BATmirror(b));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tunique", GDK_EXCEPTION);
}

str
ALGtunion(int *result, int *bid, int *bid2)
{
	BAT *b, *b2, *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.tunion", RUNTIME_OBJECT_MISSING);
	if ((b2 = BATdescriptor(*bid2)) == NULL){
		BBPreleaseref(*bid2);
		throw(MAL, "algebra.tunion", RUNTIME_OBJECT_MISSING);
	}
	
	bn = BATkunion(BATmirror(b),BATmirror(b2));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(b2->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(b2->batCacheid);
	throw(MAL, "algebra.tunion", GDK_EXCEPTION);
}

str
ALGtdifference(int *result, int *bid, int *bid2)
{
	BAT *b, *b2, *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.tdifference", RUNTIME_OBJECT_MISSING);
	if ((b2 = BATdescriptor(*bid2)) == NULL){
		BBPreleaseref(*bid2);
		throw(MAL, "algebra.tdifference", RUNTIME_OBJECT_MISSING);
	}
	
	bn = BATkdiff(BATmirror(b),BATmirror(b2));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(b2->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(b2->batCacheid);
	throw(MAL, "algebra.tdifference", GDK_EXCEPTION);
}

str
ALGtdiff(int *result, int *bid, int *bid2)
{
	BAT *b, *b2, *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.tdiff", RUNTIME_OBJECT_MISSING);
	if ((b2 = BATdescriptor(*bid2)) == NULL){
		BBPreleaseref(*bid2);
		throw(MAL, "algebra.tdiff", RUNTIME_OBJECT_MISSING);
	}
	
	bn = BATkdiff(BATmirror(b),BATmirror(b2));
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(b2->batCacheid);
	if (bn) {
		BAT *r = BATmirror(BATmark(bn,0));
		
		BBPreleaseref(bn->batCacheid);
		bn = r;
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.tdiff", GDK_EXCEPTION);
}

str
ALGtintersect(int *result, int *bid, int *bid2)
{
	BAT *b, *b2, *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.tintersect", RUNTIME_OBJECT_MISSING);
	if ((b2 = BATdescriptor(*bid2)) == NULL){
		BBPreleaseref(*bid2);
		throw(MAL, "algebra.tintersect", RUNTIME_OBJECT_MISSING);
	}
	
	bn = BATsemijoin(BATmirror(b),BATmirror(b2));
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(b2->batCacheid);
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.tintersect", GDK_EXCEPTION);
}

str
ALGtinter(int *result, int *bid, int *bid2)
{
	BAT *b, *b2, *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.tinter", RUNTIME_OBJECT_MISSING);
	if ((b2 = BATdescriptor(*bid2)) == NULL){
		BBPreleaseref(*bid2);
		throw(MAL, "algebra.tinter", RUNTIME_OBJECT_MISSING);
	}
	
	bn = BATsemijoin(BATmirror(b),BATmirror(b2));
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(b2->batCacheid);
	if (bn) {
		BAT *r = BATmirror(BATmark(bn,0));

		BBPreleaseref(bn->batCacheid);
		bn = r;
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.tinter", GDK_EXCEPTION);
}

str
ALGtsort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tsort", RUNTIME_OBJECT_MISSING);
	}
	bn = BATsort(BATmirror(b));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tsort", GDK_EXCEPTION);
}

str
ALGtsort_rev(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tsort", RUNTIME_OBJECT_MISSING);
	}
	bn = BATsort_rev(BATmirror(b));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tsort", GDK_EXCEPTION);
}

str
ALGhsort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.hsort", RUNTIME_OBJECT_MISSING);
	}
	bn = BATsort(b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.hsort", GDK_EXCEPTION);
}

str
ALGhsort_rev(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tsort", RUNTIME_OBJECT_MISSING);
	}
	bn = BATsort_rev(b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tsort", GDK_EXCEPTION);
}
str
ALGhtsort(int *result, int *lid)
{
	BAT *b, *bm = NULL, *bn = NULL;

	if ((b = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.htsort", RUNTIME_OBJECT_MISSING);
	}
	bm = BATmirror(BATsort(BATmirror(b)));
	if (bm) {
		bn = BATssort(bm);
		if (bn) {
			if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
			*result = bn->batCacheid;
			BBPkeepref(*result);
			BBPunfix(bm->batCacheid);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPunfix(bm->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.htsort", GDK_EXCEPTION);
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.htsort", GDK_EXCEPTION);
}

str
ALGthsort(int *result, int *lid)
{
	BAT *b, *bm = NULL, *bn = NULL;

	if ((b = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.thsort", RUNTIME_OBJECT_MISSING);
	}
	bm = BATmirror(BATsort(b));
	if (bm) {
		bn = BATssort(bm);
		if (bn) {
			bn = BATmirror(bn);
			if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
			*result = bn->batCacheid;
			BBPkeepref(*result);
			BBPunfix(bm->batCacheid);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPunfix(bm->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.thsort", GDK_EXCEPTION);
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.thsort", GDK_EXCEPTION);
}

str
ALGssort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.ssort", RUNTIME_OBJECT_MISSING);
	}
	bn = BATssort(b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.ssort", GDK_EXCEPTION);
}

str
ALGssort_rev(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.ssort_rev", RUNTIME_OBJECT_MISSING);
	}
	bn = BATssort_rev(b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.ssort_rev", GDK_EXCEPTION);
}

str
ALGsubsort33(bat *result, bat *norder, bat *ngroup, bat *bid, bat *order, bat *group, bit *reverse, bit *stable)
{
	BAT *bn = NULL, *on = NULL, *gn = NULL;
	BAT *b = NULL, *o = NULL, *g = NULL;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.subsort", RUNTIME_OBJECT_MISSING);
	if (order && (o = BATdescriptor(*order)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.subsort", RUNTIME_OBJECT_MISSING);
	}
	if (group && (g = BATdescriptor(*group)) == NULL) {
		if (o)
			BBPreleaseref(o->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.subsort", RUNTIME_OBJECT_MISSING);
	}
	if (BATsubsort(result ? &bn : NULL,
				   norder ? &on : NULL,
				   ngroup ? &gn : NULL,
				   b, o, g, *reverse, *stable) == GDK_FAIL) {
		if (o)
			BBPreleaseref(o->batCacheid);
		if (g)
			BBPreleaseref(g->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.subsort", OPERATION_FAILED);
	}
	if (result)
		BBPkeepref(*result = bn->batCacheid);
	if (norder)
		BBPkeepref(*norder = on->batCacheid);
	if (ngroup)
		BBPkeepref(*ngroup = gn->batCacheid);
	return MAL_SUCCEED;
}

str
ALGsubsort32(bat *result, bat *norder, bat *bid, bat *order, bat *group, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, norder, NULL, bid, order, group, reverse, stable);
}

str
ALGsubsort31(bat *result, bat *bid, bat *order, bat *group, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, NULL, NULL, bid, order, group, reverse, stable);
}

str
ALGsubsort23(bat *result, bat *norder, bat *ngroup, bat *bid, bat *order, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, norder, ngroup, bid, order, NULL, reverse, stable);
}

str
ALGsubsort22(bat *result, bat *norder, bat *bid, bat *order, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, norder, NULL, bid, order, NULL, reverse, stable);
}

str
ALGsubsort21(bat *result, bat *bid, bat *order, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, NULL, NULL, bid, order, NULL, reverse, stable);
}

str
ALGsubsort13(bat *result, bat *norder, bat *ngroup, bat *bid, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, norder, ngroup, bid, NULL, NULL, reverse, stable);
}

str
ALGsubsort12(bat *result, bat *norder, bat *bid, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, norder, NULL, bid, NULL, NULL, reverse, stable);
}

str
ALGsubsort11(bat *result, bat *bid, bit *reverse, bit *stable)
{
	return ALGsubsort33(result, NULL, NULL, bid, NULL, NULL, reverse, stable);
}

str
ALGrevert(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.revert", RUNTIME_OBJECT_MISSING);
	}
	bn = BATcopy(b, b->htype, b->ttype, TRUE);
	BATrevert(bn);
	*result= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcount_bat(wrd *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}
	*result = (wrd) BATcount(b);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcount_nil(wrd *result, int *bid, bit *ignore_nils)
{
	BAT *b;
	BUN cnt;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}
	if (*ignore_nils)
		cnt = BATcount_no_nil(b);
	else
		cnt = BATcount(b);
	*result = (wrd) cnt;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcount_no_nil(wrd *result, int *bid)
{
	bit ignore_nils = 1;

	return ALGcount_nil(result, bid, &ignore_nils);
}

str
ALGtmark(int *result, int *bid, oid *base)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.markT", RUNTIME_OBJECT_MISSING);
	}
	bn = BATmark(b, *base);
	if (bn != NULL) {
		BBPreleaseref(b->batCacheid);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.markT", GDK_EXCEPTION);
}

str
ALGtmark_default(int *result, int *bid)
{
	oid o = 0;

	return ALGtmark(result, bid, &o);
}

str 
ALGtmarkp(int *result, int *bid, int *nr_parts, int *part_nr)
{
#if SIZEOF_OID == 4
	int bits = 31;
#else
	int bits = 63;
#endif
	oid base = 0;
	
	assert(*part_nr < *nr_parts);
	base = ((oid)1)<<bits;
	base /= *nr_parts;
	base *= *part_nr;
	return ALGtmark(result, bid, &base);
}

str
ALGmarkHead(int *result, int *bid, oid *base)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.markH", RUNTIME_OBJECT_MISSING);
	}
	/* M5's markH is semantically identical with M4/GDK's tmark */
	/* (Don't ask me why; wasn't my decision. Stefan.) */
	bn = BATmirror(BATmark(BATmirror(b), *base));
	if (bn != NULL) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.markH", GDK_EXCEPTION);
}

str
ALGmarkHead_default(int *result, int *bid)
{
	oid o = 0;

	return ALGmarkHead(result, bid, &o);
}

str 
ALGhmarkp(int *result, int *bid, int *nr_parts, int *part_nr)
{
#if SIZEOF_OID == 4
	int bits = 31;
#else
	int bits = 63;
#endif
	oid base = 0;
	
	assert(*part_nr < *nr_parts);
	base = ((oid)1)<<bits;
	base /= *nr_parts;
	base *= *part_nr;
	return ALGmarkHead(result, bid, &base);
}

str 
ALGmark_grp_1(int *result, int *bid, int *gid)
{
	BAT *g, *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	bn = BATmark_grp(b, g, NULL);
	if (bn != NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "algebra.mark_grp", GDK_EXCEPTION);
}

str 
ALGmark_grp_2(int *result, int *bid, int *gid, oid *base)
{
	BAT *g, *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	bn = BATmark_grp(b, g, base);
	if (bn != NULL) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "algebra.mark_grp", GDK_EXCEPTION);
}

str
ALGhistogram_rev(int *result, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.histogram", RUNTIME_OBJECT_MISSING);
	}
	bn = BAThistogram(b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.histogram", GDK_EXCEPTION);
}

str
ALGlike(int *ret, int *bid, str *k)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.like", RUNTIME_OBJECT_MISSING);
	}
	CMDlike(&bn, b, *k);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.like", GDK_EXCEPTION);
}

str
ALGslice(int *ret, bat *bid, lng *start, lng *end)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.slice", RUNTIME_OBJECT_MISSING);
	}
	slice(&bn, b, *start, *end);
	if (bn != NULL) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.slice", GDK_EXCEPTION);
}

str
ALGslice_int(int *ret, bat *bid, int *start, int *end)
{
	lng s = *start;
	lng e = (*end == int_nil ? lng_nil : *end);

	return ALGslice(ret, bid, &s, &e);
}

str
ALGslice_wrd(int *ret, bat *bid, wrd *start, wrd *end)
{
	lng s = *start;
	lng e = (*end == wrd_nil ? lng_nil : *end);

	return ALGslice(ret, bid, &s, &e);
}

/* carve out a slice based on the OIDs */
/* beware that BATs may have different OID bases */
str
ALGslice_oid(int *ret, bat *bid, oid *start, oid *end)
{
	BAT *b, *bv;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "algebra.slice", RUNTIME_OBJECT_MISSING);
	
	bv  = BATmirror( b);
	if ( bv == NULL)
		throw(MAL, "algebra.slice", MAL_MALLOC_FAIL);
	bv  = BATselect_( bv, (ptr) start, (ptr) end, TRUE, FALSE);
	if ( bv == NULL)
		throw(MAL, "algebra.slice", MAL_MALLOC_FAIL);
	bv  = BATmirror( bv);
	if ( bv == NULL)
		throw(MAL, "algebra.slice", MAL_MALLOC_FAIL);
		
	*ret = bv->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGsubslice_wrd(int *ret, bat *bid, wrd *start, wrd *end)
{
	lng s = *start;
	lng e = (*end == wrd_nil ? lng_nil : *end);
	bat slc;
	str msg;

	if ((msg = ALGslice(&slc, bid, &s, &e)) == MAL_SUCCEED) {
		if ((msg = ALGtmark_default(ret, &slc)) == MAL_SUCCEED) {
			BBPdecref(slc, TRUE); 
			*ret = -*ret; /* ugly reverse */ 
			return MAL_SUCCEED;
		}
	}
	return msg;
}

/*
 * @- BUN Get/Fetch
 */
str
ALGposition(wrd *retval, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.position", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	if (CMDposition(retval, b, val) == GDK_FAIL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.position", GDK_EXCEPTION "Item not found");
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGpositionBUN(wrd *retval, int *bid, ptr val, ptr tval)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.position", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	if( (CMDpositionBUN(retval, b, val, tval) == GDK_FAIL) ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.position", GDK_EXCEPTION "Item not found");
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

static str
doALGfetch(ptr ret, BAT *b, BUN pos)
{
	BATiter bi = bat_iterator(b);

	assert(pos <= BUN_MAX);
	if (ATOMextern(b->ttype)) {
		ptr _src = BUNtail(bi,pos);
		int _len = ATOMlen(b->ttype, _src);
		ptr _dst = GDKmalloc(_len);
		memcpy(_dst, _src, _len);
		*(ptr*) ret = _dst;
	} else {
		int _s = ATOMsize(ATOMtype(b->ttype));
		if (ATOMvarsized(b->ttype)) {
			memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtvar(bi, pos), _s);
		} else if (b->ttype == TYPE_void) {
			*(oid*) ret = b->tseqbase;
			if (b->tseqbase != oid_nil)
				*(oid*)ret += pos - BUNfirst(b);
		} else if (_s == 4) {
			*(int*) ret = *(int*) Tloc(b, pos);
		} else if (_s == 1) {
			*(bte*) ret = *(bte*) Tloc(b, pos);
		} else if (_s == 2) {
			*(sht*) ret = *(sht*) Tloc(b, pos);
		} else if (_s == 8) {
			*(lng*) ret = *(lng*) Tloc(b, pos);
		} else {
			memcpy(ret, Tloc(b, pos), _s);
		}
	}
	return MAL_SUCCEED;
}

str
ALGfetch(ptr ret, int *bid, lng *pos)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.fetch", RUNTIME_OBJECT_MISSING);
	}
	if ((*pos < (lng) BUNfirst(b)) || (*pos >= (lng) BUNlast(b)))
		throw(MAL, "algebra.fetch", ILLEGAL_ARGUMENT " Idx out of range\n");
	msg = doALGfetch(ret, b, (BUN) *pos);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str
ALGfetchoid(int *ret, int *bid, oid *pos)
{
	lng o = *pos;

	ALGfetch(ret, bid, &o);
	return MAL_SUCCEED;
}

str
ALGfetchint(int *ret, int *bid, int *pos)
{
	lng o = *pos;

	return ALGfetch(ret, bid, &o);
}

str
ALGfetchbat(int *ret, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.fetch", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.fetch", RUNTIME_OBJECT_MISSING);
	}

	bn = BATfetch(b, s);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(s->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(s->batCacheid);
	throw(MAL, "algebra.fetchbat", GDK_EXCEPTION);

}

str
ALGexist(bit *ret, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.exist", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	CMDexist(ret, b, val);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.exist", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	CMDexistBUN(ret, b, val, tval);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGfind(ptr ret, int *bid, ptr val)
{
	BAT *b;
	BUN q;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.find", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	q = BUNfnd(b, val);

	if (q == BUN_NONE){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.find", GDK_EXCEPTION "can not find element");
	}
	msg = doALGfetch(ret, b, q);
	BBPreleaseref(b->batCacheid);
	return msg;
}


str
ALGhashjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;
	size_t lsize, rsize;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.hashjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.hashjoin", RUNTIME_OBJECT_MISSING);
	}

	lsize = left->H->heap.size + left->T->heap.size + (left->H->vheap ? left->H->vheap->size : 0) + (left->T->vheap ? left->T->vheap->size : 0);
	rsize = right->H->heap.size + right->T->heap.size + (right->H->vheap ? right->H->vheap->size : 0) + (right->T->vheap ? right->T->vheap->size : 0);

	if (rsize < lsize)
		bn = BATmirror(BAThashjoin(BATmirror(right), BATmirror(left), BUN_NONE));
	else
		bn = BAThashjoin(left, right, BUN_NONE);

	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.hashjoin", MAL_MALLOC_FAIL);
}

str
ALGmergejoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.mergejoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.mergejoin", RUNTIME_OBJECT_MISSING);
	}
	if (!BATtordered(left) && !BAThordered(right))
		throw(MAL, "algebra.mergejoin", ILLEGAL_ARGUMENT " Neither left nor right bat is ordered.\n");

	if ((left->ttype == TYPE_void) || (right->htype == TYPE_void))
		throw(MAL, "algebra.mergejoin", ILLEGAL_ARGUMENT " Cannot perform mergejoin on void fields.\n");
	bn = BATmergejoin(left, right, BUN_NONE);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.mergejoin", MAL_MALLOC_FAIL);
}

str
ALGindexjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.indexjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.indexjoin", RUNTIME_OBJECT_MISSING);
	}

	bn = BATthetajoin(left, right, JOIN_EQ, BUN_NONE);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.indexjoin", MAL_MALLOC_FAIL);
}

str
ALGprojectNIL(int *ret, int *bid)
{
    BAT *b, *bn;

    if ((b = BATdescriptor(*bid)) == NULL) {
        throw(MAL, "algebra.project", RUNTIME_OBJECT_MISSING);
    }

    bn = BATconst(b, TYPE_void, (ptr) &oid_nil);
    if (bn) {
        *ret = bn->batCacheid;
        BBPkeepref(bn->batCacheid);
		BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
    }
    BBPunfix(b->batCacheid);
    throw(MAL, "algebra.project", MAL_MALLOC_FAIL);
}

/*
 * The constant versions are typed by the parser
 */
str
ALGprojecthead(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = getArgReference(stk, pci, 0);
	const ValRecord *v = &stk->stk[getArg(pci, 1)];
	bat bid = * (bat *) getArgReference(stk, pci, 2);
	BAT *b, *bn;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(bid)) == NULL)
		throw(MAL, "algebra.project", RUNTIME_OBJECT_MISSING);
	b = BATmirror(b);
	bn = BATconst(b, v->vtype, VALptr(v));
	if (bn == NULL) {
		*ret = 0;
		throw(MAL, "algebra.project", MAL_MALLOC_FAIL);
	}
	bn = BATmirror(bn);
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ);
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGprojecttail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = getArgReference(stk, pci, 0);
	bat bid = * (bat *) getArgReference(stk, pci, 1);
	const ValRecord *v = &stk->stk[getArg(pci, 2)];
	BAT *b, *bn;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(bid)) == NULL)
		throw(MAL, "algebra.project", RUNTIME_OBJECT_MISSING);
	bn = BATconst(b, v->vtype, VALptr(v));
	if (bn == NULL) {
		*ret = 0;
		throw(MAL, "algebra.project", MAL_MALLOC_FAIL);
	}
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ);
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}


/* You don;t have to materialize the oids.
This is taken care upon access */
str
ALGidentity(int *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.identity", RUNTIME_OBJECT_MISSING);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); \
	BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}
str
ALGmaterialize(int *ret, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.materialize", RUNTIME_OBJECT_MISSING);
	if( b->htype == TYPE_void){
		bn= BATmaterialize(b);
		if( bn == NULL)
			throw(MAL, "batcalc.materialize", MAL_MALLOC_FAIL);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		BBPkeepref(*ret= bn->batCacheid);
	} else 
		BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}

str ALGreuse(int *ret, int *bid)
{
	BAT *b,*bn;
	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "algebra.reuse", RUNTIME_OBJECT_MISSING);

	if( b->batPersistence != TRANSIENT || b->batRestricted != BAT_WRITE){
		if( ATOMvarsized(b->ttype) || b->htype != TYPE_void){
			bn= BATwcopy(b);
		} else {
			bn = BATnew(b->htype,b->ttype,BATcount(b));
			BATsetcount(bn,BATcount(b));
			bn->tsorted = FALSE;
			bn->trevsorted = FALSE;
			BATkey(bn,FALSE);
			/* head is void */
			BATseqbase(bn, b->hseqbase);
		}
		BBPkeepref(*ret= bn->batCacheid);
		BBPreleaseref(b->batCacheid);
	} else 
		BBPkeepref(*ret = *bid);
	return MAL_SUCCEED;
}

/*
 * @+ BAT avg operation
 * The avg aggregate only works for int and float fields.
 */
str
ALGavg(dbl *res, int *bid)
{
	BAT *b;
	int ret;
	BUN cnt;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "aggr.avg", RUNTIME_OBJECT_MISSING);
	ret = BATcalcavg(b, NULL, res, &cnt);
	BBPreleaseref(b->batCacheid);
	if (ret == GDK_FAIL)
		throw(MAL, "aggr.avg", SEMANTIC_TYPE_MISMATCH);
	/* backward compatibility: return nil if there are nils in the input */
	if (cnt < BATcount(b))
		*res = dbl_nil;
	return MAL_SUCCEED;
}

/*
 * @+ BAT standard deviation
 */
str
ALGstdev(dbl *res, int *bid)
{
	BAT *b;
	dbl stdev;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "aggr.stdev", RUNTIME_OBJECT_MISSING);
	stdev = BATcalcstdev_sample(NULL, b);
	BBPreleaseref(b->batCacheid);
	if (stdev == dbl_nil)
		throw(MAL, "aggr.stdev", SEMANTIC_TYPE_MISMATCH);
	*res = stdev;
	return MAL_SUCCEED;
}

str
ALGstdevp(dbl *res, int *bid)
{
	BAT *b;
	dbl stdev;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "aggr.stdevp", RUNTIME_OBJECT_MISSING);
	stdev = BATcalcstdev_population(NULL, b);
	BBPreleaseref(b->batCacheid);
	if (stdev == dbl_nil)
		throw(MAL, "aggr.stdevp", SEMANTIC_TYPE_MISMATCH);
	*res = stdev;
	return MAL_SUCCEED;
}

/*
 * @+ BAT variance
 */
str
ALGvariance(dbl *res, int *bid)
{
	BAT *b;
	dbl variance;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "aggr.variance", RUNTIME_OBJECT_MISSING);
	variance = BATcalcvariance_sample(NULL, b);
	BBPreleaseref(b->batCacheid);
	if (variance == dbl_nil)
		throw(MAL, "aggr.variance", SEMANTIC_TYPE_MISMATCH);
	*res = variance;
	return MAL_SUCCEED;
}

str
ALGvariancep(dbl *res, int *bid)
{
	BAT *b;
	dbl variance;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "aggr.variancep", RUNTIME_OBJECT_MISSING);
	variance = BATcalcvariance_population(NULL, b);
	BBPreleaseref(b->batCacheid);
	if (variance == dbl_nil)
		throw(MAL, "aggr.variancep", SEMANTIC_TYPE_MISMATCH);
	*res = variance;
	return MAL_SUCCEED;
}
