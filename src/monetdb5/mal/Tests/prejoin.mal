# the prejoin experiment

t0:= alarm.usec();
base:= bat.new(:oid,:int);
barrier (go,i):= language.newRange(0:int);
	k:= mmath.rand();
	o:= calc.oid(i);
	bat.insert(base,o,k);
#	redo (go,i):= language.nextElement(1:int,10:int);
#	redo (go,i):= language.nextElement(1:int,1000:int);
	redo (go,i):= language.nextElement(1:int,10000000:int);
exit (go,i);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#loop %d\n",d0);
t0:= alarm.usec();
# create a sample with minimal overlap
sample := 100000;
c:= algebra.sample(base,sample);
#c:= algebra.copy(b);

#get fresh copies for 2nd experiment
b:= algebra.copy(base);
d:= algebra.copy(b);
e:= algebra.copy(c);
t1:= alarm.usec();
#io.print(b);
#io.print(c);
d0:= t1-t0;
io.printf("#copy %d\n",d0);
t0:= alarm.usec();
cc:= bat.reverse(c);
j:= algebra.join(b,cc);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#join %d\n",d0);
t0:= alarm.usec();
j:= algebra.join(b,cc);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#hot join %d\n",d0);
cnt:= aggr.count(j);
io.print(cnt);
t0:= alarm.usec();
(w,y):= algebra.prejoin(d,e,2);
t1:= alarm.usec();
d0:= t1-t0;
d1:= d0;
io.printf("#prejoin %d\n",d0);
t0:= alarm.usec();
cy:= bat.reverse(y);
h:= algebra.join(w,cy);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#join %d\n",d0);
cnt:= aggr.count(h);
io.print(cnt);
d1:= d1+d0;
io.printf("#join total %d\n",d1);
#io.print(w);
#io.print(y);
