@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f sql

@c
/*
 * @t SQL Scenario implementation
 * @a M Kersten
 * @v 0
 * @* SQL support implementation
 * This module contains the wrappers around the SQL
 * multi-version-catalog and support routines copied
 * from the Version 4 code base.
 */
@mal
module batsql;
module sql;

pattern start():void 
address SQLsession
comment "Switch to processing SQL statements";

pattern start2():void
address SQLsession2
comment "Switch to processing precompiled sql statements";

pattern init():void
address SQLinitEnvironment
comment "Initialize the environment for MAL";

pattern mvc():int
address SQLmvc
comment "get the multiversion catalog context, needed for correct statement dependencies (ie sql.update, should be after sql.bind in concurrent execution)";

pattern trans(type:int,chain:int,name:str):void
address SQLtransaction
comment "a transaction statement (type can be commit,release,rollback or start)";

pattern transaction{unsafe}()
address SQLtransaction2
comment "Start an autocommit transaction";

pattern commit()
address SQLcommit
comment "Trigger the commit operation for a MAL block";

pattern abort()
address SQLabort
comment "Trigger the abort operation for a MAL block";

pattern catalog(type:int,sname:str,name:str,action:int):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,name:str,funcid:int,ft:int,action:int):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,name:str,tname:str,time:int,o:int,event:int,oname:str,nname:str,condition:str,query:str):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,t:ptr):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,t:ptr,temp:int):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,t:ptr,restart:lng):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,grantee:str,role:str):void
address SQLcatalog
comment "a grant/revoke role statement";

pattern catalog(type:int,user:str,passwd:str,enc:int,schema:str,fullname:str):void
address SQLcatalog
comment "a user catalog statement";

pattern catalog(type:int,sname:str,tname:str,grantee:str,privs:int,cname:str,grant:int,grantor:int):void
address SQLcatalog
comment "a grant/revoke privileges statement";

pattern catalog(type:int,iname:str,itype:int,sname:str,tname:str...):void
address SQLcatalog
comment "a create index catalog statement";

pattern eval(cmd:str):void 
address SQLstatement
comment "Compile and execute a single sql statement";

pattern eval(cmd:str, output:bit):void 
address SQLstatement
comment "Compile and execute a single sql statement (and optionaly send output on the output stream)";

pattern include(fname:str):void 
address SQLinclude
comment "Compile and execute a sql statements on the file";

pattern evalAlgebra(cmd:str, optimize:bit):void
address RAstatement
comment "Compile and execute a single 'relational algebra' statement";

pattern assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

pattern assert(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";

pattern assert(b:wrd,msg:str):void
address SQLassertWrd
comment "Generate an exception when b!=0";

pattern assert(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";
# @- The SQL multi-version catalog
# This module also contains the definitions for managing an SQL database schema in
# version 5.  It is an adaptation of the original V4.3 code base.
# A main difference is that the global catalog is obtained from
# the client record, rather than lookup the variable in a context stack.
#
# The MAL operations below are used in the SQL->MAL compiler and
# can be (sparingly) used to inspect it from a MIL console.
# The 'mvc_' header is removed, because all commands are already
# prepended by the 'sql.' module name.
# The original code is retained, because it makes it
# easier to later re-use part of the catalog code in a separately.

pattern setVariable(mvc:int, varname:str, value:any_1 ):int
address setVariable
comment "Set the value of a session variable";

pattern getVariable(mvc:int, varname:str ):any_1
address getVariable
comment "Get the value of a session variable";

pattern logfile{unsafe}(filename:str):void 
address mvc_logfile
comment "Enable/disable saving the sql statement traces";

pattern next_value( sname:str, sequence:str ):lng
address mvc_next_value
comment "return the next value of the sequence";

pattern batsql.next_value( sname:bat[:oid,:str], sequence:str ) :bat[:oid,:lng]
address mvc_bat_next_value
comment "return the next value of the sequence";

pattern get_value( sname:str, sequence:str ):lng
address mvc_get_value
comment "return the current value of the sequence";

pattern restart{unsafe}( sname:str, sequence:str, start:lng ):lng
address mvc_restart_seq
comment "restart the sequence with value start";

pattern bind_dbat(mvc:int, schema:str, table:str, access:int):bat[:oid,:oid]
address mvc_bind_dbat_wrap
comment "Bind to 'schema.table' BAT with deleted objecs
and with specific access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid,:oid],uval:bat[:oid,:any_1])
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid,:oid],uval:bat[:oid,:any_1])
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid,:oid],uval:bat[:oid,:any_1])
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT partition with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid,:oid],uval:bat[:oid,:any_1])
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

command delta ( col:bat[:oid,:any_3], uid:bat[:oid,:oid], uval:bat[:oid,:any_3], ins:bat[:oid,:any_3] )
		:bat[:oid,:any_3] 
address DELTAbat
comment "Return column bat with delta's applied.";

command projectdelta( subselect:bat[:oid,:oid], col:bat[:oid,:any_3], uid:bat[:oid,:oid], uval:bat[:oid,:any_3], ins:bat[:oid,:any_3] ) :bat[:oid,:any_3] 
address DELTAproject
comment "Return column bat with delta's applied.";

command subdelta ( col:bat[:oid,:oid], uid:bat[:oid,:oid], uval:bat[:oid,:oid], ins:bat[:oid,:oid] ) :bat[:oid,:oid]
address DELTAsub
comment "Return a single bat of subselected delta.";

command delta ( col:bat[:oid,:any_3], uid:bat[:oid,:oid], uval:bat[:oid,:any_3]) :bat[:oid,:any_3] 
address DELTAbat2
comment "Return column bat with delta's applied.";

command projectdelta( subselect:bat[:oid,:oid], col:bat[:oid,:any_3], uid:bat[:oid,:oid], uval:bat[:oid,:any_3]) :bat[:oid,:any_3] 
address DELTAproject2
comment "Return column bat with delta's applied.";

command subdelta ( col:bat[:oid,:oid], uid:bat[:oid,:oid], uval:bat[:oid,:oid]) :bat[:oid,:oid]
address DELTAsub2
comment "Return a single bat of subselected delta.";

command getVersion(clientid:int):lng
address mvc_getVersion
comment "Return the database version identifier for a client";

pattern append(mvc:int, sname:str, tname:str, cname:str, ins:any):int
address mvc_append_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname (returns sequence number for order dependence)";

pattern update(mvc:int, sname:str, tname:str, cname:str, rids:any, upd:any):int
address mvc_update_wrap
comment "Update the values of the column tname.cname";

pattern clear_table{unsafe}(sname:str, tname:str) :wrd
address mvc_clear_table_wrap
comment "Clear table";

pattern tid( mvc:int, sname:str, tname:str):bat[:oid,:any_3] 
address SQLtid
comment "Return the tables tid column.";

pattern tid( mvc:int, sname:str, tname:str, part_nr:int, nr_parts:int ):bat[:oid,:any_3] 
address SQLtid
comment "Return the tables tid column.";

pattern delete{unsafe}(mvc:int, sname:str, tname:str, b:any):int
address mvc_delete_wrap
comment "delete from table";

# @-
# The Monet 5 code generator uses several SQL specific wrapper functions.
pattern resultSet{unsafe}( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:any_1 ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

pattern resultSet{unsafe}( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:bat[:oid,:any_1] ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

pattern resultSet{unsafe}( nr_cols:int, qtype:int, order:any_1 ) :int 
address mvc_result_row_wrap
comment "Prepare a row result set"; 

pattern resultSet{unsafe}( nr_cols:int, qtype:int, order:bat[:oid,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

pattern rsColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:any_1 ) :void
address mvc_result_value_wrap
comment "Add the value to the row query result";

pattern rsColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, col:bat[:oid,:any_1] ) :void
address mvc_result_column_wrap
comment "Add the column to the table query result";

pattern declaredTable{unsafe}( name:str ) :int 
address mvc_declared_table_wrap
comment "Prepare a declared table"; 

pattern dtColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int) :void
address mvc_declared_table_column_wrap;

pattern dropDeclaredTable{unsafe}( name:str ) :void 
address mvc_drop_declared_table_wrap
comment "drop a declared table"; 

pattern dropDeclaredTables{unsafe}( nr:int ) :void 
address mvc_drop_declared_tables_wrap
comment "drop top n declared tables"; 

pattern exportHead{unsafe}(s:streams, res_id:int) :void
address mvc_export_head_wrap
comment "Export a result (in order) to stream s"; 

pattern exportResult{unsafe}(s:streams, res_id:int) :void
address mvc_export_result_wrap
comment "Export a result (in order) to stream s"; 

pattern exportChunk{unsafe}(s:streams, res_id:int) :void
address mvc_export_chunk_wrap
comment "Export a chunk of the result set (in order) to stream s"; 

pattern exportChunk{unsafe}(s:streams, res_id:int, offset:int, nr:int) :void
address mvc_export_chunk_wrap
comment "Export a chunk of the result set (in order) to stream s"; 

pattern exportOperation{unsafe}(w:str) :void
address mvc_export_operation_wrap
comment "Export result of schema/transaction queries"; 

pattern affectedRows{unsafe}(mvc:int, nr:wrd, w:str) :int
address mvc_affected_rows_wrap
comment "export the number of affected rows by the current query";

pattern exportValue{unsafe}(qtype:int, tname:str, name:str, typename:str, digits:int, scale:int, eclass:int, val:any_1, w:str):void
address mvc_export_value_wrap 
comment "export a single value onto the stream s";

pattern copy_from{unsafe}( sname:str, tname:str, 
	sep:str, rsep:str, ssep:str, ns:str, fname:str, nr:lng, offset:lng, locked:int)(:bat[:oid,:any]...)
address mvc_import_table_wrap
comment "Import a table from bstream s with the 
	given tuple and seperators (sep/rsep)";

pattern copyfrom{unsafe}( sname:str, tname:str, 
	sep:str, rsep:str, ssep:str, ns:str, nr:lng, offset:lng, locked:int)(:bat[:oid,:any]...)
address mvc_import_table_stdin
comment "Import a table from bstream s with the 
	given tuple and seperators (sep/rsep)";

function single(x:any_2):bat[:oid,:any_2];
	b := bat.new(0:oid, x);
	c := bat.append(b, x);
	return c;
end single;

pattern importTable{unsafe}( sname:str, tname:str, fname:str... )(:bat[:oid,:any]...)
address mvc_bin_import_table_wrap
comment "Import a table from the files (fname)";

command zero_or_one( col:bat[:any_2,:any_1]) :any_1
address zero_or_one
comment "if col contains exactly one value return this. Incase of more raise an exception else return nil";

command not_unique( b:bat[:oid,:oid]) :bit 
address not_unique 
comment "check if the tail sorted bat b doesn't have unique tail values" ;

command not_uniques( b:bat[:oid,:oid]) :bat[:oid,:oid] 
address not_unique_oids 
comment "return not unique oids" ;

command not_uniques( b:bat[:oid,:wrd]) :bat[:oid,:oid] 
address not_unique_oids ;

command optimizers()(:bat[:oid,:str],:bat[:oid,:str],:bat[:oid,:str])
address getPipeCatalog;

pattern optimizer_updates()
address SQLoptimizersUpdate;

function times(elaps:int,inblock:lng, oublock:lng):void;
	io.printf("#times %d ms",elaps);
	io.printf(" %d reads",inblock);
	io.printf(" %d writes\n",oublock);
end times;

factory times();
	elaps:= alarm.time();
	user := profiler.getUserTime();
	system := profiler.getSystemTime();
	inblocks := profiler.getDiskReads();
	oublocks := profiler.getDiskWrites();
barrier goon:=true;
	e1:= alarm.time();
	u1:= profiler.getUserTime();
	s1:= profiler.getSystemTime();
	i1 := profiler.getDiskReads();
	o1 := profiler.getDiskWrites();
	elaps:= e1-elaps;
	inblocks := i1-inblocks;
	oublocks := o1-oublocks;
	user := u1-user;
	system:= s1-system;
	io.printf("times %d ms",elaps);
	io.printf(" user %d ms",user);
	io.printf(" system %d ms",system);
	io.printf(" %d reads",inblocks);
	io.printf(" %d writes\n",oublocks);
	elaps := e1;
	user := u1;
	system:=s1;
	inblocks  := i1;
	oublocks  := o1;
	yield times;
	redo goon:=true;
exit goon;
end times;

pattern argRecord():str
address SQLargRecord
comment "Glue together the calling sequence";
pattern argRecord(a:any...):str
address SQLargRecord
comment "Glue together the calling sequence";

function sql_environment{inline}()(name:bat[:oid,:str],value:bat[:oid,:str]);
	(name,value):= inspect.getEnvironment();
	return (name,value) := (name,value);
end sql_environment;

function bbp{inline}()( id:bat[:oid,:int], name:bat[:oid,:str], htype:bat[:oid,:str], ttype:bat[:oid,:str], count:bat[:oid,:lng], refcnt:bat[:oid,:int], lrefcnt:bat[:oid,:int], location:bat[:oid,:str], heat:bat[:oid,:int], dirty:bat[:oid,:str], status:bat[:oid,:str], kind:bat[:oid,:str]);

	(ns,iht,itt,icnt,irefcnt,ilrefcnt,ilocation,iheat,idirty,istatus,ikind) := bbp.get();
	ri := algebra.markT(ns, 0:oid);
	i := bat.reverse(ri);
	n := algebra.markH(ns, 0:oid);
	ht := algebra.markH(iht, 0:oid);
	tt := algebra.markH(itt, 0:oid);
	cnt := algebra.markH(icnt, 0:oid);
	refcnt := algebra.markH(irefcnt, 0:oid);
	lrefcnt := algebra.markH(ilrefcnt, 0:oid);
	location := algebra.markH(ilocation, 0:oid);
	heat := algebra.markH(iheat, 0:oid);
	dirty := algebra.markH(idirty, 0:oid);
	status := algebra.markH(istatus, 0:oid);
	kind := algebra.markH(ikind, 0:oid);
	return (i,n,ht,tt,cnt,refcnt,lrefcnt,location,heat,dirty,status,kind);
end bbp;

pattern sql_variables():bat[:oid,:str]
address sql_variables
comment "return the table with session variables";

pattern db_users() :bat[:oid,:str]
address db_users_wrap
comment "return table of users with sql scenario";

pattern password(user:str) :str
address db_password_wrap
comment "return password hash of user";

pattern dump_cache()(query:bat[:oid,:str],count:bat[:oid,:int])
address dump_cache
comment "dump the content of the query cache";

pattern dump_opt_stats()(rewrite:bat[:oid,:str],count:bat[:oid,:int])
address dump_opt_stats
comment "dump the optimizer rewrite statistics";

pattern dump_trace()(
	event:bat[:oid,:int],
	clk:bat[:oid,:str],
	pc:bat[:oid,:str],
	thread:bat[:oid,:int],
	user:bat[:oid,:int],
	ticks:bat[:oid,:lng],
	reads:bat[:oid,:lng],
	writes:bat[:oid,:lng],
	rbytes:bat[:oid,:lng],
	wbytes:bat[:oid,:lng],
	type:bat[:oid,:str],
	stmt:bat[:oid,:str])
address dump_trace
comment "dump the trace statistics";

pattern storage()(
	schema:bat[:oid,:str],
	table:bat[:oid,:str],
	column:bat[:oid,:str],
	type:bat[:oid,:str],
	location:bat[:oid,:str],
	count:bat[:oid,:lng],
	atomwidth:bat[:oid,:int],
	columnsize:bat[:oid,:lng],
	heap:bat[:oid,:lng],
	indices:bat[:oid,:lng],
	sorted:bat[:oid,:bit])
address sql_storage
comment "return a table with storage information ";

pattern querylog_catalog()(
id:bat[:oid,:oid],
user:bat[:oid,:str],
defined:bat[:oid,:timestamp],
query:bat[:oid,:str],
pipe:bat[:oid,:str],
mal:bat[:oid,:int],
optimize:bat[:oid,:lng]
)
address sql_querylog_catalog
comment "Obtain the query log catalog";

pattern querylog_calls()(
id:bat[:oid,:oid],
start:bat[:oid,:timestamp],
stop:bat[:oid,:timestamp],
arguments:bat[:oid,:str],
tuples:bat[:oid,:wrd],
exec:bat[:oid,:lng],
result:bat[:oid,:lng],
cpuload:bat[:oid,:int],
iowait:bat[:oid,:int],
space:bat[:oid,:lng]
)
address sql_querylog_calls
comment "Obtain the query log calls";

pattern querylog_empty()
address sql_querylog_empty;

command querylog_enable()
address QLOGenable;
command querylog_enable(thres:int)
address QLOGenablehreshold;
command querylog_disable()
address QLOGdisable;


pattern sysmon_queue()(qtag:bat[:oid,:lng], user:bat[:oid,:str],started:bat[:oid,:timestamp],estimate:bat[:oid,:timestamp],progress:bat[:oid,:int], status:bat[:oid,:str], tag:bat[:oid,:oid], query:bat[:oid,:str])
address SYSMONqueue;

pattern sysmon_pause(tag:sht)
address SYSMONpause;
pattern sysmon_pause(tag:int)
address SYSMONpause;
pattern sysmon_pause(tag:lng)
address SYSMONpause;

pattern sysmon_resume(tag:sht)
address SYSMONresume;
pattern sysmon_resume(tag:int)
address SYSMONresume;
pattern sysmon_resume(tag:lng)
address SYSMONresume;

pattern sysmon_stop(tag:sht)
address SYSMONstop;
pattern sysmon_stop(tag:int)
address SYSMONstop;
pattern sysmon_stop(tag:lng)
address SYSMONstop;

# @- SQL function aliases
# The code generate should identify the precise module
# target for all functions. This creates quite some
# administration overhead and analysis at many places.
# The alternative is to extend modules with an alias.
#
# The routine below are added to the calc module to
# ease code generation.
pattern calc.hash( v:bte ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:bte] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:sht ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:sht] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:int ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:int] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:lng ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:lng] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:oid ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:oid] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:wrd ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:wrd] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:flt ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:flt] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:dbl ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:dbl] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.hash( v:any ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:any_1] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.rotate_xor_hash(h:wrd, nbits:int, v:any_1) :wrd address MKEYrotate_xor_hash;
command batcalc.rotate_xor_hash(h:bat[:oid,:wrd], nbits:int, b:bat[:oid,:any_1]) :bat[:oid,:int] address MKEYbulk_rotate_xor_hash;

# @- SQL functions
# The SQL functions are all recognized by their module name.
# For some we need to provide a new implementation, others
# merely require a different address binding.
#
# The aggregate operations work on doubles by default.
# This calls for casting values around in the process.
@= mal_round
command sql.dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command sql.round( v:@1, d:int, s:int, r:bte) :@1
address @1_round_wrap
comment "round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)";

command calc.second_interval( sc:int, v:@1, ek:int, sk:int ) :lng
address @1_dec2second_interval
comment "cast @1 decimal to a second_interval";

@
@mal
@:mal_round(bte)@
@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@

@= mal_fround
command sql.dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command sql.round( v:@1, r:bte) :@1
address @1_round_wrap
comment "round off the floating point v to r digits behind the dot (if r < 0, before the dot)";

command sql.ms_trunc( v:@1, r:int) :@1
address @1_trunc_wrap
comment "truncate the floating point v to r digits behind the dot (if r < 0, before the dot)";

@
@mal
@:mal_fround(flt)@
@:mal_fround(dbl)@

command sql.alpha(dec:dbl, theta:dbl) :dbl
address SQLdbl_alpha
comment "Implementation of astronomy alpha function: expands the radius theta depending on the declination";

command batsql.alpha(dec:bat[:oid,:dbl], theta:dbl) :bat[:oid,:dbl]
address SQLbat_alpha
comment "BAT implementation of astronomy alpha function";

@= mal_cast
command calc.@1( v:void, digits:int ) :@1 
address nil_2num_@1
comment "cast to @1 and check for overflow";

command calc.@1( v:void, digits:int, scale:int ) :@1 
address nil_2dec_@1
comment "cast to dec(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:void], digits:int ) :bat[:oid,:@1] 
address batnil_2num_@1
comment "cast to @1 and check for overflow";
command batcalc.@1( v:bat[:oid,:void], digits:int, scale:int ) :bat[:oid,:@1] 
address batnil_2dec_@1
comment "cast to dec(@1) and check for overflow";

command calc.@1( v:str, digits:int ) :@1 
address str_2num_@1
comment "cast to @1 and check for overflow";
command calc.@1( v:str, digits:int, scale:int ) :@1 
address str_2dec_@1
comment "cast to dec(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:str], digits:int ) :bat[:oid,:@1] 
address batstr_2num_@1
comment "cast to @1 and check for overflow";
command batcalc.@1( v:bat[:oid,:str], digits:int, scale:int ) :bat[:oid,:@1] 
address batstr_2dec_@1
comment "cast to dec(@1) and check for overflow";
@
@mal
# @-
# address CALCstr2@1
# command calc.str( v:@1 ) :str
# address CALC@12str
# comment "Cast @1 to str";
@:mal_cast(bte)@
@:mal_cast(sht)@
@:mal_cast(int)@
@:mal_cast(lng)@

@= mal_casttime
command calc.@1( v:void ) :@1 
address nil_2_@1
comment "Cast to @1";
command calc.@1( v:void, digits:int ) :@1 
address nil_2time_@1
comment "cast to @1 and check for overflow";

command batcalc.@1( v:bat[:oid,:void] ) :bat[:oid,:@1] 
address batnil_2_@1
comment "Cast to @1";
command batcalc.@1( v:bat[:oid,:void], digits:int ) :bat[:oid,:@1] 
address batnil_2time_@1
comment "cast to @1 and check for overflow";

command calc.@1( v:str ) :@1 
address str_2_@1
comment "Cast to @1";
command calc.@1( v:str, digits:int ) :@1 
address str_2time_@1
comment "cast to @1 and check for overflow";
command calc.@1( v:@1, digits:int ) :@1 
address @1_2time_@1
comment "cast @1 to @1 and check for overflow";

command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "Cast to @1";
command batcalc.@1( v:bat[:oid,:str], digits:int ) :bat[:oid,:@1] 
address batstr_2time_@1
comment "cast to @1 and check for overflow";
command batcalc.@1( v:bat[:oid,:@1], digits:int ) :bat[:oid,:@1] 
address bat@1_2time_@1
comment "cast @1 to @1 and check for overflow";
@
@mal
@:mal_casttime(timestamp)@
@:mal_casttime(daytime)@

command calc.date( v:void ) :date 
address nil_2_date
comment "cast to date";
command batcalc.date( v:bat[:oid,:void] ) :bat[:oid,:date] 
address batnil_2_date
comment "cast to date";

command calc.date( v:str ) :date 
address str_2_date
comment "cast to date";
command batcalc.date( v:bat[:oid,:str] ) :bat[:oid,:date] 
address batstr_2_date
comment "cast to date";
command calc.str( v:date ) :str 
address SQLdate_2_str
comment "cast date to str";

command calc.sqlblob( v:str ) :sqlblob 
address str_2_sqlblob
comment "cast to sqlblob";
command batcalc.sqlblob( v:bat[:oid,:str] ) :bat[:oid,:sqlblob] 
address batstr_2_sqlblob
comment "cast to sqlblob";
command calc.str( v:sqlblob ) :str 
address SQLsqlblob_2_str
comment "cast sqlblob to str";

pattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str 
address SQLstr_cast
comment "cast to string and check for overflow";

pattern batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:oid,:any_1], digits:int ) :bat[:oid,:str] 
address SQLbatstr_cast
comment "cast to string and check for overflow";

command calc.substring(s:str,offset:int):str
address STRsubstringTail;
command calc.substring(s:str,offset:int,count:int):str
address STRsubstring;

@= mal_cast_2dec
# command calc.@1( v:@2) :@1 
# address @2_2_@1
# comment "cast @2 to @1";
command calc.@1( v:@2, digits:int, scale:int ) :@1 
address @2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";

# command batcalc.@1( v:bat[:oid,:@2]) :bat[:oid,:@1]
# address bat@2_2_@1
# comment "cast @2 to @1";
command batcalc.@1( v:bat[:oid,:@2], digits:int, scale:int ) :bat[:oid,:@1] 
address bat@2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";
@
@mal
@:mal_cast_2dec(bte,flt)@
@:mal_cast_2dec(sht,flt)@
@:mal_cast_2dec(int,flt)@
@:mal_cast_2dec(wrd,flt)@
@:mal_cast_2dec(lng,flt)@
@:mal_cast_2dec(bte,dbl)@
@:mal_cast_2dec(sht,dbl)@
@:mal_cast_2dec(int,dbl)@
@:mal_cast_2dec(wrd,dbl)@
@:mal_cast_2dec(lng,dbl)@

@= mal_cast_dec2
command calc.@1( s1:int, v:@2) :@1 
address @2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command calc.@1( s1:int, v:@2, d2:int, s2:int ) :@1 
address @2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";

command batcalc.@1( s1:int, v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command batcalc.@1( s1:int, v:bat[:oid,:@2], d2:int, s2:int ) :bat[:oid,:@1] 
address bat@2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";
@
@mal

@= mal_cast2
@:mal_cast_2dec(@1,@2)@
@:mal_cast_dec2(@1,@2)@
@
@mal
@:mal_cast2(bte,bte)@
@:mal_cast2(bte,sht)@
@:mal_cast2(bte,int)@
@:mal_cast2(bte,wrd)@
@:mal_cast2(bte,lng)@
@:mal_cast2(sht,bte)@
@:mal_cast2(sht,sht)@
@:mal_cast2(sht,int)@
@:mal_cast2(sht,wrd)@
@:mal_cast2(sht,lng)@
@:mal_cast2(int,bte)@
@:mal_cast2(int,sht)@
@:mal_cast2(int,int)@
@:mal_cast2(int,wrd)@
@:mal_cast2(int,lng)@
@:mal_cast2(wrd,bte)@
@:mal_cast2(wrd,sht)@
@:mal_cast2(wrd,int)@
@:mal_cast2(wrd,wrd)@
@:mal_cast2(lng,bte)@
@:mal_cast2(lng,sht)@
@:mal_cast2(lng,int)@
@:mal_cast2(lng,wrd)@
@:mal_cast2(lng,lng)@
@:mal_cast2(flt,bte)@
@:mal_cast2(flt,sht)@
@:mal_cast2(flt,int)@
@:mal_cast2(flt,wrd)@
@:mal_cast2(flt,lng)@
@:mal_cast2(dbl,bte)@
@:mal_cast2(dbl,sht)@
@:mal_cast2(dbl,int)@
@:mal_cast2(dbl,wrd)@
@:mal_cast2(dbl,lng)@

command calc.month_interval( v:str, ek:int, sk:int ) :int
address month_interval_str
comment "cast str to a month_interval and check for overflow";

command calc.second_interval( v:str, ek:int, sk:int ) :lng
address second_interval_str
comment "cast str to a second_interval and check for overflow";

pattern calc.month_interval( v:bte, ek:int, sk:int ) :int
address month_interval
comment "cast bte to a month_interval and check for overflow";

pattern calc.second_interval( v:bte, ek:int, sk:int ) :lng
address second_interval
comment "cast bte to a second_interval and check for overflow";

pattern calc.month_interval( v:sht, ek:int, sk:int ) :int
address month_interval
comment "cast sht to a month_interval and check for overflow";

pattern calc.second_interval( v:sht, ek:int, sk:int ) :lng
address second_interval
comment "cast sht to a second_interval and check for overflow";

pattern calc.month_interval( v:int, ek:int, sk:int ) :int
address month_interval
comment "cast int to a month_interval and check for overflow";

pattern calc.second_interval( v:int, ek:int, sk:int ) :lng
address second_interval
comment "cast int to a second_interval and check for overflow";

pattern calc.month_interval( v:wrd, ek:int, sk:int ) :int
address month_interval
comment "cast wrd to a month_interval and check for overflow";

pattern calc.second_interval( v:wrd, ek:int, sk:int ) :lng
address second_interval
comment "cast wrd to a second_interval and check for overflow";

pattern calc.month_interval( v:lng, ek:int, sk:int ) :int
address month_interval
comment "cast lng to a month_interval and check for overflow";

pattern calc.second_interval( v:lng, ek:int, sk:int ) :lng
address second_interval
comment "cast lng to a second_interval and check for overflow";

command calc.rowid(v:any_1, schema:str, table:str) :oid
address sql_rowid
comment "return the next rowid";

command sql.rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_rank_grp
comment "return the ranked groups";

command sql.rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_rank
comment "return the rank bat";

command sql.dense_rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_dense_rank_grp
comment "return the densely ranked groups";

command sql.dense_rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_dense_rank
comment "return the densely ranked bat";

command aggr.exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1], ord:bat[:oid,:oid], grp:bat[:oid,:oid], ext:bat[:oid,:oid]) :bat[:oid,:int]; 
	# order is based on ord
	og := algebra.leftfetchjoin(ord, grp);
	x := algebra.mark_grp(og,ext,1:oid);
	mg := batcalc.int(x);

	# restore the order based on grp 
	or := bat.reverse(ord);
	gg := bat.mirror(grp);
	go := algebra.leftjoin(gg, or);
	return mark_grp := algebra.leftfetchjoin(go, mg);
end batcalc.mark_grp;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1], ord:bat[:oid,:oid], orig:bat[:oid,:any_2]) :bat[:oid,:int]; 
        x := algebra.markT(b,1:oid);
        mg := batcalc.int(x);

	# restore the order based on grp 
	or := bat.reverse(ord);
	gg := bat.mirror(orig);
	go := algebra.leftjoin(gg, or);
	return mark_grp := algebra.leftfetchjoin(go, mg);
end batcalc.mark_grp;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1] ) :bat[:oid,:int]; 
        x := algebra.markT(b,1:oid);
        return mark_grp:= batcalc.int(x);
end batcalc.mark_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1], ord:bat[:oid,:oid], grp:bat[:oid,:oid], ext:bat[:oid,:oid]) :bat[:oid,:int]; 
	# order is based on ord
	og := algebra.leftfetchjoin(ord, grp);
	rg := sql.rank_grp(b, og, ext);

	# restore the order based on grp 
	or := bat.reverse(ord);
	gg := bat.mirror(grp);
	go := algebra.leftjoin(gg, or);
	return rank_grp := algebra.leftfetchjoin(go, rg);
end batcalc.rank_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1], ord:bat[:oid,:oid], orig:bat[:oid,:any_2]) :bat[:oid,:int]; 
	rg := sql.rank(b);

	# restore the order based on grp 
	or := bat.reverse(ord);
	gg := bat.mirror(orig);
	go := algebra.leftjoin(gg, or);
	return rank_grp := algebra.leftfetchjoin(go, rg);
end batcalc.rank_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return rank_grp:= sql.rank(b);
end batcalc.rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1], ord:bat[:oid,:oid], grp:bat[:oid,:oid], ext:bat[:oid,:oid]) :bat[:oid,:int]; 
	# order is based on ord
	og := algebra.leftfetchjoin(ord, grp);
	drg := sql.dense_rank_grp(b, og, ext);

	# restore the order based on grp 
	or := bat.reverse(ord);
	gg := bat.mirror(grp);
	go := algebra.leftjoin(gg, or);
	return rank_grp := algebra.leftfetchjoin(go, drg);
end batcalc.dense_rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1], ord:bat[:oid,:oid], orig:bat[:oid,:any_2]) :bat[:oid,:int]; 
	drg := sql.dense_rank(b);

	# restore the order based on grp 
	or := bat.reverse(ord);
	gg := bat.mirror(orig);
	go := algebra.leftjoin(gg, or);
	return rank_grp := algebra.leftfetchjoin(go, drg);
end batcalc.dense_rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return dense_rank_grp:= sql.dense_rank(b);
end batcalc.dense_rank_grp;

function sql.subzero_or_one{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid], no_nil:bit) :bat[:oid,:any_1];
	(g,e,h) := group.subgroup(gp);
	m := aggr.max(h);
	c0 := calc.isnil(m);
	c01 := calc.not(c0);
	c1 := calc.>(m,1:wrd);
	c11 := calc.and(c01,c1);
	ms := calc.str(m); 
	msg := str.+("21000!zero_or_one: cardinality violation (", ms);
	msg1 := str.+(msg, ">1)");
	sql.assert(c11, msg1);
	return zero_or_one := b;
end sql.subzero_or_one;


function mmath.rand{inline}( v:int ) :int;
	x := mmath.rand();
	return rand := x;
end mmath.rand;

pattern cluster1(sch:str, tbl:str)
address SQLcluster1
comment "Cluster the columns of a table on the (first) primary key";

pattern cluster2(sch:str, tbl:str)
address SQLcluster2
comment "Cluster the columns of a table on the (first) primary key";

pattern shrink(sch:str, tbl:str)
address SQLshrink
comment "Consolidate the deletion table over all columns using shrinking";

pattern reuse(sch:str, tbl:str)
address SQLreuse
comment "Consolidate the deletion table over all columns reusing deleted slots";

pattern vacuum(sch:str, tbl:str)
address SQLvacuum
comment "Choose an approach to consolidate the deletions";

pattern drop_hash(sch:str, tbl:str)
address SQLdrop_hash
comment "Drop hash indices for the given table";

pattern newdictionary(sch:str, tbl:str):void
address SQLnewDictionary
comment "Perform dictionary compression on a table";
pattern dropdictionary(sch:str, tbl:str):void
address SQLdropDictionary
comment "Perform dictionary decompression on a table";

pattern gzcompress(sch:str, tbl:str):void
address SQLgzcompress
comment "Perform LZ compression on a table";
pattern gzdecompress(sch:str, tbl:str):void
address SQLgzdecompress
comment "Perform LZ decompression on a table";
pattern gztruncate(sch:str, tbl:str):void
address SQLtruncate
comment "Remove the tables when you have a compressed image";
pattern gzexpand(sch:str, tbl:str):void
address SQLexpand
comment "Remove the compressed image";

# The distributed processing of queries requires the SQL runtime
# system to be able to deliver portions of the BATs in an efficient way.
# It should be cast into a more efficient C procedure, which also
# takes care of NAS opportunities.

function octopus.bind(mvc:int, sch:str, tab:str,col:str,kind:int, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(mvc,sch,tab,col,kind);
	return bind:= b;
end bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind",rm,s,t,c,k);
	b:bat[:oid,:any_1]:= remote.get(conn,bh);
	return bind:= b;
end octopus.bind;

function octopus.bind_dbat(mvc:int, sch:str, tab:str,access:int, version:int):bat[:oid,:oid];
	b := sql.bind_dbat(mvc,sch,tab,access);
	return bind_dbat:= b;
end octopus.bind_dbat;

function octopus.bind_dbat(conn:str, sch:str, tab:str, access:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	a := remote.put(conn,access);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_dbat",rm,s,t,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_dbat:= b;
end octopus.bind_dbat;

function octopus.bind_idxbat(mvc:int, sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:oid];
	b := sql.bind_idxbat(mvc,sch,tab,index,access);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.bind_idxbat(conn:str, sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:oid] := nil:bat[:oid,:oid];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_idxbat",rm,s,t,i,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

# Octopus.bind signatures adjusted to new mitosis sql.bind (part_nr, nr_parts)
function octopus.bind(mvc:int, sch:str, tab:str,col:str,kind:int, part_nr:int, nr_parts:int, version:int) :bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(mvc,sch,tab,col,kind,part_nr,nr_parts);
	return bind:= b;
end bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int, part_nr:int, nr_parts:int, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	v := remote.put(conn,version);
	l := remote.put(conn,part_nr);
	h := remote.put(conn,nr_parts);
	rb:= remote.put(conn,b);
	rb:= remote.exec(conn,"sql","bind",rm,s,t,c,k,l,h);
	b:bat[:oid,:any_1]:= remote.get(conn,rb);
	return bind:= b;
end octopus.bind;

function octopus.bind_idxbat(conn:str, sch:str, tab:str, index:str, access:int, part_nr:int, nr_parts:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:oid] := nil:bat[:oid,:oid];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	l := remote.put(conn,part_nr);
	h := remote.put(conn,nr_parts);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_idxbat",rm,s,t,i,a,l,h);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.getVariable(conn:str,name:str):any_1;
	s := remote.put(conn,name);
	bh:= remote.exec(conn,"sql","getVariable",s);
	b:any_1 := remote.get(conn,bh);
	return getVariable:= b;
end octopus.getVariable;

function octopus.getBid(dbname:str, fn:str, bidtype:sht):lng;
res:lng := -1:lng;
barrier remotewrk := calc.!=(dbname,"NOTworker");
	conn := octopus.connect(dbname);
	r_fn := remote.put(conn,fn);
	r_bt := remote.put(conn,bidtype);
	r_getBid := remote.put(conn,res);
	r_getBid := remote.exec(conn,"trader","makeBid",r_fn,r_bt);
	res:lng  := remote.get(conn,r_getBid);
	catch ANYexception:str;
 	   raise ANYexception:str ;
	exit ANYexception:str ;
exit remotewrk;
    return getBid:lng := res;
end getBid;

function remote.bind{inline}(dbconn:str, sch:str, tab:str,col:str,kind:int, 
version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	conn := remote.connect(dbconn, "monetdb", "monetdb", "msql");
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind",rm,s,t,c,k);
	b:bat[:oid,:any_1]:= remote.get(conn,bh);
	return bind:= b;
end remote.bind;

function remote.bind_idxbat{inline}(dbconn:str, sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:oid] := nil:bat[:oid,:oid];
	m := nil:int;
	conn := remote.connect(dbconn, "monetdb", "monetdb", "msql");
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_idxbat",rm,s,t,i,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_idxbat:= b;
end remote.bind_idxbat;

function remote.bind_dbat{inline}(dbconn:str, sch:str, tab:str, access:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	conn := remote.connect(dbconn, "monetdb", "monetdb", "msql");
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	a := remote.put(conn,access);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_dbat",rm,s,t,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_dbat:= b;
end remote.bind_dbat;

pattern rdfshred (location:str, gname:str, schema:str)
address SQLrdfShred
comment "Procedure that wraps around the shredder of the rdf module in MAL. 
Shredding an RDF data file from location results in 7 new tables (6 
permutations of SPO and a mapping) in the RDF schema and an entry to table 
rdf.graph We can then query with SQL queries the RDF triple storeby quering 
tables gid_spo, gid_pso etc., where gid is looked up in rdf.graph"

command prelude()
address SQLprelude;

command epilogue()
address SQLepilogue;

sql.prelude();

@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef WIN32
#ifndef LIBSQL
#define sql5_export extern __declspec(dllimport)
#else
#define sql5_export extern __declspec(dllexport)
#endif
#else
#define sql5_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>

#include <tablet.h>
#include <streams.h>
#include <mtime.h>
#include <math.h>
#include <blob.h>
#include <mkey.h>
#include <str.h>
#include "sql_privileges.h"
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_qc.h"
#include "sql_env.h"
#include "sql_statement.h"
#include "querylog.h"

#include <bat/bat_storage.h>
#include <bat/bat_utils.h>

/*
 * @-
 * The back-end structure collects the information needed to support
 * compilation and execution of the SQL code against the Monet Version 5
 * back end. Note that the back-end can be called upon by the front-end
 * to handle specific tasks, such as catalog management (sql_mvc)
 * and query execution (sql_qc). For this purpose, the front-end needs
 * access to operations defined in the back-end, in particular for
 * freeing the stack and code segment.
 * @-
 */
typedef struct backend {
	int console;
	char language;		/* 'S' or 's' or 'X' */
	mvc *mvc;
	stream *out;
	Client client;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	int 	mvc_var;	
	int	vtop;		/* top of the variable stack before the current function */
	cq *q;			/* pointer to the cached query */
} backend;

extern backend *backend_reset(backend *b);
extern backend *backend_create(mvc *m, Client c);
extern void backend_destroy(backend *b);

extern int sqlcleanup(mvc *c, int err);
extern sql_rel *sql_symbol2relation(mvc *c, symbol *sym);
extern stmt *sql_relation2stmt(mvc *c, sql_rel *r);

extern BAT *mvc_bind_dbat(mvc *m, char *sname, char *tname, int access);
extern BAT *mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access);

sql5_export str SQLmvc(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtransaction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcommit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLabort(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtransaction2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcatalog(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

sql5_export str mvc_append_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_update_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_dbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_idxbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_clear_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_delete_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str DELTAbat(bat *result, bat *col, bat *uid, bat *uval, bat *ins);
sql5_export str DELTAsub(bat *result, bat *col, bat *uid, bat *uval, bat *ins);
sql5_export str DELTAproject(bat *result, bat *subselect, bat *col, bat *uid, bat *uval, bat *ins);
sql5_export str DELTAbat2(bat *result, bat *col, bat *uid, bat *uval);
sql5_export str DELTAsub2(bat *result, bat *col, bat *uid, bat *uval);
sql5_export str DELTAproject2(bat *result, bat *subselect, bat *col, bat *uid, bat *uval);
sql5_export str mvc_result_row_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_file_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

sql5_export str mvc_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_declared_table_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_drop_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci );
sql5_export str mvc_drop_declared_tables_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci );

sql5_export str mvc_affected_rows_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_result_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_head_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_chunk_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_operation_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_import_table_stdin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bin_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str setVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str getVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_variables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_logfile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bat_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_get_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_getVersion(lng *r, int *clientid);
sql5_export str mvc_restart_seq(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str zero_or_one(ptr ret, int *bid);
sql5_export str not_unique(bit *ret, int *bid);
sql5_export str not_unique_oids(bat *ret, bat *bid);
sql5_export str SQLcluster1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcluster2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLshrink(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLreuse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLvacuum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLdrop_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLnewDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLdropDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLgzcompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLgzdecompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtruncate(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLexpand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoctopusBind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoctopusBinddbat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLargRecord(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLrdfShred(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoptimizersUpdate(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str month_interval_str( int *ret, str *s, int *ek, int *sk );
sql5_export str second_interval_str( lng *res, str *s, int *ek, int *sk );
sql5_export str dump_cache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str dump_opt_stats(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str dump_trace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_storage(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_querylog_catalog(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_querylog_calls(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_querylog_empty(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_rowid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe);
sql5_export str sql_rank(bat *rid, bat *bid);
sql5_export str sql_dense_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe);
sql5_export str sql_dense_rank(bat *rid, bat *bid);
@= round_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r );
sql5_export str str_2dec_@1( @1 *res, str *val, int *d, int *sc );
sql5_export str str_2num_@1( @1 *res, str *v, int *len );
sql5_export str batstr_2dec_@1( int *res, int *val, int *d, int *sc );
sql5_export str batstr_2num_@1( int *res, int *v, int *len );
sql5_export str @1_dec2second_interval( lng *res, int *sc, @1 *dec, int *ek, int *sk );

sql5_export str nil_2dec_@1( @1 *res, void *val, int *d, int *sc );
sql5_export str nil_2num_@1( @1 *res, void *v, int *len );
sql5_export str batnil_2dec_@1( int *res, int *val, int *d, int *sc );
sql5_export str batnil_2num_@1( int *res, int *v, int *len );
@
@h
@:round_export(bte)@
@:round_export(sht)@
@:round_export(int)@
@:round_export(wrd)@
@:round_export(lng)@

@= cast_time
sql5_export str nil_2time_@1( @1 *res, void *v, int *len );
sql5_export str batnil_2time_@1( int *res, int *v, int *len );
sql5_export str str_2time_@1( @1 *res, str *v, int *len );
sql5_export str batstr_2time_@1( int *res, int *v, int *len );
sql5_export str @1_2time_@1( @1 *res, @1 *v, int *len );
sql5_export str bat@1_2time_@1( int *res, int *v, int *len );
@
@h
@:cast_time(timestamp)@
@:cast_time(daytime)@
@= cast_export
sql5_export str nil_2_@1( @3 *res, void *val );
sql5_export str batnil_2_@1( int *res, int *val );
sql5_export str str_2_@1( @3 *res, str *val );
sql5_export str batstr_2_@1( int *res, int *val );
sql5_export str SQL@1_2_str( str *res, @1 *val );
@
@h
@:cast_export(timestamp,timestamp_tostr,timestamp)@
@:cast_export(daytime,daytime_tostr,daytime)@
@:cast_export(date,date_tostr,date)@
@:cast_export(sqlblob,sqlblob_tostr,sqlblob*)@
sql5_export str SQLstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLbatstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@= fround_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, bte *r );
sql5_export str @1_trunc_wrap( @1 *res, @1 *v, int *r );
@
@h
@:fround_export(flt)@
@:fround_export(dbl)@
#define radians(x)       ((x) * 3.14159265358979323846 /180.0 )
#define degrees(x)       ((x) * 180.0/3.14159265358979323846 )
sql5_export str SQLdbl_alpha(dbl *res, dbl *decl, dbl *theta);
sql5_export str SQLbat_alpha(bat *res, bat *decl, dbl *theta);
sql5_export str month_interval(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str second_interval(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str month_interval_daytime( int *ret, daytime *s, int *ek, int *sk );
sql5_export str second_interval_daytime( lng *res, daytime *s, int *ek, int *sk );
@= simpleupcast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= simpledowncast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= numcastup_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:numcastup_export(bte,bte)@
@:numcastup_export(sht,bte)@
@:numcastup_export(sht,sht)@
@:numcastup_export(int,bte)@
@:numcastup_export(int,sht)@
@:numcastup_export(int,int)@
@:numcastup_export(wrd,bte)@
@:numcastup_export(wrd,sht)@
@:numcastup_export(wrd,int)@
@:numcastup_export(wrd,wrd)@
@:numcastup_export(lng,bte)@
@:numcastup_export(lng,sht)@
@:numcastup_export(lng,int)@
@:numcastup_export(lng,wrd)@
@:numcastup_export(lng,lng)@
@= fnumcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:fnumcastdown_export(bte,flt)@
@:fnumcastdown_export(sht,flt)@
@:fnumcastdown_export(int,flt)@
@:fnumcastdown_export(wrd,flt)@
@:fnumcastdown_export(lng,flt)@
@:fnumcastdown_export(bte,dbl)@
@:fnumcastdown_export(sht,dbl)@
@:fnumcastdown_export(int,dbl)@
@:fnumcastdown_export(wrd,dbl)@
@:fnumcastdown_export(lng,dbl)@
@= fnumcastup_export
@:simpleupcast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:fnumcastup_export(flt,bte)@
@:fnumcastup_export(flt,sht)@
@:fnumcastup_export(flt,int)@
@:fnumcastup_export(flt,wrd)@
@:fnumcastup_export(flt,lng)@
@:fnumcastup_export(dbl,bte)@
@:fnumcastup_export(dbl,sht)@
@:fnumcastup_export(dbl,int)@
@:fnumcastup_export(dbl,wrd)@
@:fnumcastup_export(dbl,lng)@
@= numcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:numcastdown_export(bte,sht)@
@:numcastdown_export(bte,int)@
@:numcastdown_export(bte,wrd)@
@:numcastdown_export(bte,lng)@
@:numcastdown_export(sht,int)@
@:numcastdown_export(sht,wrd)@
@:numcastdown_export(sht,lng)@
@:numcastdown_export(int,wrd)@
@:numcastdown_export(int,lng)@
@:numcastdown_export(wrd,lng)@

sql5_export str getSQLContext(Client cntxt, MalBlkPtr mb, mvc **c, backend **b );

sql5_export void freeVariables(Client c, MalBlkPtr mb, MalStkPtr glb, int start);

#endif /* _SQL_H */

@c
/*
 * @-
 * First introduce the routines to be called by the front-end.
 */
#include "monetdb_config.h"
#include "sql.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include <sql_storage.h>
#include <sql_scenario.h>
#include <store_sequence.h>
#include <sql_optimizer.h>
#include <sql_datetime.h>
#include <rel_optimizer.h>
#include <rel_distribute.h>
#include <rel_select.h>
#include <rel_exp.h>
#include <rel_dump.h>
#include <rel_bin.h>
#include <bbp.h>
#include <cluster.h>
#include <opt_dictionary.h>
#include <opt_pipes.h>
#ifdef HAVE_RAPTOR
# include <rdf.h>
#endif
#include "mal_instruction.h"

/* Windows doesn't have round or trunc, but it does have floor and ceil */
#ifndef HAVE_ROUND
static inline double
round(double val)
{
	/* round to nearest integer, away from zero */
	if (val < 0)
		return -floor(-val + 0.5);
	else
		return floor(val + 0.5);
}
#endif

#ifndef HAVE_TRUNC
static inline double
trunc(double val)
{
	/* round to integer, towards zero */
	if (val < 0)
		return ceil(val);
	else
		return floor(val);
}
#endif

backend *
backend_reset(backend *b)
{
	b->out = b->client->fdout;
	b->language = 0;

	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->vtop = 0;
	b->q = NULL;
	b->mvc_var = 0;
	return b;
}

backend *
backend_create(mvc *m, Client c)
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->mvc = m;
	b->client = c;
	b->mvc_var = 0;
	return backend_reset(b);
}

void
backend_destroy(backend *b)
{
	_DELETE(b);
}

static int
rel_is_table( sql_rel *rel )
{
	if (!rel || is_base(rel->op))
		return 1;
	return 0;
}

static int
exp_is_point_select( sql_exp * e) 
{
	if (!e)
		return 1;
	if (e->type == e_cmp && !e->f && e->flag == (int)cmp_equal) {
		sql_exp *r = e->r;

		if (r->card <= CARD_AGGR) 
			return 1;
	}
	return 0;
}

static int
rel_is_point_query( sql_rel *rel)
{
	int is_point = 0;

	if (!rel)
		return 1;
	if (is_project(rel->op))
		return rel_is_point_query(rel->l);
	if (is_select(rel->op) && rel_is_table(rel->l) && rel->exps) {
/*
		node *n;
		is_point = 1;
		for (n=rel->exps->h; n && is_point; n = n->next) {
			if (!exp_is_point_select(n->data))
				is_point = 0;
		}
*/
		is_point = 0;
		/* just one point expression makes this a point query */
		if (rel->exps->h)
			if (exp_is_point_select(rel->exps->h->data))
				is_point = 1;
	}
	return is_point;
}

static int
rel_need_distinct_query( sql_rel *rel)
{
	int need_distinct = 0;

	while (!need_distinct && rel && is_project(rel->op) && !is_groupby(rel->op))
		rel = rel->l;
	if (!need_distinct && rel && is_groupby(rel->op) && rel->exps) {
		node *n, *m;
		for (n=rel->exps->h; n && !need_distinct; n = n->next) {
			sql_exp *e = n->data;
			if (e->type == e_aggr) {
				list *l = e->l;

				if (l) for(m = l->h; m && !need_distinct; m = m->next){
					sql_exp *a = m->data;
	
					if (need_distinct(a))
						need_distinct = 1;
				}
			}
		}
	}
	return need_distinct;
}


sql_rel *
sql_symbol2relation(mvc *c, symbol *sym)
{
	sql_rel *r;

	r = rel_semantic(c, sym);
	if (!r) 
		return NULL;
	if (r) {
		r = rel_optimizer(c, r);
		r = rel_distribute(c, r);
		if (rel_is_point_query(r) || rel_need_distinct_query(r))
			c->point_query = 1;
	}
	return r;
}

stmt *
sql_relation2stmt(mvc *c, sql_rel *r)
{
	stmt *s = NULL;

	if (!r) {
		return NULL;
	} else {
		if (c->emode == m_plan) {
			rel_print(c, r, 0);
		} else {
			s = output_rel_bin(c, r);
		}
	}
	return s;
}

/*
 * @-
 * After the SQL statement has been executed, its data structures
 * should be garbage collected. For successful actions we have to finish
 * the transaction as well, e.g. commit or rollback.
 */
int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	if ((c->emod & mod_locked) == mod_locked) {
		/* here we should commit the transaction */
		if (!err) {
			sql_trans_commit(c->session->tr);
			/* write changes to disk */
			sql_trans_end(c->session);
			store_apply_deltas();
			sql_trans_begin(c->session);
		}
		store_unlock();
		c->emod = 0;
	}
	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err > 0)
		c->session->status = -err;
	if (err < 0)
		c->session->status = err;
	c->label = 0;
	c->point_query = 0;
	scanner_query_processed(&(c->scanner));
	return err;
}

/*
 * @-
 * The internal administration of the SQL compilation and execution state
 * is administered by a state descriptor accessible in each phase.
 * Failure to find the state descriptor aborts the session.
 */
str 
getSQLContext(Client cntxt, MalBlkPtr mb, mvc **c, backend **b)
{
	backend *be;
	(void) mb;

	if (cntxt == NULL)
		throw(SQL, "mvc", "No client record");
	if (cntxt->sqlcontext == NULL)
		throw(SQL, "mvc", "SQL module not initialized");
	be = (backend *) cntxt->sqlcontext;
	if (c) {
		*c = be->mvc;
		if (*c == NULL)
			throw(SQL, "mvc", "SQL module not initialized, mvc struct missing");
	}
	if (b)
		*b = be;
	return MAL_SUCCEED;
}

str
SQLmvc(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getSQLContext(cntxt, mb, &sql, NULL);
	int *res = (int*) getArgReference(stk, pci, 0);

	if (msg)
		return msg;
	*res = 0;
	return MAL_SUCCEED;
}

str
SQLtransaction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getSQLContext(cntxt, mb, &sql, NULL);
	int type = *(int*) getArgReference(stk, pci, 1);
	int chain = *(int*) getArgReference(stk, pci, 2);
	str name = *(str*) getArgReference(stk, pci, 3);
	char buf[BUFSIZ];
	int ret = 0;

	if (msg)
		return msg;
	if (name && strcmp(name, str_nil) == 0)
		name = NULL;

	switch (type) {
	case DDL_RELEASE:
		if (sql->session->auto_commit == 1) 
			throw(SQL, "sql.trans", "3BM30!RELEASE SAVEPOINT: not allowed in auto commit mode");
		ret = mvc_release(sql, name);
		if (ret < 0) {
			snprintf(buf, BUFSIZ, "3B000!RELEASE SAVEPOINT: (%s) failed", name);
			throw(SQL, "sql.trans", "%s", buf);
		}
		break;
	case DDL_COMMIT:
		if (sql->session->auto_commit == 1) {
			if (name)
				throw(SQL,"sql.trans", "3BM30!SAVEPOINT: not allowed in auto commit mode");
			else
				throw(SQL,"sql.trans", "2DM30!COMMIT: not allowed in auto commit mode");
		}
		ret = mvc_commit(sql, chain, name);
		if (ret < 0 && !name) 
			throw(SQL, "sql.trans", "2D000!COMMIT: failed");
		if (ret < 0 && name)
			throw(SQL, "sql.trans", "3B000!SAVEPOINT: (%s) failed", name);
		break;
	case DDL_ROLLBACK:
		if (sql->session->auto_commit == 1) 
			throw(SQL, "sql.trans", "2DM30!ROLLBACK: not allowed in auto commit mode");
		ret = mvc_rollback(sql, chain, name);
		if (ret < 0 && name) {
			snprintf(buf, BUFSIZ, "3B000!ROLLBACK TO SAVEPOINT: (%s) failed", name);
			throw(SQL, "sql.trans", "%s", buf);
		}
		break;
	case DDL_TRANS:
		if (sql->session->auto_commit == 0) 
			throw(SQL, "sql.trans", "25001!START TRANSACTION: cannot start a transaction within a transaction");
		if (sql->session->active)
			mvc_rollback(sql, 0, NULL);
		sql->session->auto_commit = 0;
		sql->session->ac_on_commit = 1;
		sql->session->level = chain;
		(void) mvc_trans(sql);
		break;
	default:
		throw(SQL, "sql.trans", "transaction unknown type");
	}
	return MAL_SUCCEED;
}

str
SQLcommit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret;
	mvc *sql = NULL;
	str msg = getSQLContext(cntxt, mb, &sql, NULL);
	(void) stk;
	(void) pci;

	if (sql->session->auto_commit != 0) 
		throw(SQL,"sql.trans", "2DM30!COMMIT: not allowed in auto commit mode");
	ret = mvc_commit(sql, 0, 0);
	if (ret < 0 ) 
		throw(SQL, "sql.trans", "2D000!COMMIT: failed");
	return msg;
}

str
SQLabort(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getSQLContext(cntxt, mb, &sql, NULL);
	(void) stk;
	(void) pci;

	if (sql->session->active)
		mvc_rollback(sql, 0, NULL);
	return msg;
}

str
SQLtransaction2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getSQLContext(cntxt, mb, &sql, NULL);

	(void) stk;
	(void) pci;
	if (sql->session->auto_commit == 0) 
		throw(SQL, "sql.trans", "25001!START TRANSACTION: cannot start a transaction within a transaction");
	if (sql->session->active)
		mvc_rollback(sql, 0, NULL);
	sql->session->auto_commit = 0;
	sql->session->ac_on_commit = 1;
	sql->session->level = 0;
	(void) mvc_trans(sql);
	return msg;
}

static str
create_table_or_view( mvc *sql, char *sname, sql_table *t, int temp)
{
	sql_allocator *osa;
	sql_schema *s = mvc_bind_schema(sql, sname);
	sql_table *nt = NULL;
	node *n;

	if (STORE_READONLY) 
		return sql_error(sql, 06, "25006!schema statements cannot be executed on a readonly database.");

	if (!s) 
		return sql_message("3F000!CREATE %s: schema '%s' doesn't exist", (t->query)?"TABLE":"VIEW", sname);

	if (mvc_bind_table(sql, s, t->base.name)) {
		char *cd = (temp == SQL_DECLARED_TABLE)?"DECLARE":"CREATE";
		return sql_message("42S01!%s TABLE: name '%s' already in use", cd, t->base.name);
	} else if (temp != SQL_DECLARED_TABLE && (!schema_privs(sql->role_id, s) && !(isTempSchema(s) && temp == SQL_LOCAL_TEMP))){
		return sql_message("42000!CREATE TABLE: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}

	osa = sql->sa;
	sql->sa = NULL;
	/* first check default values */
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (c->def) {
			char *buf;
			sql_rel *r = NULL;

			sql->sa = sa_create();
			buf = sa_alloc(sql->sa, strlen(c->def) + 8);
			snprintf(buf, BUFSIZ, "select %s;", c->def);
			r = rel_parse(sql, buf, m_deps); 
			if (!r || !is_project(r->op) || !r->exps || list_length(r->exps) != 1 || rel_check_type(sql, &c->type, r->exps->h->data, type_equal) == NULL) 
				throw(SQL, "sql.catalog", "%s", sql->errstr);
			rel_destroy(r);
			sa_destroy(sql->sa);
			sql->sa = NULL;
		}
	}

	nt = sql_trans_create_table(sql->session->tr, s, t->base.name, t->query, t->type, t->system, temp, t->commit_action, t->sz);

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		mvc_copy_column(sql, nt, c);
	}
	if (t->idxs.set) {
		for (n = t->idxs.set->h; n; n = n->next) {
			sql_idx *i = n->data;
			mvc_copy_idx(sql, nt, i);
		}
	}
	if (t->keys.set) {
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			mvc_copy_key(sql, nt, k);
		}
	}
	/* also create dependencies */
	if (nt->query && isView(nt)) {
		sql_rel *r = NULL;

		sql->sa = sa_create();
		r = rel_parse(sql, nt->query, m_deps); 
		if (r) {
			stmt *sqs = rel_bin(sql, r);
			list *view_id_l = stmt_list_dependencies(sql->sa, sqs, VIEW_DEPENDENCY);
			list *id_l = stmt_list_dependencies(sql->sa, sqs, COLUMN_DEPENDENCY);
			list *func_id_l = stmt_list_dependencies(sql->sa, sqs, FUNC_DEPENDENCY);

			mvc_create_dependencies(sql, id_l, nt->base.id, VIEW_DEPENDENCY);
			mvc_create_dependencies(sql, view_id_l, nt->base.id, VIEW_DEPENDENCY);
			mvc_create_dependencies(sql, func_id_l, nt->base.id, VIEW_DEPENDENCY);
		}
		sa_destroy(sql->sa);
	}
	sql->sa = osa;
	return MAL_SUCCEED;
}

static str
alter_table( mvc *sql, char *sname, sql_table *t)
{
	sql_schema *s = mvc_bind_schema(sql, sname);
	sql_table *nt = NULL;
	node *n;

	if (!s) 
		return sql_message("3F000!ALTER TABLE: no such schema '%s'", sname);

	if ((nt = mvc_bind_table(sql, s, t->base.name)) == NULL) {
		return sql_message("42S02!ALTER TABLE: no such table '%s'", t->base.name);

	} else if (!schema_privs(sql->role_id, s) && !(isTempSchema(s) && t->persistence == SQL_LOCAL_TEMP)){
		return sql_message("42000!ALTER TABLE: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}

	/* First check if all the changes are allowed */
	if (t->idxs.set) {
		/* only one pkey */
		if (nt->pkey) {
			for (n = t->idxs.nelm; n; n = n->next) {
				sql_idx *i = n->data;
				if (i->key->type == pkey)
					return sql_message("40000!CONSTRAINT PRIMARY KEY: a table can have only one PRIMARY KEY\n");
			}
		}
	}

	if (t->readonly != nt->readonly) 
		mvc_readonly( sql, nt, t->readonly);

	/* check for changes */
	if (t->tables.dset) for (n = t->tables.dset->h; n; n = n->next) {
		/* propagate alter table .. drop table */
		sql_table *at = n->data;
		sql_table *pt = mvc_bind_table(sql, nt->s, at->base.name);

		sql_trans_del_table(sql->session->tr, nt, pt, at->drop_action);
	}
	for (n = t->tables.nelm; n; n = n->next) {
		/* propagate alter table .. add table */
		sql_table *at = n->data;
 		sql_table *pt = mvc_bind_table(sql, nt->s, at->base.name);

		sql_trans_add_table(sql->session->tr, nt, pt);
	}

	/* check for changes */
	if (t->columns.dset) for (n = t->columns.dset->h; n; n = n->next) {
		/* propagate alter table .. drop column */
		sql_column *c = n->data;
 		sql_column *nc = mvc_bind_column(sql, nt, c->base.name);
		mvc_drop_column(sql, nt, nc, c->drop_action);
	}
	/* check for changes on current cols */
	for (n = t->columns.set->h; n != t->columns.nelm; n = n->next) {

		/* null or default value changes */
		sql_column *c = n->data;
 		sql_column *nc = mvc_bind_column(sql, nt, c->base.name);

		if (c->null != nc->null) {
			mvc_null(sql, nc, c->null);
			/* for non empty check for nulls */
			if (c->null == 0){
				BAT *b = store_funcs.bind_col(sql->session->tr, nc, 0);

				/* TODO also check updates and inserts */
				if (BATcount(b) && b->T->nonil != TRUE) {
					BUN bun = BUNfnd(BATmirror(b), ATOMnilptr(b->ttype));
					if (bun != BUN_NONE)
						return sql_message ("40002!ALTER TABLE: NOT NULL constraint violated for column %s.%s", c->t->base.name, c->base.name );
				}
				BBPunfix(b->batCacheid);
			}
		}
		if (c->def != nc->def)
			mvc_default(sql, nc, c->def);
	}
	for (; n; n = n->next) {
		/* propagate alter table .. add column */
		sql_column *c = n->data;
		mvc_copy_column(sql, nt, c);
	}
	if (t->idxs.set) {
		/* alter drop index */
		if (t->idxs.dset) for (n = t->idxs.dset->h; n; n = n->next) {
			sql_idx *i = n->data;
 			sql_idx *ni = mvc_bind_idx(sql, s, i->base.name);
			mvc_drop_idx(sql, s, ni);
		}
		/* alter add index */
		for (n = t->idxs.nelm; n; n = n->next) {
			sql_idx *i = n->data;
			mvc_copy_idx(sql, nt, i);
		}
	}
	if (t->keys.set) {
		/* alter drop key */
		if (t->keys.dset) for (n = t->keys.dset->h; n; n = n->next) {
			sql_key *k = n->data;
 			sql_key *nk = mvc_bind_key(sql, s, k->base.name);
			mvc_drop_key(sql, s, nk, k->drop_action);
		}
		/* alter add key */
		for (n = t->keys.nelm; n; n = n->next) {
			sql_key *k = n->data;
			mvc_copy_key(sql, nt, k);
		}
	}
	return MAL_SUCCEED;
}



static char *
drop_table(mvc *sql, char *sname, char *tname, int drop_action)
{
	sql_schema *s = NULL;
	sql_table *t = NULL;
	node *n; 

	if (sname && !(s=mvc_bind_schema(sql, sname))) 
		return sql_message("3F000!DROP TABLE: no such schema '%s'", sname);
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
	}
	if (!t) { 
		return sql_message("42S02!DROP TABLE: no such table '%s'", tname);
	} else if (isView(t)) {
		return sql_message("42000!DROP TABLE: cannot drop VIEW '%s'", tname);
	} else if (t->system) {
		return sql_message("42000!DROP TABLE: cannot drop system table '%s'", tname);
	} else if (!schema_privs(sql->role_id, s) && !(isTempSchema(s) && t->persistence == SQL_LOCAL_TEMP)){
		return sql_message("42000!DROP TABLE: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	if ( !drop_action && t->keys.set) {
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			if (k->type == ukey || k->type == pkey) {
				sql_ukey *uk = (sql_ukey *) k;

				if (uk->keys && list_length(uk->keys)) {
					node *l = uk->keys->h;

					for (; l; l = l->next) {
						k = l->data;
						/* make sure it is not a self referencing key */
						if (k->t != t) 
							return sql_message("40000!DROP TABLE: FOREIGN KEY %s.%s depends on %s", k->t->base.name, k->base.name, tname);
					}
				}
			}
		}
	}

	if (!drop_action && mvc_check_dependency(sql, t->base.id, TABLE_DEPENDENCY, NULL))
		return sql_message("42000!DROP TABLE: unable to drop table %s (there are database objects which depend on it)\n", t->base.name);
	
	mvc_drop_table(sql, s, t, drop_action);
	return MAL_SUCCEED;
}

static char *
drop_view(mvc *sql, char *sname, char *tname, int drop_action)
{
	sql_table *t = NULL;
	sql_schema *ss = NULL;

	if (sname != NULL && (ss = mvc_bind_schema(sql, sname)) == NULL)
		return sql_message("3F000!DROP VIEW: no such schema '%s'", sname);

	if (ss == NULL)
		ss = cur_schema(sql);

	t = mvc_bind_table(sql, ss, tname);

	if (!schema_privs(sql->role_id, ss) && !(isTempSchema(ss) && t && t->persistence == SQL_LOCAL_TEMP)){  
		return sql_message("42000!DROP VIEW: access denied for %s to schema '%s'", stack_get_string(sql, "current_user"), ss->base.name);
	} else if (!t) {
		return sql_message("42S02!DROP VIEW: unknown view '%s'", tname);
	} else if (!isView(t)) {
		return sql_message("42000!DROP VIEW: unable to drop view '%s': is a table", tname);
	} else if (t->system) {
		return sql_message("42000!DROP VIEW: cannot drop system view '%s'", tname);
	} else if (! drop_action && mvc_check_dependency(sql, t->base.id, VIEW_DEPENDENCY, NULL)) {
		return sql_message("42000!DROP VIEW: cannot drop view '%s', there are database objects which depend on it", t->base.name);
	} else {
		mvc_drop_table(sql, ss, t, drop_action);
		return MAL_SUCCEED;
	}
}

static str
drop_key( mvc *sql, char *sname, char *kname, int drop_action )
{
	sql_key *key;
	sql_schema *ss = NULL;

	if (sname != NULL && (ss = mvc_bind_schema(sql, sname)) == NULL)
		return sql_message("3F000!ALTER TABLE: no such schema '%s'", sname);

	if (ss == NULL)
		ss = cur_schema(sql);

	if ((key = mvc_bind_key(sql, ss, kname )) == NULL) 
		return sql_message("42000!ALTER TABLE: no such constraint '%s'", kname);
	if (!drop_action && mvc_check_dependency(sql, key->base.id, KEY_DEPENDENCY, NULL)) 
		return sql_message("42000!ALTER TABLE: cannot drop constraint '%s': there are database objects which depend on it", key->base.name);
	mvc_drop_key(sql, ss, key, drop_action);
	return MAL_SUCCEED;
}

static str
create_index( mvc *sql, char *iname, int itype, char *sname, char *tname, MalStkPtr stk, InstrPtr pci) 
{
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_idx *i = NULL;

	if (!(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!CREATE INDEX: no such schema '%s'", sname);

	i = mvc_bind_idx(sql, s, iname);
	t = mvc_bind_table(sql, s, tname);
	if (i) {
		return sql_message("42S11!CREATE INDEX: name '%s' already in use", iname);
	} else if (!t) {
		return sql_message("42S02!CREATE INDEX: no such table '%s'", tname);
	} else if (isView(t)) {
		return sql_message("42S02!CREATE INDEX: cannot create index on view '%s'", tname);
	} else {
		int n;
		sql_idx *i = mvc_create_idx(sql, t, iname, (idx_type) itype);

		if (!i) 
			return sql_message("40000!CREATE INDEX: failed to create index '%s'", iname);

		for (n=6; n<pci->argc; n++) {
			char *cname = *(str*)getArgReference(stk, pci, n);
			sql_column *c = mvc_bind_column(sql, t, cname);

			if (!c) {
				return sql_message("42S22!CREATE INDEX: no such column '%s'", cname);
			} else {
				mvc_create_ic(sql, i, c);
				mvc_create_dependency(sql, c->base.id, i->base.id, INDEX_DEPENDENCY);
			}
		}
	}
	return NULL;
}

static str
drop_index( mvc *sql, char *sname, char *iname)
{
	sql_schema *s = NULL;
	sql_idx *i = NULL;

	if (!(s=mvc_bind_schema(sql, sname))) 
		return sql_message("3F000!DROP INDEX: no such schema '%s'", sname);
 	i = mvc_bind_idx(sql, s, iname);
	if (!i) {
		return sql_message("42S12!DROP INDEX: no such index '%s'", iname);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message("42000!DROP INDEX: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	} else {
		mvc_drop_idx(sql, s, i);
	}
	return NULL;
}

static str
create_seq( mvc *sql, char *sname, sql_sequence *seq)
{
	sql_schema *s = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!CREATE SEQUENCE: no such schema '%s'", sname);
	if (s == NULL)
		s = cur_schema(sql);
	if (find_sql_sequence(s, seq->base.name)) {
		return sql_message("42000!CREATE SEQUENCE: name '%s' already in use", seq->base.name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message( "42000!CREATE SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	sql_trans_create_sequence(sql->session->tr, s, seq->base.name, seq->start, seq->minvalue, seq->maxvalue, seq->increment, seq->cacheinc, seq->cycle, seq->bedropped);
	return NULL;
}

static str
alter_seq( mvc *sql, char *sname, sql_sequence *seq, lng *val)
{
	sql_schema *s = NULL;
	sql_sequence *nseq = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!ALTER SEQUENCE: no such schema '%s'", sname);
	if (s == NULL)
		s = cur_schema(sql);
	if (!(nseq = find_sql_sequence(s, seq->base.name))) {
		return sql_message( "42000!ALTER SEQUENCE: no such sequence '%s'", seq->base.name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message( "42000!ALTER SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}

	/* first alter the known values */
	sql_trans_alter_sequence(sql->session->tr, nseq, seq->minvalue, seq->maxvalue, seq->increment, seq->cacheinc, seq->cycle);
	if (val)
		sql_trans_sequence_restart(sql->session->tr, nseq, *val);
	return MAL_SUCCEED;
}




static str
drop_seq(mvc *sql, char *sname, char *name)
{
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!DROP SEQUENCE: no such schema '%s'", sname);
	if (!s)
		s = cur_schema(sql);
	if (!(seq = find_sql_sequence(s, name))) {
		return sql_message("42M35!DROP SEQUENCE: no such sequence '%s'", name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message("42000!DROP SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"),  s->base.name);
	}
	if (mvc_check_dependency(sql, seq->base.id, BEDROPPED_DEPENDENCY, NULL))
		return sql_message("2B000!DROP SEQUENCE: unable to drop sequence %s (there are database objects which depend on it)\n", seq->base.name);

	sql_trans_drop_sequence(sql->session->tr, s, seq, 0);
	return NULL;
}

static str
drop_func( mvc *sql, char *sname, char *name, int fid, int type, int action)
{
	sql_schema *s = NULL;
	char is_aggr = (type == F_AGGR);
	char is_func = (type != F_PROC);
	char *F = is_aggr?"AGGREGATE":(is_func?"FUNCTION":"PROCEDURE");
	char *f = is_aggr?"aggregate":(is_func?"function":"procedure");
	char *KF = type==F_FILT?"FILTER ": type==F_UNION?"UNION ": "";
	char *kf = type==F_FILT?"filter ": type==F_UNION?"union ": "";

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!DROP %s%s: no such schema '%s'", KF, F, sname);
	if (!s)
		s = cur_schema(sql);
	if (fid >= 0) {
		node *n = find_sql_func_node(s, fid);
		if (n) {
			sql_func *func = n->data;

			if (!schema_privs(sql->role_id, s)) {
				return sql_message("DROP %s%s: access denied for %s to schema ;'%s'", KF, F, stack_get_string(sql, "current_user"), s->base.name);
	}
			if (!action && mvc_check_dependency(sql, func->base.id, !IS_PROC(func) ? FUNC_DEPENDENCY : PROC_DEPENDENCY, NULL))
				return sql_message("DROP %s%s: there are database objects dependent on %s%s %s;", KF, F, kf, f, func->base.name);
	
			if (is_func && func->res.comp_type) 
				mvc_drop_table(sql, func->res.comp_type->s, func->res.comp_type, 0);
			mvc_drop_func(sql, s, func, action); 
		}
	} else {
		node *n = NULL;
		list *list_func = schema_bind_func(sql, s, name, type);

		if (!schema_privs(sql->role_id, s)) {
			list_destroy(list_func);
			return sql_message("DROP %s%s: access denied for %s to schema ;'%s'", KF, F, stack_get_string(sql, "current_user"), s->base.name);
		}
		for( n = list_func->h ; n; n = n->next) {
			sql_func *func = n->data;

			if (!action && mvc_check_dependency(sql, func->base.id, !IS_PROC(func) ? FUNC_DEPENDENCY : PROC_DEPENDENCY, list_func)) {
				list_destroy(list_func);
				return sql_message("DROP %s%s: there are database objects dependent on %s%s %s;", KF, F, kf, f, func->base.name);
			}
		}
		mvc_drop_all_func(sql, s, list_func, action);
		list_destroy(list_func);
	}
	return MAL_SUCCEED;
}

static char *
create_func( mvc *sql, char *sname, sql_func *f )
{
	sql_func *nf;
	sql_schema *s = NULL;
	char is_aggr = (f->type == F_AGGR);
	char is_func = (f->type != F_PROC);
	char *F = is_aggr?"AGGREGATE":(is_func?"FUNCTION":"PROCEDURE");
	char *KF = f->type==F_FILT?"FILTER ": f->type==F_UNION?"UNION ": "";

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!CREATE %s%s: no such schema '%s'", KF, F, sname);
	if (!s)
		s = cur_schema(sql);
	nf = mvc_create_func(sql, NULL, s, f->base.name, f->ops, &f->res, f->type, f->mod, f->imp, f->query);
	if (nf && nf->query) {
		char *buf;
		sql_rel *r = NULL;
		sql_allocator *sa = sql->sa;

		sql->sa = sa_create();
		buf = sa_strdup(sql->sa, nf->query);
		r = rel_parse(sql, buf, m_deps); 
		if (r) {
			stmt *sb = rel_bin(sql, r);
			list *id_col_l = stmt_list_dependencies(sql->sa, sb, COLUMN_DEPENDENCY);
			list *id_func_l = stmt_list_dependencies(sql->sa, sb, FUNC_DEPENDENCY);
			list *view_id_l = stmt_list_dependencies(sql->sa, sb, VIEW_DEPENDENCY);

			mvc_create_dependencies(sql, id_col_l, nf->base.id, !IS_PROC(f) ? FUNC_DEPENDENCY : PROC_DEPENDENCY);
			mvc_create_dependencies(sql, id_func_l, nf->base.id, !IS_PROC(f) ? FUNC_DEPENDENCY : PROC_DEPENDENCY);
			mvc_create_dependencies(sql, view_id_l, nf->base.id, !IS_PROC(f) ? FUNC_DEPENDENCY : PROC_DEPENDENCY);
		}
		sa_destroy(sql->sa);
		sql->sa = sa;
	} else {
		if (!backend_resolve_function(sql, nf)) 
			return sql_message("3F000!CREATE %s%s: external name %s.%s not bound", KF, F, nf->mod, nf->base.name);
	}
	return MAL_SUCCEED;
}

static char *
create_trigger( mvc *sql, char *sname, char *tname, char *triggername, int time, int orientation, int event, char *old_name, char *new_name, char *condition, char *query)
{
	sql_trigger *tri = NULL;
	sql_schema *s = NULL;
	sql_table *t;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!CREATE TRIGGER: no such schema '%s'", sname);
	if (!s)
		s = cur_schema(sql);
	if (!schema_privs(sql->role_id, s)) 
		return sql_message("3F000!CREATE TRIGGER: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	if (mvc_bind_trigger(sql, s, triggername ) != NULL) 
		return sql_message("3F000!CREATE TRIGGER: name '%s' already in use", triggername);
	
	if (!(t = mvc_bind_table(sql, s, tname)))
		return sql_message("3F000!CREATE TRIGGER: unknown table '%s'", tname);

	if (isView(t)) 
		return sql_message("3F000!CREATE TRIGGER: cannot create trigger on view '%s'", tname);

	tri = mvc_create_trigger(sql, t, triggername, time, orientation, event, old_name, new_name, condition, query);
	if (tri) {
		char *buf;
		sql_rel *r = NULL;
		sql_allocator *sa = sql->sa;

		sql->sa = sa_create();
		buf = sa_strdup(sql->sa, query);
		r = rel_parse(sql, buf, m_deps); 
		if (r) {
			stmt *sqs = rel_bin(sql, r);
			list *col_l = stmt_list_dependencies(sql->sa, sqs, COLUMN_DEPENDENCY);
			list *func_l = stmt_list_dependencies(sql->sa, sqs, FUNC_DEPENDENCY);
			list *view_id_l = stmt_list_dependencies(sql->sa, sqs, VIEW_DEPENDENCY);

			mvc_create_dependencies(sql, col_l, tri->base.id, TRIGGER_DEPENDENCY);
			mvc_create_dependencies(sql, func_l, tri->base.id, TRIGGER_DEPENDENCY);
			mvc_create_dependencies(sql, view_id_l, tri->base.id, TRIGGER_DEPENDENCY);
		}
		sa_destroy(sql->sa);
		sql->sa = sa;
	}
	return MAL_SUCCEED;
}

static char *
drop_trigger( mvc *sql, char *sname, char *tname)
{
	sql_trigger *tri = NULL;
	sql_schema *s = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("3F000!DROP TRIGGER: no such schema '%s'", sname);
	if (!s)
		s = cur_schema(sql);
	if (s && !schema_privs(sql->role_id, s)) 
		return sql_message("3F000!DROP TRIGGER: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);

	if ((tri = mvc_bind_trigger(sql, s, tname)) == NULL)
		return sql_message("3F000!DROP TRIGGER: unknown trigger %s\n", tname);
	mvc_drop_trigger(sql, s, tri);
	return MAL_SUCCEED;
}

static char *
SaveArgReference(MalStkPtr stk, InstrPtr pci, int arg)
{
	char *val = *(str*)getArgReference(stk, pci, arg);

	if (val && strcmp(val, str_nil) == 0)
		val = NULL;
	return val;
}

str
SQLcatalog(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getSQLContext(cntxt, mb, &sql, NULL);
	int type = *(int*) getArgReference(stk, pci, 1);
	str sname = *(str*) getArgReference(stk, pci, 2);

	if (msg)
		return msg;

	if (STORE_READONLY) 
		return sql_message("25006!schema statements cannot be executed on a readonly database.");

	switch (type) {
	case DDL_CREATE_SEQ:
	{
		sql_sequence *s = *(sql_sequence**) getArgReference(stk, pci, 3);
		msg = create_seq(sql, sname, s);
	} 	break;
	case DDL_ALTER_SEQ:
	{
		lng *val = NULL;
		sql_sequence *s = *(sql_sequence**) getArgReference(stk, pci, 3);
		if (getArgType(mb, pci, 4) == TYPE_lng) 
			val = getArgReference(stk, pci, 4);
		if (val == NULL || *val == lng_nil)
			msg = sql_message("42M36!ALTER SEQUENCE: cannot (re)start with NULL");
		else
			msg = alter_seq(sql, sname, s, val);
	} 	break;
	case DDL_DROP_SEQ: {
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_seq( sql, sname, name);
	} 	break;
	case DDL_CREATE_SCHEMA: {
		str name = SaveArgReference(stk, pci, 3);
		int auth_id = sql->role_id;

		if (name && (auth_id = sql_find_auth(sql, name)) < 0) {
			msg = sql_message("42M32!CREATE SCHEMA: no such authorization '%s'", name);
		}
		if (sql->user_id != USER_MONETDB && sql->role_id != ROLE_SYSADMIN) {
			msg = sql_message("42000!CREATE SCHEMA: insufficient privileges for user '%s'", stack_get_string(sql, "current_user"));
		}
		if (mvc_bind_schema(sql, sname)) {
			msg = sql_message("3F000!CREATE SCHEMA: name '%s' already in use", sname);
		} else {
			(void)mvc_create_schema(sql, sname, auth_id, sql->user_id);
		}
	}	break;
	case DDL_DROP_SCHEMA: {
		int action = *(int*) getArgReference(stk, pci, 4);
		sql_schema *s = mvc_bind_schema(sql, sname);

		if (!s) {
			msg = sql_message("3F000!DROP SCHEMA: name %s does not exist", sname);
		} else if (!schema_privs(sql->role_id, s)) {
			msg = sql_message("42000!DROP SCHEMA: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
		} else if (s == cur_schema(sql)) {
			msg = sql_message("42000!DROP SCHEMA: cannot drop current schema");
		} else if (strcmp(sname, "sys") == 0 || strcmp(sname, "tmp") == 0) {
			msg = sql_message("42000!DROP SCHEMA: access denied for '%s'", sname);
		} else if (sql_schema_has_user(sql, s)) {
			msg = sql_message("2BM37!DROP SCHEMA: unable to drop schema '%s' (there are database objects which depend on it", sname);
		} else {
			mvc_drop_schema(sql, s, action);
		}
	} 	break;
	case DDL_CREATE_TABLE: 
	case DDL_CREATE_VIEW: 
	{
		sql_table *t = *(sql_table**) getArgReference(stk, pci, 3);
		int temp = *(int*) getArgReference(stk, pci, 4);

		msg = create_table_or_view(sql, sname, t, temp);
	} 	break;
	case DDL_DROP_TABLE: {
		int action = *(int*) getArgReference(stk, pci, 4);
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_table( sql, sname, name, action);
	} 	break;
	case DDL_DROP_VIEW: {
		int action = *(int*) getArgReference(stk, pci, 4);
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_view( sql, sname, name, action);
	} 	break;
	case DDL_DROP_CONSTRAINT: {
		int action = *(int*) getArgReference(stk, pci, 4);
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_key( sql, sname, name, action);
	} 	break;
	case DDL_ALTER_TABLE: {
		sql_table *t = *(sql_table**) getArgReference(stk, pci, 3);
		msg = alter_table(sql, sname, t);
	} 	break;
	case DDL_CREATE_TYPE: {
		char *impl = *(str*) getArgReference(stk, pci, 3);
		if (!mvc_create_type(sql, sql->session->schema, sname, 0, 0, 0, impl)) 
			msg = sql_message("0D000!CREATE TYPE: unknown external type '%s'", impl);
	} 	break;
	case DDL_DROP_TYPE: {
		msg = sql_message("0A000!DROP TYPE: not implemented ('%s')", sname);
	} 	break;
	case DDL_GRANT_ROLES: {
		char *auth = SaveArgReference(stk, pci, 3);

		msg = sql_grant_role( sql, sname /*grantee */, auth);
	} 	break;
	case DDL_REVOKE_ROLES: {
		char *auth = SaveArgReference(stk, pci, 3);

		msg = sql_revoke_role( sql, sname /*grantee */, auth);
	} 	break;
	case DDL_GRANT: {
		char *tname = *(str*)getArgReference(stk, pci, 3);
		char *grantee = *(str*)getArgReference(stk, pci, 4);
		int privs = *(int*)getArgReference(stk, pci, 5);
		char *cname = SaveArgReference(stk, pci, 6);
		int grant = *(int*)getArgReference(stk, pci, 7);
		int grantor = *(int*)getArgReference(stk, pci, 8);
		msg = sql_grant_table_privs( sql, grantee, privs, sname, tname, cname, grant, grantor);
	} 	break;
	case DDL_REVOKE: {
		char *tname = *(str*)getArgReference(stk, pci, 3);
		char *grantee = *(str*)getArgReference(stk, pci, 4);
		int privs = *(int*)getArgReference(stk, pci, 5);
		char *cname = SaveArgReference(stk, pci, 6);
		int grant = *(int*)getArgReference(stk, pci, 7);
		int grantor = *(int*)getArgReference(stk, pci, 8);
		msg = sql_revoke_table_privs( sql, grantee, privs, sname, tname, cname, grant, grantor);
	} 	break;
	case DDL_CREATE_USER: {
		char *passwd = *(str*)getArgReference(stk, pci, 3);
		int enc = *(int*)getArgReference(stk, pci, 4);
		char *schema = SaveArgReference(stk, pci, 5);
		char *fullname = SaveArgReference(stk, pci, 6);
		msg = sql_create_user( sql, sname, passwd, enc, fullname, schema);
	}	break;
	case DDL_DROP_USER: {
		msg = sql_drop_user( sql, sname);
	}	break;
	case DDL_ALTER_USER: {
		char *passwd = SaveArgReference(stk, pci, 3);
		int enc = *(int*)getArgReference(stk, pci, 4);
		char *schema = SaveArgReference(stk, pci, 5);
		char *oldpasswd = SaveArgReference(stk, pci, 6);
		msg = sql_alter_user( sql, sname, passwd, enc, schema, oldpasswd);
	}	break;
	case DDL_RENAME_USER: {
		char *newuser = *(str*)getArgReference(stk, pci, 3);
		msg = sql_rename_user( sql, sname, newuser);
	}	break;
	case DDL_CREATE_ROLE: {
		char *role = sname;
		int grantor = *(int*)getArgReference(stk, pci, 4);
		msg = sql_create_role( sql, role, grantor);
	} 	break;
	case DDL_DROP_ROLE: {
		char *role = sname;
		msg = sql_drop_role( sql, role);
	} 	break;
	case DDL_CREATE_INDEX: {
		int itype = *(int*)getArgReference(stk, pci, 3);
		char *ssname = *(str*)getArgReference(stk, pci, 4);
		char *tname = *(str*)getArgReference(stk, pci, 5);
		msg = create_index( sql, sname, itype, ssname, tname, stk, pci);
	} 	break;
	case DDL_DROP_INDEX: {
		char *iname = *(str*)getArgReference(stk, pci, 3);
		msg = drop_index( sql, sname, iname );
	} 	break;
	case DDL_DROP_FUNCTION: {
		char *fname = *(str*)getArgReference(stk, pci, 3);
		int fid = *(int*)getArgReference(stk, pci, 4);
		int type = *(int*)getArgReference(stk, pci, 5);
		int action = *(int*)getArgReference(stk, pci, 6);
		msg = drop_func( sql, sname, fname, fid, type, action );
	} 	break;
	case DDL_CREATE_FUNCTION: {
		sql_func *f = *(sql_func**)getArgReference(stk, pci, 3);
		msg = create_func(sql, sname, f);
	} 	break;
	case DDL_CREATE_TRIGGER: {
		char *tname = *(str*)getArgReference(stk, pci, 3);
		char *triggername = *(str*)getArgReference(stk, pci, 4);
		int time = *(int*)getArgReference(stk, pci, 5);
		int orientation = *(int*)getArgReference(stk, pci, 6);
		int event = *(int*)getArgReference(stk, pci, 7);
		char *old_name = *(str*)getArgReference(stk, pci, 8);
		char *new_name = *(str*)getArgReference(stk, pci, 9);
		char *condition = *(str*)getArgReference(stk, pci, 10);
		char *query = *(str*)getArgReference(stk, pci, 11);

		msg = create_trigger(sql, sname, tname, triggername, time, orientation, event, old_name, new_name, condition, query);
	} 	break;
	case DDL_DROP_TRIGGER: {
		char *triggername = *(str*)getArgReference(stk, pci, 3);

		msg = drop_trigger(sql, sname, triggername);
	} 	break;
	default:
		throw(SQL, "sql.catalog", "catalog unknown type");
	}
	if (msg)
		return msg;
	return MAL_SUCCEED;
}

/* setVariable(int *ret, str *name, any value) */
str
setVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt, mb, &m, NULL);
	str varname   = *(str *) getArgReference(stk, pci, 2);
	int mtype = getArgType(mb, pci, 3);
	ValRecord *src;
	char buf[BUFSIZ];

	*res = 0;
	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.setVariable", "failed");
	if ( strcmp("optimizer",  varname)== 0) {
		str newopt = *(str *) getArgReference(stk,pci,3);
		if ( newopt) {
			if ( ! isOptimizerPipe(newopt)  && strchr(newopt,(int)';') == 0){
				snprintf(buf, BUFSIZ, "optimizer '%s' unknown", newopt);
				throw(SQL, "sql.setVariable", "%s", buf);
			}
			snprintf(buf,BUFSIZ,"user_%d",cntxt->idx);
			if ( ! isOptimizerPipe(newopt) || strcmp(buf,newopt) == 0){
				msg = addPipeDefinition(cntxt, buf, newopt);
				if ( msg )
					return msg;
				if (stack_find_var(m, varname)) 
					stack_set_string(m, varname, buf);
			} else
				if (stack_find_var(m, varname)) 
					stack_set_string(m, varname, newopt);
		}
		return MAL_SUCCEED;
	}
	src = &stk->stk[getArg(pci, 3)];
	if (stack_find_var(m, varname)) {
		stack_set_var(m, varname, src);
	} else {
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.setVariable", "%s", buf);
	}
	if ((msg = sql_update_var(m, varname)) != NULL) {
		snprintf(buf, BUFSIZ, "%s", msg);
		_DELETE(msg);
		throw(SQL, "sql.setVariable", "%s", buf);
	}
	return MAL_SUCCEED;
}

/* getVariable(int *ret, str *name) */
str
getVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int mtype = getArgType(mb, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt, mb, &m, NULL);
	str varname   = *(str *) getArgReference(stk, pci, 2);
	ValRecord *dst, *src;

	if (msg)
		return msg;
	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.getVariable", "failed");
	src = stack_get_var(m, varname);
	if (!src) {
		char buf[BUFSIZ];
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.getVariable", "%s", buf);
	}
	dst = &stk->stk[getArg(pci, 0)];
	VALcopy(dst,src);
	return MAL_SUCCEED;
}

str
sql_variables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	mvc *m = NULL;
	BAT *vars; 
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int *res = (int *) getArgReference(stk, pci, 0);

	if (msg)
		return msg;

	vars = BATnew(TYPE_void,TYPE_str, m->topvars);
	if ( vars == NULL)
		throw(SQL, "sql.variables", MAL_MALLOC_FAIL);
	BATseqbase(vars, 0);
	for (i=0; i<m->topvars && m->vars[i].s; i++) 
		BUNappend(vars, m->vars[i].name, FALSE);
	*res = vars->batCacheid;
	BBPkeepref(vars->batCacheid);
	return MAL_SUCCEED;
}

/* str mvc_logfile(int *d, str *filename); */
str
mvc_logfile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int *res = (int *) getArgReference(stk, pci, 0);
	str filename = *(str *)getArgReference(stk, pci, 1);

	if (msg)
		return msg;
	if (m->scanner.log) {
		close_stream(m->scanner.log);
		m->scanner.log = NULL;
	}

	if (strcmp(filename, str_nil)) 
		m->scanner.log = open_wastream(filename);
	*res = 0;
	return MAL_SUCCEED;
}

/* str mvc_next_value(lng *res, str *sname, str *seqname); */
str
mvc_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_next_value(seq, res)) {
			m->last_id = *res;
			stack_set_number(m, "last_id", m->last_id);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.next_value", "error");
}

/* str mvc_bat_next_value(bat *res, int *sid, str *seqname); */
str
mvc_bat_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	BAT *b, *r;
	BUN p,q;
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;
	seqbulk *sb = NULL;
	BATiter bi;
	bat *res  = (bat *) getArgReference(stk, pci, 0);
	int *sid  = (int *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;

	if( (b = BATdescriptor(*sid)) == NULL )
		throw(SQL, "sql.next_value", "Cannot access descriptor");

	r = BATnew(b->htype, TYPE_lng, BATcount(b));
	if (!r) {
		BBPunfix(b->batCacheid);
		throw(SQL, "sql.next_value", "Cannot create bat");
	}
	BATseqbase(r, b->hseqbase);

	if (!BATcount(b)) {
		BBPunfix(b->batCacheid);
		BBPkeepref(r->batCacheid);
		*res = r->batCacheid;
		return MAL_SUCCEED;
	}

	bi = bat_iterator(b);
	BATloop(b,p,q){
		str sname = BUNtail(bi,BUNfirst(b));
		lng l;

		if (!s || strcmp(s->base.name, sname) != 0) {
			if (sb)
				seqbulk_destroy(sb);
			s = mvc_bind_schema(m, sname);
			seq = NULL;
			if (!s || 
			    (seq = find_sql_sequence(s, *seqname)) == NULL ||
			    !(sb = seqbulk_create(seq, BATcount(b))) ) {
				BBPunfix(b->batCacheid);
				BBPunfix(r->batCacheid);
				throw(SQL, "sql.next_value", "error");
			}
		}
		if (!seqbulk_next_value(sb, &l)) {
			BBPunfix(b->batCacheid);
			BBPunfix(r->batCacheid);
			seqbulk_destroy(sb);
			throw(SQL, "sql.next_value", "error");
		}
		BUNins(r, BUNhead(bi,p), &l, FALSE);
	}
	if (sb) 
		seqbulk_destroy(sb);
	BBPunfix(b->batCacheid);
	BBPkeepref(r->batCacheid);
	*res = r->batCacheid;
	return MAL_SUCCEED;
}

/* str mvc_get_value(lng *res, str *sname, str *seqname); */
str
mvc_get_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_get_value(seq, res))
			return MAL_SUCCEED;
	}
	throw(SQL, "sql.get_value", "error");
}

str
mvc_getVersion(lng *version, int *clientid)
{
	mvc *m = NULL;
	Client cntxt = MCgetClient(*clientid);
	str msg = getSQLContext(cntxt, NULL, &m, NULL);

	if (msg)
		return msg;
	*version = -1;
	if (m->session->tr)
		*version = m->session->tr->stime;
	return MAL_SUCCEED;
}

/* str mvc_restart_seq(lng *res, str *sname, str *seqname, lng *start); */
str
mvc_restart_seq(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);
	lng *start  = (lng *) getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	if (*start == lng_nil)
		throw(SQL, "sql.restart", "cannot (re)start with NULL");
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq) {
			*res = sql_trans_sequence_restart(m->session->tr, seq, *start);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.restart", "sequence %s not found", *sname);
}

static BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_column *c = NULL;

	s = mvc_bind_schema(m, sname);
	if ( s == NULL) 
		return NULL;
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL) 
		return NULL;
	c = mvc_bind_column(m, t, cname);
	if ( c == NULL) 
		return NULL;

	b = store_funcs.bind_col(tr, c, access);
	return b;
}

BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_table *t = NULL;

	s = mvc_bind_schema(m, sname);
	if (s == NULL)
		return NULL;
	t = mvc_bind_table(m, s, tname);
	if (t == NULL)
		return NULL;

	b = store_funcs.bind_del(tr, t, access);
	return b;
}

BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_idx *i = NULL;

	s = mvc_bind_schema(m, sname);
	if (s == NULL)
		return NULL;
	i = mvc_bind_idx(m, s, iname);
	if (i == NULL)
		return NULL;

	(void) tname;
	b = store_funcs.bind_idx(tr, i, access);
	return b;
}

/* str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access); */
str
mvc_bind_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int upd = (pci->argc == 7 || pci->argc == 9);
	BAT *b = NULL, *bn;
	int *bid = (int *)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	str *sname = (str *)getArgReference(stk, pci, 2+upd);
	str *tname = (str *)getArgReference(stk, pci, 3+upd);
	str *cname = (str *)getArgReference(stk, pci, 4+upd);
	int *access = (int *)getArgReference(stk, pci, 5+upd);

	if (msg)
		return msg;
	b = mvc_bind(m, *sname, *tname, *cname, *access);
	if (b) {
		if ( pci->argc == (8+upd) && getArgType(mb,pci,6+upd) == TYPE_int){
			BUN cnt = BATcount(b), psz;
			/* partitioned access */
			int part_nr = *(int *)getArgReference(stk, pci, 6+upd);
			int nr_parts = *(int *)getArgReference(stk, pci, 7+upd);

			if (*access == 0) {
				psz = cnt?(cnt/nr_parts):0;
				bn =  BATslice(b, part_nr*psz, (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz));
				BATseqbase(bn, part_nr*psz);
			} else {
				oid l, h;
				BAT *c = mvc_bind(m, *sname, *tname, *cname, 0);
				cnt = BATcount(c);
				psz = cnt?(cnt/nr_parts):0;
				l = part_nr*psz;
				h = (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz);
				h--;
				bn = BATmirror(BATselect(BATmirror(b), &l, &h));
				BBPreleaseref(c->batCacheid);
			}
			BBPreleaseref(b->batCacheid);
			b = bn;
		}
		if (upd) {
			int *uvl = (int *)getArgReference(stk, pci, 1);

			if (BATcount(b)) {
				BAT *id = BATmirror(BATmark(b, 0));
				BAT *vl = BATmirror(BATmark(BATmirror(b), 0));
				BBPkeepref( *bid = id->batCacheid);
				BBPkeepref( *uvl = vl->batCacheid);
			} else {
				*bid = e_bat(TYPE_oid); 
				*uvl = e_bat(b->T->type); 
			}
			BBPreleaseref(b->batCacheid);
		} else {
			BBPkeepref( *bid = b->batCacheid);
		}
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.bind", "unable to find %s.%s(%s)", *sname, *tname, *cname);
}


/* str mvc_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *iname, int *access); */
str
mvc_bind_idxbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int upd = (pci->argc == 7 || pci->argc == 9);
	BAT *b = NULL,*bn;
	int *bid = (int *)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	str *sname = (str *)getArgReference(stk, pci, 2+upd);
	str *tname = (str *)getArgReference(stk, pci, 3+upd);
	str *iname = (str *)getArgReference(stk, pci, 4+upd);
	int *access = (int *)getArgReference(stk, pci, 5+upd);

	if (msg)
		return msg;
	b = mvc_bind_idxbat(m, *sname, *tname, *iname, *access);
	if (b) {
		if ( pci->argc == (8+upd) && getArgType(mb,pci,6+upd) == TYPE_int){
			BUN cnt = BATcount(b), psz;
			/* partitioned access */
			int part_nr = *(int *)getArgReference(stk, pci, 6+upd);
			int nr_parts = *(int *)getArgReference(stk, pci, 7+upd);

			if (*access == 0) {
				psz = cnt?(cnt/nr_parts):0;
				bn =  BATslice(b, part_nr*psz, (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz));
				BATseqbase(bn, part_nr*psz);
			} else {
				oid l, h;
				BAT *c = mvc_bind_idxbat(m, *sname, *tname, *iname, 0);
				cnt = BATcount(c);
				psz = cnt?(cnt/nr_parts):0;
				l = part_nr*psz;
				h = (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz);
				h--;
				bn = BATmirror(BATselect(BATmirror(b), &l, &h));
				BBPreleaseref(c->batCacheid);
			}
			BBPreleaseref(b->batCacheid);
			b = bn;
		}
		if (upd) {
			int *uvl = (int *)getArgReference(stk, pci, 1);

			if (BATcount(b)) {
				BAT *id = BATmirror(BATmark(b, 0));
				BAT *vl = BATmirror(BATmark(BATmirror(b), 0));
				BBPkeepref( *bid = id->batCacheid);
				BBPkeepref( *uvl = vl->batCacheid);
			} else {
				*bid = e_bat(TYPE_oid); 
				*uvl = e_bat(b->T->type); 
			}
			BBPreleaseref(b->batCacheid);
		} else {
			BBPkeepref( *bid = b->batCacheid);
		}
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.idxbind", "unable to find index %s for %s.%s", *iname, *sname, *tname);
}

/*mvc_append_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_append_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);
	str cname = *(str *)getArgReference(stk, pci, 4);
	ptr ins = (ptr)getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	sql_schema *s;
	sql_table *t;
	sql_column *c;

	*res = 0;
	if (msg)
		return msg;
	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.append","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(SQL,"sql.append","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(SQL,"sql.append","Table missing");
	if (cname[0] != '%' && (c = mvc_bind_column(m, t, cname)) != NULL) {
		store_funcs.append_col(m->session->tr, c, ins, tpe);
	} else if (cname[0] == '%') {
		sql_idx *i = mvc_bind_idx(m, s, cname+1);
		if (i)
			store_funcs.append_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat) {
		BBPunfix(((BAT*)ins)->batCacheid);
	}
	return MAL_SUCCEED;
}

/*mvc_update_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_update_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);
	str cname = *(str *)getArgReference(stk, pci, 4);
	bat Tids = *(bat*)getArgReference(stk, pci, 5);
	bat Upd = *(bat*)getArgReference(stk, pci, 6);
	BAT *tids, *upd;
	int tpe = getArgType(mb, pci, 6);
	sql_schema *s;
	sql_table *t;
	sql_column *c;

	*res = 0;
	if (msg)
		return msg;
	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	else
		assert(0);
	if (tpe != TYPE_bat)
		throw(SQL, "sql.update", "bat expected");
	if ((tids = BATdescriptor(Tids)) == NULL)
		throw(SQL, "sql.update","Cannot access descriptor");
	if ((upd = BATdescriptor(Upd)) == NULL) {
		BBPunfix(tids->batCacheid);
		throw(SQL, "sql.update","Cannot access descriptor");
	}
	s = mvc_bind_schema(m, sname);
	if ( s == NULL) {
		BBPunfix(tids->batCacheid);
		BBPunfix(upd->batCacheid);
		throw(SQL,"sql.update","Schema missing");
	}
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL) {
		BBPunfix(tids->batCacheid);
		BBPunfix(upd->batCacheid);
		throw(SQL,"sql.update","Table missing");
	}
	if (cname[0] != '%' && (c = mvc_bind_column(m, t, cname)) != NULL) {
		store_funcs.update_col(m->session->tr, c, tids, upd, tpe);
	} else if (cname[0] == '%') {
 		sql_idx *i = mvc_bind_idx(m, s, cname+1);
		if (i)
			store_funcs.update_idx(m->session->tr, i, tids, upd, tpe);
	}
	BBPunfix(tids->batCacheid);
	BBPunfix(upd->batCacheid);
	return MAL_SUCCEED;
}

/*
 * @-
 * Monet 5 extension
 * @-
 * The Mx macro below is used in many places throughout the code base to
 * access the BAT descriptor.
 */
@= chkIdentifier
	/* generate exception if string is not an identifier */
	if( isIdentifier(@1))
		throw(SQL,  "@4","identifier expected");
@= Pseudo
	if (BBPindex("@1_@2_@3") <= 0)
		BATname(b, "@1_@2_@3");
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;

@
@c

/* str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access); */
str
mvc_bind_dbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int *ret = (int *)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	str *sname = (str *)getArgReference(stk, pci, 2);
	str *tname = (str *)getArgReference(stk, pci, 3);
	int *access = (int*)getArgReference(stk, pci, 4);

	if (msg)
		return msg;
	b = mvc_bind_dbat(m, *sname, *tname, *access);
	if (b) {
		BBPkeepref( *ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_dbat_wrap", "error");
}

/* str mvc_clear_table_wrap(wrd *res, str *sname, str *tname); */
str
mvc_clear_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema *s;
	sql_table *t;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	wrd *res = (wrd *)getArgReference(stk, pci, 0);
	str *sname = (str *)getArgReference(stk, pci, 1);
	str *tname = (str *)getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	if ( s == NULL)
		throw(SQL,"sql.clear_table","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( t == NULL)
		throw(SQL,"sql.clear_table","42S02!Table missing");
	*res = mvc_clear_table(m, t);
	return MAL_SUCCEED;
}

/*mvc_delete_wrap(int *d, str *sname, str *tname, ptr d) */
str
mvc_delete_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);
	ptr ins = (ptr)getArgReference(stk, pci, 4);
	int tpe = getArgType(mb, pci, 4);
	BAT *b = NULL;

	sql_schema *s;
	sql_table *t;

	*res = 0;
	if (msg)
		return msg;
	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (b = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.delete","Cannot access descriptor");
	if (tpe != TYPE_bat || (b->ttype != TYPE_oid && b->ttype != TYPE_void))
		throw(SQL, "sql.delete","Cannot access descriptor");
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(SQL,"sql.delete","3F000!Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(SQL,"sql.delete","42S02!Table missing");
	store_funcs.delete_tab(m->session->tr, t, b, tpe);
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

static BAT *
setwritable(BAT *b)
{
	BAT *bn;

	bn = BATsetaccess(b, BAT_WRITE);	/* can return NULL */
	if (b != bn)
		BBPunfix(b->batCacheid);
	return bn;
}

str 
DELTAbat2(bat *result, bat *col, bat *uid, bat *uval)
{
	return DELTAbat(result, col, uid, uval, NULL);
}

str 
DELTAsub2(bat *result, bat *col, bat *uid, bat *uval)
{
	return DELTAsub(result, col, uid, uval, NULL);
}

str 
DELTAproject2(bat *result, bat *sub, bat *col, bat *uid, bat *uval)
{
	return DELTAproject(result, sub, col, uid, uval, NULL);
}

str 
DELTAbat(bat *result, bat *col, bat *uid, bat *uval, bat *ins)
{
	BAT *c, *u_id, *u_val, *u, *i = NULL, *res;

	if ((u_id = BBPquickdesc(ABS(*uid), 0)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	if (ins && (i = BBPquickdesc(ABS(*ins), 0)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);

	/* no updates, no inserts */
	if (BATcount(u_id) == 0 && (!i || BATcount(i) == 0)) {
		BBPincref(*result = *col, TRUE);
		return MAL_SUCCEED;
	}

	if ((c = BBPquickdesc(ABS(*col), 0)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);

	/* bat may change */
	if (i && BATcount(c) == 0 && BATcount(u_id) == 0) {
		BBPincref(*result = *ins, TRUE);
		return MAL_SUCCEED;
	}

	c = BATdescriptor(*col);
	if ((res = BATcopy(c, TYPE_void, c->ttype, TRUE)) == NULL) 
		throw(MAL, "sql.delta", OPERATION_FAILED);
	BBPunfix(c->batCacheid);

	if ((u_val = BATdescriptor(*uval)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	u_id = BATdescriptor(*uid);
	u = BATleftfetchjoin(BATmirror(u_id), u_val, BATcount(u_val));
	BBPunfix(u_id->batCacheid);
	BBPunfix(u_val->batCacheid);
	if (BATcount(u)) 
		res = BATreplace(res, u, TRUE);
	BBPunfix(u->batCacheid);

	if (i && BATcount(i)) {
		i = BATdescriptor(*ins);
		res = BATappend(res, i, TRUE);
		BBPunfix(i->batCacheid);
	}

	BBPkeepref(*result = res->batCacheid);
	return MAL_SUCCEED;
}

str 
DELTAsub(bat *result, bat *col, bat *uid, bat *uval, bat *ins)
{
	BAT *c, *cminu, *u_id, *u_val, *u, *i = NULL, *res;

	if ((u_id = BBPquickdesc(ABS(*uid), 0)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	if (ins && (i = BBPquickdesc(ABS(*ins), 0)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);

	/* no updates, no inserts */
	if (BATcount(u_id) == 0 && (!i || BATcount(i) == 0)) {
		BBPincref(*result = *col, TRUE);
		return MAL_SUCCEED;
	}

	if ((c = BBPquickdesc(ABS(*col), 0)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);

	/* bat may change */
	if (i && BATcount(c) == 0 && BATcount(u_id) == 0) {
		BBPincref(*result = *ins, TRUE);
		return MAL_SUCCEED;
	}

	c = BATdescriptor(*col);
	res = c;
	if (BATcount(u_id)) {
		u_id = BATdescriptor(*uid);
		cminu = BATkdiff(BATmirror(c), BATmirror(u_id));
		BBPunfix(c->batCacheid);
		c = BATmirror(BATmark(cminu, 0));
		BBPunfix(cminu->batCacheid);

		if ((u_val = BATdescriptor(*uval)) == NULL) {
			BBPunfix(c->batCacheid);
			BBPunfix(u_id->batCacheid);
			throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
		}
		u = BATleftfetchjoin(u_val, u_id, BATcount(u_val));
		BBPunfix(u_id->batCacheid);
		BBPunfix(u_val->batCacheid);
		res = BATappend(c, u, TRUE);
		BBPunfix(u->batCacheid);
	}

	if (i) {
		i = BATdescriptor(*ins);
		res = BATappend(res, i, TRUE);
		BBPunfix(i->batCacheid);
	}
	BBPkeepref(*result = res->batCacheid);
	return MAL_SUCCEED;
}

str 
DELTAproject(bat *result, bat *sub, bat *col, bat *uid, bat *uval, bat *ins)
{
	BAT *s, *c, *u_id, *u_val, *u, *i = NULL, *res, *tres;

	if ((s = BATdescriptor(*sub)) == NULL) 
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);

	if (ins && (i = BATdescriptor(*ins)) == NULL) {
		BBPunfix(s->batCacheid);
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	}

	if (i && BATcount(s) == 0) {
		res = BATleftfetchjoin(s, i, 0);
		BBPunfix(s->batCacheid);
		if (i) BBPunfix(i->batCacheid);

		BBPkeepref(*result = res->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(*col)) == NULL) {
		BBPunfix(s->batCacheid);
		if (i) BBPunfix(i->batCacheid);
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	}

	/* leftfetchjoin(sub,col).union(leftfetchjoin(sub,i)) */
	res = c;
	if (i && BATcount(i)) {
		if (BATcount(c) == 0) {
			res = i;
			i = c;
		} else {
			if ((res = BATcopy(c, TYPE_void, c->ttype, TRUE)) == NULL)
				throw(MAL, "sql.projectdelta", OPERATION_FAILED);
			res = BATappend(res,i,FALSE);
			BBPunfix(c->batCacheid);
		}
	}
	if (i) BBPunfix(i->batCacheid);

	tres = BATleftfetchjoin(s, res, BATcount(res));
	assert(tres);
	BBPunfix(res->batCacheid);
	res = tres;

	if ((u_id = BATdescriptor(*uid)) == NULL) {
		BBPunfix(res->batCacheid);
		BBPunfix(s->batCacheid);
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	}
	if (!BATcount(u_id)) {
		BBPunfix(u_id->batCacheid);
		BBPunfix(s->batCacheid);
		BBPkeepref(*result = res->batCacheid);
		return MAL_SUCCEED;
	}
	if ((u_val = BATdescriptor(*uval)) == NULL) {
		BBPunfix(u_id->batCacheid);
		BBPunfix(res->batCacheid);
		BBPunfix(s->batCacheid);
		throw(MAL, "sql.delta", RUNTIME_OBJECT_MISSING);
	}
	
	u = BATleftfetchjoin(BATmirror(u_id), u_val, BATcount(u_val));
	BBPunfix(u_id->batCacheid);
	BBPunfix(u_val->batCacheid);
	if (BATcount(u)) {
		BAT *nu = BATleftjoin(s, u, BATcount(u));
		res = setwritable(res);
		res = BATreplace(res, nu, 0);
		BBPunfix(nu->batCacheid);
	}
	BBPunfix(s->batCacheid);
	BBPunfix(u->batCacheid);

	BBPkeepref(*result = res->batCacheid);
	return MAL_SUCCEED;
}

/* str SQLtid(bat *result, mvc *m, str *sname, str *tname) */
str
SQLtid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);

	sql_schema *s;
	sql_table *t;
	sql_column *c;
	BAT *tids;
	size_t nr, sb = 0, inr = 0;

	*res = 0;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(SQL,"sql.tid","3F000!Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(SQL,"sql.tid","42S02!Table missing");
	c = t->columns.set->h->data;

	nr = store_funcs.count_col(tr, c, 1);

	if (isTable(t) && !t->readonly &&
	   (t->base.flag != TR_NEW /* alter */) &&
	    t->persistence == SQL_PERSIST && !t->commit_action) 
		inr = store_funcs.count_col(tr, c, 0);
	nr -= inr;
	if ( pci->argc == 6){ /* partitioned version */
		size_t cnt = nr;
		int part_nr = *(int *)getArgReference(stk, pci, 4);
		int nr_parts = *(int *)getArgReference(stk, pci, 5);

		nr /= nr_parts;
		sb = part_nr*nr;
		if (nr_parts == (part_nr+1)){ /* last part gets the inserts */
			nr = cnt - (part_nr*nr); /* keep rest */
			nr += inr;
		}
	} else {
		nr += inr;
	}

	/* create void,void bat with length and oid's set */
	tids = BATnew(TYPE_void, TYPE_void, 0);
	tids->H->seq = sb;
	tids->T->seq = sb;
	BATsetcount(tids, nr);
	tids->H->revsorted = 0;
	tids->T->revsorted = 0;
	
	if (store_funcs.count_del(tr, t)) {
		BAT *d = store_funcs.bind_del(tr, t, RD_INS);
		BAT *diff = BATkdiff(tids, BATmirror(d));

		BBPunfix(tids->batCacheid);
		tids = BATmirror(BATmark(diff, sb));
		BBPunfix(diff->batCacheid);
		BBPunfix(d->batCacheid);
	}
	BBPkeepref( *res = tids->batCacheid ); 
	return MAL_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results, NULL);
	return m->results->id;
}

/* str mvc_result_row_wrap(int *res_id, int *nr_cols, int *qtype, int *o); */
str
mvc_result_row_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	int *qtype = (int *)getArgReference(stk, pci, 2);
	int *o = (int *)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	(void)o; /* dummy order */
	*res_id = mvc_result_row(m, *nr_cols, *qtype); 
	if (*res_id < 0)
		throw(SQL, "sql.resultSet", "failed");
	return MAL_SUCCEED;
}

/* str mvc_result_file_wrap(int *res_id, int *nr_cols, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, bat *order_bid); */
str 
mvc_result_file_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *order = NULL;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	res_table *t = NULL;
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len;
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	unsigned char **T = (unsigned char **)getArgReference(stk, pci, 2);
	unsigned char **R = (unsigned char **)getArgReference(stk, pci, 3);
	unsigned char **S = (unsigned char **)getArgReference(stk, pci, 4);
	unsigned char **N = (unsigned char **)getArgReference(stk, pci, 5);
	int mtype = getArgType(mb, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if (isaBatType(mtype)) {
		bat *order_bid = (bat *)getArgReference(stk, pci, 6);
		if ((order = BATdescriptor(*order_bid)) == NULL ) {
			throw(SQL, "sql.resultSet", "Cannot access descriptor");
		}
	}
	m->results = t = res_table_create(m->session->tr, m->result_id++, *nr_cols, Q_TABLE, m->results, order);
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	len = strlen((char*)(*S));
	GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); len = 0;
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	t->tsep = (char*)tsep;
	t->rsep = (char*)rsep;
	t->ssep = (char*)ssep;
	t->ns = (char*)ns;
	*res_id = t->id;
	if (*res_id < 0)
		res = createException(SQL, "sql.resultSet", "failed");
	if (order)
		BBPunfix(order->batCacheid);
	return res;
}

/* str mvc_result_table_wrap(int *res_id, int *nr_cols, int *qtype, bat *order_bid); */
str
mvc_result_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *order;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	int *qtype = (int *)getArgReference(stk, pci, 2);
	bat *order_bid = (bat *)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	if ((order = BATdescriptor(*order_bid)) == NULL ) {
		throw(SQL, "sql.resultSet", "Cannot access descriptor");
	}
	*res_id = mvc_result_table(m, *nr_cols, *qtype, order);
	if (*res_id < 0)
		res= createException(SQL, "sql.resultSet", "failed");
	BBPunfix(order->batCacheid);
	return res;
}

/* str mvc_result_column_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, bat *bid); */
str
mvc_result_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *b;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int *ret = (int *)getArgReference(stk, pci, 0);
	str *tn = (str *)getArgReference(stk, pci, 2);
	str *name = (str *)getArgReference(stk, pci, 3);
	str *type = (str *)getArgReference(stk, pci, 4);
	int *digits = (int *)getArgReference(stk, pci, 5);
	int *scale = (int *)getArgReference(stk, pci, 6);
	bat *bid = (bat *)getArgReference(stk, pci, 7);

	(void) cntxt;
	if (msg)
		return msg;
	if ((b = BATdescriptor(*bid)) == NULL)
		throw(SQL, "sql.rsColumn", "cannot access BAT descriptor");
	if (mvc_result_column(m, *tn, *name, *type, *digits, *scale, b)) 
		res = createException(SQL, "sql.rsColumn", "mvc_result_column failed");
	*ret = 0;
	BBPunfix(b->batCacheid);
	return res;
}

str
/*mvc_result_value_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, ptr p, int mtype)*/
mvc_result_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret  = (int *) getArgReference(stk, pci, 0);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	ptr p =  (ptr) getArgReference(stk, pci, 7);
	int mtype = getArgType(mb, pci, 7);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (mvc_result_value(m, *tn, *cn, *type, *digits, *scale, p, mtype))
		throw(SQL, "sql.rsColumn", "failed");
	*ret = 0;
	return MAL_SUCCEED;
}

/* str mvc_declared_table_wrap(int *res_id, str *name); */
str
mvc_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	int *res_id = (int *) getArgReference(stk, pci, 0);
	str *name = (str *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.declared_table","3F000!Schema missing");
	(void)mvc_create_table(m, s, *name, tt_table, TRUE, SQL_DECLARED_TABLE, CA_DROP, 0);
	*res_id = 0;
	return MAL_SUCCEED;
}

/* str mvc_declared_table_column_wrap(int *ret, int *rs, str *tname, str *name, str *type, int *digits, int *scale); */
str 
mvc_declared_table_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_subtype tpe;
	int *ret  = (int *) getArgReference(stk, pci, 0);
	int *rs = (int *) getArgReference(stk, pci, 1);
	str *tname = (str *) getArgReference(stk, pci, 2);
	str *name = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if (*rs != 0)
		throw(SQL, "sql.dtColumn", "Cannot access declared table");
	if (!sql_find_subtype(&tpe, *type, *digits, *scale))
		throw(SQL, "sql.dtColumn", "Cannot find column type");
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.declared_table_column","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( t == NULL)
		throw(SQL,"sql.declared_table_column","42S02!Table missing");
	(void)mvc_create_column(m, t, *name, &tpe); 
	*ret = 0;
	return MAL_SUCCEED;
}

str
mvc_drop_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci )
{
	mvc *m = NULL;
	str *name = (str *) getArgReference(stk, pci, 1);
	str msg = getSQLContext(cntxt, mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.drop","3F000!Schema missing");
	t = mvc_bind_table(m, s, *name);
	if ( t == NULL)
		throw(SQL,"sql.drop","42S02!Table missing");
	(void)mvc_drop_table(m, s, t, 0);
	return MAL_SUCCEED;
}

str
mvc_drop_declared_tables_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci )
{
	mvc *m = NULL;
	int i = *(int *) getArgReference(stk, pci, 1);
	str msg = getSQLContext(cntxt, mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.drop","3F000!Schema missing");
	while(i && s->tables.set->t) {
		t = s->tables.set->t->data;
		(void)mvc_drop_table(m, s, t, 0);
		i--;
	}
	return MAL_SUCCEED;
}

/* str mvc_affected_rows_wrap(int *m, int m, wrd *nr, str *w); */
str
mvc_affected_rows_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt, mb, &m, &b);
	int *res = (int*)getArgReference(stk, pci, 0);
#ifndef NDEBUG
	int mtype = getArgType(mb, pci, 2);
#endif
	wrd nr;
	str *w = (str *) getArgReference(stk, pci, 3);

	if (msg)
		return msg;
	*res = 0;
	assert (mtype == TYPE_wrd);
	nr = *(wrd *) getArgReference(stk, pci, 2);
	if (mvc_export_affrows(m, b->out, nr, *w)) 
		throw(SQL, "sql.affectedRows", "failed");
	return MAL_SUCCEED;
}

/* str mvc_export_head_wrap(int *ret, stream **s, int *res_id); */
str
mvc_export_head_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getSQLContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_head(c, *s, *res_id, FALSE)) {
		throw(SQL, "sql.exportHead", "failed");
	}
	(void)ret;
	return NULL;
}
/* str mvc_export_result_wrap(int *ret, stream **s, int *res_id); */
str
mvc_export_result_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getSQLContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_result(c, *s, *res_id)) {
		throw(SQL, "sql.exportResult", "failed");
	}
	(void)ret;
	return NULL;
}
/* str mvc_export_chunk_wrap(int *ret, stream **s, int *res_id, str *w); */
str
mvc_export_chunk_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getSQLContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);
	BUN	offset = 0;
	BUN	nr = 0;

	if ( pci->argc == 5){
		offset = *(BUN *) getArgReference(stk,pci,3);
		nr = *(BUN *) getArgReference(stk,pci,4);
	} 

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_chunk(c, *s, *res_id, offset, nr)) {
		throw(SQL, "sql.exportChunk", "failed");
	}
	(void)ret;
	return NULL;
}

/* str mvc_export_operation_wrap(int *ret, str *w); */
str
mvc_export_operation_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getSQLContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	str *w = (str *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_operation(c, b->out, *w)) {
		throw(SQL, "sql.exportOperation", "failed");
	}
	(void)ret;
	return NULL;
}


str
/*mvc_export_value_wrap(int *ret, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype)*/
mvc_export_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *qtype= (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	int *eclass = (int *) getArgReference(stk, pci, 7);
	ptr p =  (ptr) getArgReference(stk, pci, 8);
	int mtype = getArgType(mb, pci, 8);
	str *w = (str *) getArgReference(stk, pci, 9);
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getSQLContext(cntxt,mb, &c, &b);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (b->out == NULL ||
		mvc_export_value(c, b->out, *qtype, *tn, *cn, *type, *digits, *scale, *eclass, p, mtype, *w, "NULL") != SQL_OK)
		throw(SQL, "sql.exportValue", "failed");
	return MAL_SUCCEED;
}

static void
bat2return(MalStkPtr stk, InstrPtr pci, BAT **b)
{
	int i;

	for(i = 0; i<pci->retc; i++) {
		*(int*)getArgReference(stk, pci, i) = b[i]->batCacheid;
		BBPkeepref(b[i]->batCacheid);
	}
}

/* str mvc_import_table_wrap(int *res, str *sname, str *tname, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, str *fname, lng *sz, lng *offset); */
str
mvc_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT **b = NULL;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len = 0;
	str filename, cs;
	str *sname = (str *) getArgReference(stk, pci, pci->retc+0);
	str *tname = (str *) getArgReference(stk, pci, pci->retc+1);
	unsigned char **T = (unsigned char **) getArgReference(stk, pci, pci->retc+2);
	unsigned char **R = (unsigned char **) getArgReference(stk, pci, pci->retc+3);
	unsigned char **S = (unsigned char **) getArgReference(stk, pci, pci->retc+4);
	unsigned char **N = (unsigned char **) getArgReference(stk, pci, pci->retc+5);
	str *fname = (str *) getArgReference(stk, pci, pci->retc+6);
	lng *sz = (lng *) getArgReference(stk, pci, pci->retc+7);
	lng *offset = (lng *) getArgReference(stk, pci, pci->retc+8);
	int *locked = (int *) getArgReference(stk, pci, pci->retc+9);
	bstream *s;
	stream *ss;

	if (msg)
		return msg;
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	if (*S && strcmp(str_nil,*(char**)S)) {
		len = strlen((char*)(*S));
		GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); 
		len = 0;
	}

	codeset(&cs);
	strIconv(&filename, *fname, "UTF-8", cs);
	GDKfree(cs);
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	ss = open_rastream(filename);
	if (!ss || mnstr_errnr(ss)){
		int errnr = mnstr_errnr(ss);
		if (ss)
			mnstr_destroy(ss);
		throw(IO, "streams.open", "could not open file '%s': %s",
				filename, strerror(errnr));
	}
	s = bstream_create(ss, 33554432);
	if (!s)
		throw(IO, "bstreams.create", "failed to create block stream");
	b = mvc_import_table(cntxt, m, s, *sname, *tname, (char*)tsep, (char*)rsep, (char*)ssep, (char*)ns, *sz, *offset, *locked);
	bstream_destroy(s);
	GDKfree(filename);
	GDKfree(tsep);
	GDKfree(rsep);
	if(ssep)
		GDKfree(ssep);
	GDKfree(ns);
	if (!b)
		throw(SQL, "importTable", "%sfailed to import table", m->errstr);
	bat2return(stk, pci, b);
	GDKfree(b);
	return MAL_SUCCEED;
}

/* str mvc_import_table_stdin(int *res, str *sname, str *tname, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, lng *sz, lng *offset); */
str
mvc_import_table_stdin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT **b = NULL;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len = 0;
	str *sname = (str *) getArgReference(stk, pci, pci->retc+0);
	str *tname = (str *) getArgReference(stk, pci, pci->retc+1);
	unsigned char **T = (unsigned char **) getArgReference(stk, pci, pci->retc+2);
	unsigned char **R = (unsigned char **) getArgReference(stk, pci, pci->retc+3);
	unsigned char **S = (unsigned char **) getArgReference(stk, pci, pci->retc+4);
	unsigned char **N = (unsigned char **) getArgReference(stk, pci, pci->retc+5);
	lng *sz = (lng *) getArgReference(stk, pci, pci->retc+6);
	lng *offset = (lng *) getArgReference(stk, pci, pci->retc+7);
	int *locked = (int *) getArgReference(stk, pci, pci->retc+8);

	if (msg)
		return msg;
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	if (*S && strcmp(str_nil,*(char**)S)) {
		len = strlen((char*)(*S));
		GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); 
		len = 0;
	}
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	b = mvc_import_table(cntxt, m, m->scanner.rs, *sname, *tname, (char*)tsep, (char*)rsep, (char*)ssep, (char*)ns, *sz, *offset, *locked);
	GDKfree(tsep);
	GDKfree(rsep);
	if(ssep)
		GDKfree(ssep);
	GDKfree(ns);
	if (!b)
		throw(SQL, "importTable", "%sfailed to import table", m->errstr);
	bat2return(stk, pci, b);
	GDKfree(b);
	return MAL_SUCCEED;
}

/* str mvc_bin_import_table_wrap(.., str *sname, str *tname, str *fname..);
 * binary attachment only works for simple binary types. 
 * Non-simple types require each line to contain a valid ascii representation
 * of the text terminate by a new-line. These strings are passed to the corresponding
 * atom conversion routines to fill the column.
*/
str
mvc_bin_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt, mb, &m, NULL);
	BUN cnt = 0;
	int i;
	str sname = *(str *) getArgReference(stk, pci, 0 + pci->retc);
	str tname = *(str *) getArgReference(stk, pci, 1 + pci->retc);
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t;
	node *n;
	FILE *f;
	char *buf;
	int bufsiz= 128 * BLOCK;

	if (msg)
		return msg;

	if ( s == NULL)
		throw(SQL,"sql.drop","3F000!Schema missing");
	t = mvc_bind_table(m, s, tname);
	if (!t) 
		throw(SQL,"sql", "42S02!table %s not found", tname);
	if (list_length(t->columns.set) != (pci->argc-(2+pci->retc)))
		throw(SQL,"sql", "Not enough columns in found");

	for (i = pci->retc + 2, n = t->columns.set->h; i<pci->argc && n; i++, n = n->next) {
		sql_column *col = n->data;

		if (ATOMvarsized(col->type.type->localtype ) && col->type.type->localtype != TYPE_str) 
			throw(SQL, "sql", "failed to attach file %s",
			      *(str*)getArgReference(stk, pci, i));
		f = fopen( *(str*) getArgReference(stk,pci,i),"r");
		if ( f == NULL)
			throw(SQL, "sql", "failed to open file %s", *(str*)getArgReference(stk, pci, i));
		fclose(f);
	}

	for (i = pci->retc + 2, n = t->columns.set->h; i<pci->argc && n; i++, n = n->next) {
		sql_column *col = n->data;
		BAT *c= NULL;
		int tpe = col->type.type->localtype;

		/* handle the various cases */
		if (tpe < TYPE_str || tpe == TYPE_date ||
		    tpe == TYPE_daytime || tpe == TYPE_timestamp) {
			c = BATattach(col->type.type->localtype, *(str*)getArgReference(stk, pci, i));
			if (c == NULL) 
				throw(SQL, "sql", "failed to attach file %s", *(str*)getArgReference(stk, pci, i));
			BATsetaccess(c, BAT_READ);
			BATderiveProps(c, 1);
		} else if (tpe == TYPE_str) {
			/* get the BAT and fill it with the strings */
			c = BATnew(TYPE_void,TYPE_str,0); 
			BATseqbase(c,0);
			/* this code should be extended to deal with larger text strings. */
			f = fopen( *(str*) getArgReference(stk,pci,i),"r");
			if ( f == NULL)
				throw(SQL, "sql", "failed to re-open file %s", *(str*)getArgReference(stk, pci, i));

			buf = GDKmalloc(bufsiz);
			while ( fgets(buf, bufsiz,f) != NULL) {
				char *t = strrchr(buf,'\n');
				if ( t) *t = 0;
				BUNappend(c,buf, FALSE);
			}
			fclose(f);
			GDKfree(buf);
		} else {
			throw(SQL, "sql", "failed to attach file %s", *(str*)getArgReference(stk, pci, i));
		}
		if (i!=(pci->retc + 2) && cnt != BATcount(c)) 
			throw(SQL, "sql", "table %s not found", tname);
		cnt = BATcount(c);
		*(int*)getArgReference(stk, pci, i-(2+pci->retc)) = c->batCacheid;
		BBPkeepref(c->batCacheid);
	}
	return MAL_SUCCEED;
}


str
zero_or_one(ptr ret, int *bid) 
{
	BAT *b;
	BUN c, _s;
	ptr p;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "zero_or_one", "Cannot access descriptor");
	}
	c = BATcount(b);
	if (c == 0) {
		p = ATOMnilptr(b->ttype);
	} else if (c == 1) {
		BATiter bi = bat_iterator(b);
		p = BUNtail(bi,BUNfirst(b));
	} else {
		char buf[BUFSIZ];

		p = NULL;
		snprintf(buf, BUFSIZ, "21000!cardinality violation (" BUNFMT ">1)", c);
		throw(SQL, "zero_or_one", "%s", buf);
	}
	_s = ATOMsize(ATOMtype(b->ttype));
	if (ATOMextern(b->ttype)) {
		_s = ATOMlen(ATOMtype(b->ttype), p);
		memcpy(*(ptr*) ret=GDKmalloc(_s), p, _s);
	} else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*)p;
		*(BAT**) ret = BATdescriptor(bid);
	} else if (_s == 4) {
		*(int*) ret = *(int*)p;
	} else if (_s == 1) {
		*(bte*) ret = *(bte*)p;
	} else if (_s == 2) {
		*(sht*) ret = *(sht*)p;
	} else if (_s == 8) {
		*(lng*) ret = *(lng*)p;
	} else {
		memcpy(ret, p, _s);
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str not_unique(bit *ret, int* bid) 
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_unique", "Cannot access descriptor");
	}

	*ret = FALSE;
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	} else if (b->tsorted) {
		BUN p,q;
		oid c = *(oid*)Tloc(b, BUNfirst(b)); 

		for(p=BUNfirst(b)+1, q=BUNlast(b);p<q;p++) {
			oid v = *(oid*)Tloc(b,p);
			if (v<=c) {
				*ret = TRUE;
				break;
			}
			c = v;
		}
	} else {
		BBPunfix(b->batCacheid);
		throw(SQL, "not_unique", "input should be sorted");
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

/* later we could optimize this to start from current BUN 
   And only search the from the first if second is not found.
 */
static inline int 
HASHfndTwice(BAT *b, ptr v)
{
	BATiter bi = bat_iterator(b);
	BUN i = BUN_NONE;
	int first = 1;
	
	HASHloop( bi, b->H->hash, i, v) {
		if (!first)
			return 1;
		first = 0;
	}
	return 0;
}

str 
not_unique_oids(bat *ret, bat* bid) 
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_uniques", "Cannot access descriptor");
	}
	if (b->ttype != TYPE_oid && b->ttype != TYPE_wrd) {
		throw(SQL, "not_uniques", "Wrong types");
	}

	assert(b->htype == TYPE_oid);
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		bn = BATnew(TYPE_oid, TYPE_oid, 0);
		if( bn == NULL) {
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.not_uniques", MAL_MALLOC_FAIL);
		}
	} else if (b->tsorted) { /* ugh handle both wrd and oid types */
		oid c = *(oid*)Tloc(b, BUNfirst(b)), *rf, *rh, *rt;
		oid *h = (oid*)Hloc(b,0), *vp, *ve;
		int first = 1;

		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		if( bn == NULL){
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.not_uniques", MAL_MALLOC_FAIL);
		}
		vp = (oid*)Tloc(b, BUNfirst(b));
		ve = vp + BATcount(b);
		rf = rh = (oid*)Hloc(bn, BUNfirst(bn));
		rt = (oid*)Tloc(bn, BUNfirst(bn));
		*rh++ = *h++; 
		*rt++ = *vp; 
		for(vp++; vp < ve; vp++, h++) {
			oid v = *vp;
			if (v == c) {
				first = 0;
				*rh++ = *h;
				*rt++ = v;
			} else if (!first) {
				first = 1;
				*rh++ = *h;
				*rt++ = v;
			} else {
				*rh = *h;
				*rt = v;
			}
			c = v;
		}
		if (first)
			rh--;
		BATsetcount(bn, (BUN)(rh - rf)); 
	} else {
		oid *rf, *rh, *rt;
		oid *h = (oid*)Hloc(b,0), *vp, *ve;
		BAT *bm = BATmirror(b);

		if (BATprepareHash(bm))
			throw(SQL, "not_uniques", "hash creation failed");
		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		if( bn == NULL){
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.unique_oids", MAL_MALLOC_FAIL);
		}
		vp = (oid*)Tloc(b, BUNfirst(b));
		ve = vp + BATcount(b);
		rf = rh = (oid*)Hloc(bn, BUNfirst(bn));
		rt = (oid*)Tloc(bn, BUNfirst(bn));
		for(; vp < ve; vp++, h++) {
			/* try to find value twice */
			if (HASHfndTwice(bm, vp)) {
				*rh++ = *h;
				*rt++ = *vp;
			}
		}
		BATsetcount(bn, (BUN)(rh - rf)); 
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(1),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

/*
 * @-
 * The core modules of Monet provide just a limited set of
 * mathematical operators. The extensions required to support
 * SQL-99 are shown below. At some point they also should be
 * moved to module code base.
 */
@= round
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return NULL;
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}

str 
@1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (-*r > *d) {
		*res = 0;
	} else if (*r > 0 && *r < *s) {
		int dff = *s - *r;
		lng rnd = scales[dff]>>1;
		lng lres;
		if (*v > 0)
			lres = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			lres = (((*v - rnd)/scales[dff])*scales[dff]);
		assert((lng) GDK_@1_min < lres && lres <= (lng) GDK_@1_max);
		*res = (@1) lres;
	} else if (*r <= 0 && -*r + *s > 0) {
		int dff = -*r + *s;
		lng rnd = scales[dff]>>1;
		lng lres;
		if (*v > 0)
			lres = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			lres = (((*v - rnd)/scales[dff])*scales[dff]);
		assert((lng) GDK_@1_min < lres && lres <= (lng) GDK_@1_max);
		*res = (@1) lres;
	} else {
		*res = *v;
	}
	return MAL_SUCCEED;
}

str
nil_2dec_@1( @1 *res, void *val, int *d, int *sc )
{
	(void)val;
	(void)d;
	(void)sc;

	*res = @1_nil;
	return MAL_SUCCEED;
}

str
str_2dec_@1( @1 *res, str *val, int *d, int *sc )
{
	char *s = strip_extra_zeros(*val);
	char *dot = strchr(s, '.');
	int digits = _strlen(s) - 1;
	int scale = digits - (int) (dot-s);
	lng value = 0;

	if (!dot) {
		if (GDK_STRNIL(*val)) {
			*res = @1_nil;
			return MAL_SUCCEED;
		} else {
			throw(SQL, "@1", 
				"\"%s\" is no decimal value (doesn't contain a '.')", *val);
		}
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */

		value *= scales[d];
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		lng rnd = scales[d]>>1;

		value += rnd;
		value /= scales[d];
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		throw(SQL,"@1", 
		     "decimal (%s) doesn't have format (%d.%d)", *val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}

str
nil_2num_@1( @1 *res, void *v, int *len )
{
	int zero = 0;
	return nil_2dec_@1( res, v, len, &zero );
}

str
str_2num_@1( @1 *res, str *v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}

str
batnil_2dec_@1( int *res, int *bid, int *d, int *sc )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;

	(void)d;
	(void)sc;
	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.nil_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@1 r = @1_nil;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
batstr_2dec_@1( int *res, int *bid, int *d, int *sc )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2dec_@1( &r, &v, d, sc );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str
batnil_2num_@1( int *res, int *bid, int *len )
{
	int zero = 0;
	return batnil_2dec_@1( res, bid, len, &zero );
}

str
batstr_2num_@1( int *res, int *bid, int *len )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2num_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2num_@1( &r, &v, len );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str 
@1_dec2second_interval( lng *res, int *sc, @1 *dec, int *ek, int *sk )
{
	lng value = *dec;

	(void)ek;
	(void)sk;
	if (*sc < 3) {
		int d = 3 - *sc;
		value *= scales[d];
	} else if (*sc > 3 ) {
		int d = *sc - 3;
		lng rnd = scales[d]>>1;

		value += rnd;
		value /= scales[d];
	}
	*res = value;
	return MAL_SUCCEED;
}

@
@c

@:round(bte)@
@:round(sht)@
@:round(int)@
@:round(wrd)@
@:round(lng)@

str
daytime_2time_daytime( daytime *res, daytime *v, int *digits )
{
	int d = (*digits)?*digits-1:0;

	/* correct fraction */
	*res = *v;
	if (!daytime_isnil(*v) && d < 3) {
		*res = (daytime) (*res / scales[3-d]);
		*res = (daytime) (*res * scales[3-d]);
	}
	return MAL_SUCCEED;
}

str
second_interval_2_daytime( daytime *res, lng *s, int *digits )
{
	*res = (daytime)*s;
	return daytime_2time_daytime( res, res, digits);
}

str
nil_2time_daytime( daytime *res, void *v, int *digits )
{
	(void)digits;
	(void)v;
	*res = daytime_nil;
	return MAL_SUCCEED;
}

str
str_2time_daytime( daytime *res, str *v, int *digits )
{
	int len = sizeof(daytime), pos;

	if (!*v || strcmp(str_nil,*v) == 0) {
		*res = daytime_nil;
		return MAL_SUCCEED;
	}
	pos = daytime_fromstr(*v, &len, &res);
	if (!pos)
		throw(SQL,"daytime", "22007!daytime (%s) has incorrect format", *v);
	return daytime_2time_daytime( res, res, digits);
}

str
timestamp_2_daytime( daytime *res, timestamp *v, int *digits )
{
	int d = (*digits)?*digits-1:0;
	int msec = v->msecs;

	/* correct fraction */
	if (d < 3 && msec) {
		msec = (int) (msec / scales[3-d]);
		msec = (int) (msec * scales[3-d]);
	}
	*res = msec;
	return MAL_SUCCEED;
}

str
date_2_timestamp( timestamp *res, date *v, int *digits )
{
	(void)digits; /* no precision needed */
	res->days = *v;
	res->msecs = 0;
	return MAL_SUCCEED;
}

str
timestamp_2time_timestamp( timestamp *res, timestamp *v, int *digits )
{
	int d = (*digits)?*digits-1:0;

	*res = *v;
	/* correct fraction */
	if (d < 3) {
		int msec = res->msecs;
		if (msec) {
			msec = (int) (msec / scales[3-d]);
			msec = (int) (msec * scales[3-d]);
		}
		res->msecs = msec;
	}
	return MAL_SUCCEED;
}

str
nil_2time_timestamp( timestamp *res, void *v, int *digits )
{
	(void)digits;
	(void)v;
	*res = *timestamp_nil;
	return MAL_SUCCEED;
}

str
str_2time_timestamp( timestamp *res, str *v, int *digits )
{
	int len = sizeof(timestamp), pos;

	if (!*v || strcmp(str_nil,*v) == 0) {
		*res = *timestamp_nil;
		return MAL_SUCCEED;
	}
	pos = timestamp_fromstr(*v, &len, &res);
	if (!pos)
		throw(SQL,"timestamp", "22007!timestamp (%s) has incorrect format", *v);
	return timestamp_2time_timestamp( res, res, digits);
}

@= bat2time
str
bat@2_2time_@1( int *res, int *bid, int *digits )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2time_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@3 *v = (@3*)BUNtail(bi,p);
		union {
			lng l;
			@1 r;
		} u;
		msg = @2_2time_@1( &u.r, @4, digits );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &u.r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c
@:bat2time(timestamp,str,char,&v)@
@:bat2time(timestamp,timestamp,timestamp,v)@
@:bat2time(daytime,str,char,&v)@
@:bat2time(daytime,daytime,daytime,v)@

@= fround
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return MAL_SUCCEED;
}

str 
@1_round_wrap( @1 *res, @1 *v, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (*r < 0) {
		int d = -*r;
		@1 rnd = (@1) (scales[d]>>1); 

		if (*v > 0)
			*res = (@1) (floor(((*v + rnd)/((@1)(scales[d]))))*scales[d]);
		else
			*res = (@1) (floor(((*v + rnd)/((@1)(scales[d]))))*scales[d]);
	} else if (*r > 0) {
		int d = *r;

		if (*v > 0)
			*res = (@1) (floor(*v*(@1)scales[d]+.5)/scales[d]);
		else
			*res = (@1) (floor(*v*(@1)scales[d]+.5)/scales[d]);
	} else {
		*res = (@1) round(*v); 
	}
	return MAL_SUCCEED;
}
str
@1_trunc_wrap( @1 *res, @1 *v, int *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (*r < 0) {
		int d = -*r;
		*res = (@1) (trunc((*v)/((@1)scales[d])) * scales[d]); 
	} else if (*r > 0) {
		int d = *r;
		*res = (@1) (trunc(*v * (@1)scales[d]) / ((@1)scales[d]));
	} else {
		*res = (@1) trunc(*v);
	}
	return MAL_SUCCEED;
}

@
@c
@:fround(flt)@
@:fround(dbl)@

str
SQLdbl_alpha(dbl *res, dbl *decl, dbl *theta)
{
	dbl s, c1, c2;
    char *msg = MAL_SUCCEED;
    if (*decl == dbl_nil || *theta == dbl_nil) {
        *res = dbl_nil;
    } else if ( fabs(*decl) + *theta > 89.9 ) {
        *res = (dbl) 180.0;
    } else {
		s = sin(radians(*theta));
		c1 = cos(radians(*decl - *theta));
		c2 = cos(radians(*decl + *theta));
	    *res = degrees(fabs(atan(s / sqrt(fabs(c1 * c2)))));
		/*		mnstr_printf(GDKout,"%f\n", *res); */
	}
    return msg;
}
str
SQLbat_alpha(bat *res, bat *decl, dbl *theta)
{
    BAT *b, *bn;
    BATiter bi;
    BUN p,q;
	dbl s, c1, c2, r;
    char *msg = NULL;

	if ( *theta == dbl_nil ){
        throw(SQL, "SQLbat_alpha", "Parameter theta should not be nil");
    }
    if( (b = BATdescriptor(*decl)) == NULL ){
        throw(SQL, "alpha", "Cannot access descriptor");
    }
    bi = bat_iterator(b);
    bn = BATnew(b->htype, TYPE_dbl, BATcount(b));
    if( bn == NULL){
        BBPreleaseref(b->batCacheid);
        throw(SQL, "sql.alpha", MAL_MALLOC_FAIL);
    }
    BATseqbase(bn, b->hseqbase);
    s = sin(radians(*theta));
    BATloop(b,p,q) {
        dbl d = *(dbl*)BUNtail(bi,p);
	    if (d == dbl_nil)
			r = dbl_nil;
	    else if ( fabs(d) + *theta > 89.9 )
			r = (dbl) 180.0;
		else {
			c1 = cos(radians(d - *theta));
			c2 = cos(radians(d + *theta));
		    r = degrees(fabs(atan(s / sqrt(fabs(c1 * c2)))));
        }
        BUNins(bn, BUNhead(bi,p), &r, FALSE);
    }
    BBPkeepref( *res = bn->batCacheid);
    BBPunfix(b->batCacheid);
    return msg;
}

#if SIZEOF_WRD == SIZEOF_INT
#define wrdToStr(sptr, lptr, p) intToStr(sptr, lptr, (int*)p)
#else
#define wrdToStr(sptr, lptr, p) lngToStr(sptr, lptr, (lng*)p)
#endif

@= cast
str
nil_2_@1( @3 *res, void *val )
{
	(void)val;
	*res = @6;
	return MAL_SUCCEED;
}

str
str_2_@1( @3 *res, str *val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	char buf[BUFSIZ];
	
	e = ATOMfromstr(TYPE_@1, &p, &len, *val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, *val, ATOMnilptr(TYPE_str)) != 0))
	{
		if (p)
			GDKfree(p);
		snprintf(buf, BUFSIZ,"conversion of string '%s' failed",*val);
		throw(SQL, "@1", "%s", buf);
	}
	@4;
	if (!ATOMextern(TYPE_@1)) {
		if (p)
			GDKfree(p);
	}
	return MAL_SUCCEED;
}

str
SQL@1_2_str( str *res, @1 *val )
{
	char *p = NULL;
	int len = 0;
	@2( &p, &len, val);
	*res = p;
	return MAL_SUCCEED;
}

str
batnil_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.nil_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.2_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@3 r = @6;
		BUNins(dst, BUNhead(bi,p), @5 r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
batstr_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.2_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@3 r;
		msg = str_2_@1( &r, &v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), @5 r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@
@c
@:cast(timestamp,timestamp_tostr,timestamp, *res = *(timestamp*)p,&,*timestamp_nil)@
@:cast(daytime,daytime_tostr,daytime, *res = *(daytime*)p,&,daytime_nil)@
@:cast(date,date_tostr,date, *res = *(date*)p,&,date_nil)@
@:cast(sqlblob,sqlblob_tostr,sqlblob*, *res = (sqlblob*)p,,ATOMnilptr(TYPE_blob))@

static str
SQLstr_cast_(str *res, mvc *m, int eclass, int d, int s, int has_tz, ptr p, int tpe, int len)
{
	char *r = NULL;
	int sz = MAX(2,len + 1);	/* nil should fit */

	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, eclass, d, s, has_tz, p, tpe, &r, sz);
	} else {
		str v = (str)p; 
		strLength(&sz, v);
		if (len == 0 || (sz >= 0 && sz <= len)) 
			r = GDKstrdup(v);
	}
	if ((len > 0 && sz > len) || sz < 0) {
		if (r) 
			GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), p) != 0) {
			throw(SQL, "str_cast", "22001!value too long for type (var)char(%d)", len);
		} else {
			r = GDKstrdup(str_nil);
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

str
SQLstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *res  = (str *) getArgReference(stk, pci, 0);
	int eclass = *(int*) getArgReference(stk, pci, 1);
	int d = *(int*) getArgReference(stk, pci, 2);
	int s = *(int*) getArgReference(stk, pci, 3);
	int has_tz = *(int*) getArgReference(stk, pci, 4);
	ptr p   = (ptr) getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	int len   = *(int *) getArgReference(stk, pci, 6);
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(tpe)) 
		p = *(ptr*)p;
	return SQLstr_cast_(res, m, eclass, d, s, has_tz, p, tpe, len );
}

/* str SQLbatstr_cast(int *res, int *eclass, int *d1, int *s1, int *has_tz, int *bid, int *digits ); */
str 
SQLbatstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	char *r = NULL;
	int *res  = (int *) getArgReference(stk, pci, 0);
	int *eclass = (int*) getArgReference(stk, pci, 1);
	int *d1 = (int*) getArgReference(stk, pci, 2);
	int *s1 = (int*) getArgReference(stk, pci, 3);
	int *has_tz = (int*) getArgReference(stk, pci, 4);
	int *bid   = (int*) getArgReference(stk, pci, 5);
	int *digits   = (int *) getArgReference(stk, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_str, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.str_cast", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		ptr v = (ptr)BUNtail(bi,p);
		msg = SQLstr_cast_( &r, m, *eclass, *d1, *s1, *has_tz, v, b->ttype, *digits);
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), r, FALSE);
		GDKfree(r);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@= simpleupcast
str 
@2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return(MAL_SUCCEED);
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@2_2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	bn->hrevsorted = b->hrevsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	if ( b->T->nonil) {
		for (; p<q; p++, o++)
			*o = (@1)*p;
	} else {
		for (; p<q; p++, o++)
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else
				*o = (@1)*p;
	}
	BATsetcount(bn, BATcount(b));
	bn->hrevsorted = bn->batCount <= 1;
	bn->tsorted = 0;
	bn->trevsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@
@c

@= simpledowncast
str @2_2_@1( @1 *res, @2 *v )
{
	@3 val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if ((@3)(@1)val > (@3) GDK_@1_min && 
	    val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
		*res = (@1)val;
		return(MAL_SUCCEED);
	} else {
		throw(SQL, "convert",
			"22003!value (" @4 ") exceeds limits of type @1", val);
	}
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	@1 *o;
	@3 val;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@2_2_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(bn, b->hseqbase);
	bn->H->nonil = 1;
	bn->T->nonil = 1;
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	if ( b->T->nonil){
		for (; p<q; p++, o++){
			val = *p;
			/* see if the number fits in the data type */
			if ((@3)(@1)val > (@3) GDK_@1_min && val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
				*o = (@1)val;
			} else {
				msg= createException(SQL, "convert", "22003!value (" @4 ") exceeds limits of type @1", val);
				break;
			}
		}
	} else {
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else {
				val = *p;
				/* see if the number fits in the data type */
				if ((@3)(@1)val > (@3) GDK_@1_min && val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
					*o = (@1)val;
				} else {
					msg= createException(SQL, "convert", "22003!value (" @4 ") exceeds limits of type @1", val);
					break;
				}
			}
		}
	}
	BATsetcount(bn, BATcount(b));
	bn->hrevsorted = bn->batCount <= 1;
	bn->tsorted = 0;
	bn->trevsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}
@
 * @-
 * The simple cast up operations in some cases
 * could re-use the storage space as well.
@= numcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (@1) ((r + h) / scales[scale]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"22003!too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= (@1) scales[s2 - s1];
	else if (s2 != s1) 
		r = (@1) ((r + h) / scales[s1 - s2]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	bn->hrevsorted = b->hrevsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	if ( b->T->nonil){
		if (scale)
			for (; p<q; p++, o++)
				*o = (@1) ((*p +  ((*p<0)?-5:5)) / scales[scale]);
		else
			for (; p<q; p++, o++)
				*o = (@1) (*p);
	} else {
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else if (scale) {
				*o = (@1) ((*p +  ((*p<0)?-5:5)) / scales[scale]);
			} else {
				*o = (@1) (*p);
			}
		}
	}
	BATsetcount(bn, BATcount(b));
	bn->hrevsorted = bn->batCount <= 1;
	bn->tsorted = 0;
	bn->trevsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@
@c
@:numcastup(bte,bte)@
@:numcastup(sht,bte)@
@:numcastup(sht,sht)@
@:numcastup(int,bte)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(wrd,bte)@
@:numcastup(wrd,sht)@
@:numcastup(wrd,int)@
@:numcastup(wrd,wrd)@
@:numcastup(lng,bte)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,wrd)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2,dbl,"%f")@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@2) *v;
	if (scale) 
		r *= scales[scale];
	cpyval = (lng) r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		throw(SQL, "convert",
			"22003!too many digits (%d > %d)", inlen, p);
	}
	*res = (@1) r;
	return MAL_SUCCEED;
}
str 
bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@
@c
@:fnumcastdown(bte,flt)@
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(wrd,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(bte,dbl)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(wrd,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"22003!too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	bn->hrevsorted = b->hrevsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	if ( b->T->nonil){
		for (; p<q; p++, o++) 
			*o = (((@1)*p)/scales[scale]);
	} else {
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else 
				*o = (((@1)*p)/scales[scale]);
		}
	}
	BATsetcount(bn, BATcount(b));
	bn->hrevsorted = bn->batCount <= 1;
	bn->tsorted = 0;
	bn->trevsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@
@c
@:fnumcastup(flt,bte)@
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,wrd)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,bte)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,wrd)@
@:fnumcastup(dbl,lng)@

@= numcastdown
@:simpledowncast(@1,@2,lng,LLFMT)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val > GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"22003!value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "@2_2_@1",
			"22003!too many digits (%d > %d)", inlen, p);
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val > GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"22003!value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;
	@2 val;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec@2_2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	bn->hrevsorted = b->hrevsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	if ( b->T->nonil){
		for (; p<q; p++, o++) {
			if (scale) 
				val = (@2) ((*p+ ((*p<0)?-5:5))/scales[scale]);
			else
				val = (@2) (*p);
			/* see if the number fits in the data type */
			if (val > GDK_@1_min && val <= GDK_@1_max)
				*o = (@1)val;
			else {
				BBPreleaseref(b->batCacheid);
				BBPreleaseref(bn->batCacheid);
				throw(SQL, "convert", "22003!value (" LLFMT ") exceeds limits of type @1", (lng) val);
			}
		}
	} else{
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else {
				if (scale)
					val = (@2) (( *p + (( *p<0)?-5:5))/scales[scale]);
				else
					val = (@2) (*p);
				/* see if the number fits in the data type */
				if (val > GDK_@1_min && val <= GDK_@1_max)
					*o = (@1)val;
				else {
					BBPreleaseref(b->batCacheid);
					BBPreleaseref(bn->batCacheid);
					throw(SQL, "convert", "22003!value (" LLFMT ") exceeds limits of type @1", (lng) val);
				}
			}
		}
	}
	BATsetcount(bn, BATcount(b));
	bn->hrevsorted = bn->batCount <= 1;
	bn->tsorted = 0;
	bn->trevsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@
@c
@:numcastdown(bte,sht)@
@:numcastdown(bte,int)@
@:numcastdown(bte,wrd)@
@:numcastdown(bte,lng)@
@:numcastdown(sht,int)@
@:numcastdown(sht,wrd)@
@:numcastdown(sht,lng)@
@:numcastdown(int,wrd)@
@:numcastdown(int,lng)@
@:numcastdown(wrd,lng)@

str 
month_interval_str( int *ret, str *s, int *d, int *sk )
{
	lng res;

	if (interval_from_str( *s, *d, *sk, &res ) < 0)
		throw(SQL, "calc.month_interval",
			"wrong format (%s)", *s);
	assert((lng) GDK_int_min <= res && res <= (lng) GDK_int_max);
	*ret = (int) res;
	return MAL_SUCCEED;
}

str 
second_interval_str( lng *res, str *s, int *d, int *sk )
{
	if (interval_from_str( *s, *d, *sk, res ) < 0)
		throw(SQL, "calc.second_interval",
			"wrong format (%s)", *s);
	return MAL_SUCCEED;
}

str
month_interval(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int *) getArgReference(stk, pci, 0);
	int k = digits2ek(* (int *) getArgReference(stk, pci, 2));
	int r;

	(void) cntxt;
	(void) mb;
	switch (getArgType(mb, pci, 1)) {
	case TYPE_bte:
		r = stk->stk[getArg(pci, 1)].val.btval;
		break;
	case TYPE_sht:
		r = stk->stk[getArg(pci, 1)].val.shval;
		break;
	case TYPE_int:
		r = stk->stk[getArg(pci, 1)].val.ival;
		break;
	case TYPE_wrd:
		r = (int) stk->stk[getArg(pci, 1)].val.wval;
		break;
	case TYPE_lng:
		r = (int) stk->stk[getArg(pci, 1)].val.lval;
		break;
	default:
		throw(ILLARG, "calc.month_interval","illegal argument");
	}
	switch (k) {
	case iyear:
		r *= 12;
		break;
	case imonth:
		break;
	default:
		throw(ILLARG, "calc.month_interval","illegal argument");
	}
	*ret = r;
	return MAL_SUCCEED;
}

str
second_interval(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	lng *ret = (lng *) getArgReference(stk, pci, 0);
	int k = digits2ek(* (int *) getArgReference(stk, pci, 2));
	lng r;

	(void) cntxt;
	(void) mb;
	switch (getArgType(mb, pci, 1)) {
	case TYPE_bte:
		r = stk->stk[getArg(pci, 1)].val.btval;
		break;
	case TYPE_sht:
		r = stk->stk[getArg(pci, 1)].val.shval;
		break;
	case TYPE_int:
		r = stk->stk[getArg(pci, 1)].val.ival;
		break;
	case TYPE_wrd:
		r = stk->stk[getArg(pci, 1)].val.wval;
		break;
	case TYPE_lng:
		r = stk->stk[getArg(pci, 1)].val.lval;
		break;
	default:
		throw(ILLARG, "calc.sec_interval", "illegal argument");
	}
	switch (k) {
	case iday:
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		r *= 1000;
		break;
	default:
		throw(ILLARG, "calc.sec_interval", "illegal argument");
	}
	*ret = r;
	return MAL_SUCCEED;
}

@mal
command calc.second_interval( v:daytime, ek:int, sk:int ) :lng
address second_interval_daytime
comment "cast daytime to a second_interval and check for overflow";

command calc.daytime( v:lng, d:int) :daytime
address second_interval_2_daytime
comment "cast second_interval to a daytime and check for overflow";

command calc.daytime( v:timestamp, d:int) :daytime
address timestamp_2_daytime
comment "cast timestamp to a daytime and check for overflow";

command calc.timestamp( v:date, d:int) :timestamp
address date_2_timestamp
comment "cast date to a timestamp and check for overflow";
@h
sql5_export str second_interval_daytime( lng *res, daytime *s, int *ek, int *sk );
sql5_export str second_interval_2_daytime( daytime *res, lng *s, int *d);
sql5_export str timestamp_2_daytime( daytime *res, timestamp *v, int *d);
sql5_export str date_2_timestamp( timestamp *res, date *v, int *d);
@c
str
second_interval_daytime( lng *res, daytime *s, int *d, int *sk )
{
	int k = digits2sk(*d);
	lng r = *(int*)s;

	(void)sk;
	if (daytime_isnil(*s)) {
		*res = lng_nil;
		return MAL_SUCCEED;
	}
	switch(k) {
	case isec:
		break;
	case imin:
		r /= 60000;
		r *= 60000;
		break;
	case ihour:
		r /= 3600000;
		r *= 3600000;
		break;
	case iday: 	
		r /= (24*3600000);
		r *= (24*3600000);
		break;
	default:
		throw(ILLARG, "calc.second_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}

/* str dump_cache(int *r); */
str
dump_cache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int cnt; 
	cq *q = NULL;
	BAT *query, *count;
	int *rquery = (int *) getArgReference(stk, pci, 0);
	int *rcount = (int *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	cnt = m->qc->id; 
	query = BATnew(TYPE_void, TYPE_str, cnt);
	if( query == NULL)
		throw(SQL, "sql.dumpcache", MAL_MALLOC_FAIL);
	BATseqbase(query, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	if( count == NULL){
		BBPreleaseref(query->batCacheid);
		throw(SQL, "sql.dumpcache", MAL_MALLOC_FAIL);
	}
	BATseqbase(count, 0);

	for(q = m->qc->q; q; q = q->next) {
		if (q->type != Q_PREPARE) {
			BUNappend(query, q->codestring, FALSE);
			BUNappend(count, &q->count, FALSE);
		}
	}
	*rquery = query->batCacheid;
	*rcount = count->batCacheid;
	BBPkeepref(*rquery);
	BBPkeepref(*rcount);
	return MAL_SUCCEED;
}

/* str dump_opt_stats(int *r); */
str
dump_opt_stats(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int cnt; 
	BAT *rewrite, *count;
	int *rrewrite = (int *) getArgReference(stk, pci, 0);
	int *rcount = (int *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	cnt = m->qc->id; 
	rewrite = BATnew(TYPE_void, TYPE_str, cnt);
	if( rewrite == NULL)
		throw(SQL, "sql.optstats", MAL_MALLOC_FAIL);
	BATseqbase(rewrite, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	if( count == NULL)
		throw(SQL, "sql.optstats", MAL_MALLOC_FAIL);
	BATseqbase(count, 0);

	BUNappend(rewrite, "joinidx", FALSE);
	BUNappend(count, &m->opt_stats[0], FALSE);
	/* TODO add other rewrites */

	*rrewrite = rewrite->batCacheid;
	*rcount = count->batCacheid;
	BBPkeepref(*rrewrite);
	BBPkeepref(*rcount);
	return MAL_SUCCEED;
}

/* str dump_opt_stats(int *r); */
str
dump_trace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	BAT *t[12];

	(void)cntxt; (void)mb;
	TRACEtable(t);
	for (i = 0; i < 12; i++) {
		int id = t[i]->batCacheid;

		*(int *) getArgReference(stk, pci, i) = id;
		BBPkeepref(id);
	}
	return MAL_SUCCEED;
}

str
sql_querylog_catalog(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	BAT *t[7];

	(void)cntxt; (void)mb;
	QLOGcatalog(t);
	for (i = 0; i < 7; i++) {
		int id = t[i]->batCacheid;

		*(int *) getArgReference(stk, pci, i) = id;
		BBPkeepref(id);
	}
	return MAL_SUCCEED;
}

str
sql_querylog_calls(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	BAT *t[10];

	(void)cntxt; (void)mb;
	QLOGcalls(t);
	for (i = 0; i < 10; i++) {
		int id = t[i]->batCacheid;

		*(int *) getArgReference(stk, pci, i) = id;
		BBPkeepref(id);
	}
	return MAL_SUCCEED;
}
str
sql_querylog_empty(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret= (int*) getArgReference(stk,pci,0);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	QLOGempty(ret);
	return MAL_SUCCEED;
}


/* str sql_rowid(oid *rid, ptr v, str *sname, str *tname); */
str 
sql_rowid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_column *c = NULL;
	sql_delta *d;
	oid *rid = (oid *) getArgReference(stk, pci, 0);
	str *sname = (str *) getArgReference(stk, pci, 2);
	str *tname = (str *) getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	if ( s == NULL)
		throw(SQL,"sql.rowid","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( s == NULL)
		throw(SQL,"sql.rowid","42S02!Table missing");
	if (!s || !t || !t->columns.set->h)
		throw(SQL, "calc.rowid", "42S22!Cannot find column");
	c = t->columns.set->h->data;
	/* HACK, get insert bat */
	b = store_funcs.bind_col(m->session->tr, c, RD_INS);
	/* UGH (move into storage backends!!) */
	d = c->data;
	*rid = d->ibase + BATcount(b);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

static str
do_sql_rank_grp(bat *rid, bat *bid, bat *gid, int nrank, int dense, const char *name)
{
	BAT *r, *b, *g;
	BUN p, q;
	BATiter bi, gi;
	int (*ocmp)(const void *, const void *);
	int (*gcmp)(const void *, const void *);
	const void *oc, *gc, *on, *gn;
	int rank = 1;
	int c;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, name, "Cannot access descriptor");
	if( (g = BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(SQL, name, "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	gi = bat_iterator(g);
	ocmp = BATatoms[b->ttype].atomCmp;
	gcmp = BATatoms[g->ttype].atomCmp;
	oc = BUNtail(bi, BUNfirst(b));
	gc = BUNtail(gi, BUNfirst(g));
	if (!ALIGNsynced(b, g)) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		throw(SQL, name, "bats not aligned");
	}
/*
	if (!BATtordered(b)) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		throw(SQL, name, "bat not sorted");
	}
*/
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		throw(SQL, name, "cannot allocate result bat");
	}
	BATloop(b, p, q) {
		on = BUNtail(bi, p);
		gn = BUNtail(gi, p);

		if ((c = ocmp(on, oc)) != 0)
			rank = nrank;
		if (gcmp(gn, gc) != 0)
			c = rank = nrank = 1;
		oc = on;
		gc = gn;
		BUNins(r, BUNhead(bi,p), &rank, FALSE);
		nrank += !dense || c;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(g->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}

static str
do_sql_rank(bat *rid, bat *bid, int nrank, int dense, const char *name)
{
	BAT *r, *b;
	BATiter bi;
	int (*cmp)(const void *, const void *);
	const void *cur, *n;
	BUN p, q;
	int rank = 1;
	int c;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, name, "Cannot access descriptor");
	if (!BATtordered(b) && !BATtrevordered(b))
		throw(SQL, name, "bat not sorted");

	bi = bat_iterator(b);
	cmp = BATatoms[b->ttype].atomCmp;
	cur = BUNtail(bi, BUNfirst(b));
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, name, "cannot allocate result bat");
	}
	if (BATtdense(b)) {
		BATloop(b, p, q) {
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			rank++;
		}
	} else {
		BATloop(b, p, q) {
			n = BUNtail(bi, p);
			if ((c = cmp(n, cur)) != 0)
				rank = nrank;
			cur = n;
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			nrank += !dense || c;
		}
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}

str
sql_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe)
{
	(void) gpe;
	return do_sql_rank_grp(rid, bid, gid, 1, 0, "sql.rank_grp");
}

str
sql_dense_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe)
{
	(void) gpe;
	return do_sql_rank_grp(rid, bid, gid, 2, 1, "sql.dense_rank_grp");
}

str
sql_rank(bat *rid, bat *bid)
{
	return do_sql_rank(rid, bid, 1, 0, "sql.rank");
}

str
sql_dense_rank(bat *rid, bat *bid)
{
	return do_sql_rank(rid, bid, 2, 1, "sql.dense_rank");
}

str SQLargRecord(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str s, t, *ret;

	(void) cntxt;
	ret= (str *) getArgReference(stk,pci,0);
	s = instruction2str(mb,stk,getInstrPtr(mb,0),LIST_MAL_DEBUG);
	t= strchr(s,' ');
	*ret = GDKstrdup(t ? t+1: s);
	GDKfree(s);
	return MAL_SUCCEED;
}

/*
 * @-
 * The table is searched for all columns and they are
 * re-clustered on the hash value over the  primary key.
 * Initially the first column
 */

str SQLcluster1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int first=1;
	bat mid, hid, bid;
	BAT *map= NULL, *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.cluster","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.cluster","42S02!Table missing");
	tr = m->session->tr;
	t->base.wtime = s->base.wtime = tr->wtime = tr->wstime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; o; o = o->next) {
		sql_delta *d;
		c = o->data;
		if (first) {
			first = 0;
			b = store_funcs.bind_col(tr, c, 0);
			msg = CLUSTER_key(&hid, &b->batCacheid);
			BBPreleaseref(b->batCacheid);
			if (msg)
				return msg;
			msg = CLUSTER_map(&mid,&hid);
			BBPdecref(hid, TRUE);
			if (msg)
				return msg;
			map = BATdescriptor(mid);
			if (map== NULL)
				throw(SQL,"sql.cluster","Can not access descriptor");
		}

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(SQL,"sql.cluster","Can not access descriptor");
		msg = CLUSTER_apply(&bid, b, map);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(map->batCacheid);
			return msg;
		}
		d = c->data;
		if (d->bid)
			BBPdecref(d->bid, TRUE);
		if (d->ibid)
			BBPdecref(d->ibid, TRUE);
		d->bid = 0;
		d->ibase = 0;
		d->ibid = bid; /* use the insert bat */
		c->base.wtime = tr->wstime;
		c->base.rtime = tr->stime;
	}
	/* bat was cleared */
	t->cleared = 1;
	if (map) {
		BBPreleaseref(map->batCacheid);
		BBPdecref(mid, TRUE);
	}
	return MAL_SUCCEED;
}

str 
SQLcluster2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	int first=1;
	bat mid, hid, bid;
	BAT *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.cluster","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.cluster","42S02!Table missing");
	tr = m->session->tr;

	t->base.wtime = s->base.wtime = tr->wtime = tr->wstime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;
	for (o = t->columns.set->h; o; o = o->next) {
		sql_delta *d;
		c = o->data;
		if (first) {
			bat psum;
			unsigned int bits = 10, off = 0;
			first = 0;
			b = store_funcs.bind_col(tr, c, 0);
			msg = MKEYbathash(&hid, &b->batCacheid);
			BBPreleaseref(b->batCacheid);
			if (msg)
				return msg;
			msg = CLS_create_wrd(&psum, &mid, &hid, &bits, &off);
			BBPdecref(hid, TRUE);
			BBPdecref(psum, TRUE);
			if (msg)
				return msg;
		}

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(SQL,"sql.cluster","Can not access descriptor");
		msg = CLS_map(&bid,&mid,&b->batCacheid);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(bid);
			return msg;
		}

		d = c->data;
		if (d->bid)
			BBPdecref(d->bid, TRUE);
		if (d->ibid)
			BBPdecref(d->ibid, TRUE);
		d->bid = 0;	
		d->ibase = 0;
		d->ibid = bid; /* use the insert bat */

		c->base.wtime = tr->wstime;
		c->base.rtime = tr->stime;
	}
	/* bat was cleared */
	t->cleared = 1;
	return MAL_SUCCEED;
}
/*
 * @- Vacuum cleaning tables
 * Shrinking and re-using space to vacuum clean the holes in the relations.
 */
static str
vacuum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,
       str (*func)(int *, int *, int *), const char *name)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	bat bid;
	BAT *b, *del;
	node *o;
	int i,bids[2049];

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,name,"3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,name,"42S02!Table missing");

	if (m->user_id != USER_MONETDB)
		throw(SQL,name,"42000!insufficient privileges");
	if ((!list_empty(t->idxs.set) || !list_empty(t->keys.set)))
		throw(SQL,name, "%s not allowed on tables with indices", name + 4);
	if (has_snapshots(m->session->tr))
		throw(SQL,name, "%s not allowed on snapshots", name + 4);
	if (!m->session->auto_commit)
		throw(SQL,name, "%s only allowed in auto commit mode", name + 4);

	tr = m->session->tr;

	/* get the deletions BAT*/
	del = mvc_bind_dbat(m, *sch, *tbl, RD_INS);

	i=0;
	bids[i]=0;
	for (o = t->columns.set->h; o; o = o->next,i++) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL ||
		    (msg = (*func)(&bid, &(b->batCacheid), &(del->batCacheid))) != NULL) {
			for( i--; i>=0; i--)
				BBPdecref(bids[i], TRUE);
			if (b)
				BBPreleaseref(b->batCacheid);
			BBPreleaseref(del->batCacheid);
			if (!msg)
				throw(SQL,name,"Can not access descriptor");
			return msg;
		}
		BBPreleaseref(b->batCacheid);
		if (i < 2048){
			bids[i]= bid;
			bids[i+1]=0;
		}
	}
	if ( i >= 2048 ) {
		for( i--; i>=0; i--)
			BBPdecref(bids[i], TRUE);
		throw(SQL,name,"Too many columns to handle, use copy instead");
	}

	mvc_clear_table(m, t);
	for (o = t->columns.set->h, i=0; o; o = o->next, i++) {
		sql_column *c = o->data;
		BAT *ins = BATdescriptor(bids[i]); /* use the insert bat */

		store_funcs.append_col(tr, c, ins, TYPE_bat);
		BBPreleaseref(ins->batCacheid);
		BBPdecref(bids[i], TRUE);
	}
	/* TODO indices */
	return MAL_SUCCEED;
}

str
SQLshrink(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return vacuum(cntxt, mb, stk, pci, BKCshrinkBAT, "sql.shrink");
}

str
SQLreuse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return vacuum(cntxt, mb, stk, pci, BKCreuseBAT, "sql.reuse");
}

/*
 * The vacuum operation inspects the table for ordered properties and
 * will keep them.  To avoid expensive shuffles, the reorganisation is
 * balanced by the number of outstanding deletions.
 */
str
SQLvacuum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	BAT *b, *del;
	node *o;
	int ordered = 0;
	BUN cnt=0;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.vacuum","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.vacuum","42S02!Table missing");

	if (m->user_id != USER_MONETDB)
		throw(SQL,"sql.vacuum","42000!insufficient privileges");
	if ((!list_empty(t->idxs.set) || !list_empty(t->keys.set)))
		throw(SQL,"sql.vacuum","vacuum not allowed on tables with indices");
	if (has_snapshots(m->session->tr)) 
		throw(SQL,"sql.vacuum","vacuum not allowed on snapshots");

	tr = m->session->tr;

	for (o = t->columns.set->h; o && ordered == 0; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL) 
			throw(SQL,"sql.vacuum","Can not access descriptor");
		ordered |= BATtordered(b);
		cnt = BATcount(b);
		BBPreleaseref(b->batCacheid);
	}

	/* get the deletions BAT*/
	del = mvc_bind_dbat(m, *sch, *tbl, RD_INS);

	/* now decide on the algorithm */
	if ( ordered ){
		if( BATcount(del) > cnt/20 )
			SQLshrink(cntxt,mb,stk,pci);
	} else
		SQLreuse(cntxt,mb,stk,pci);

	BBPreleaseref(del->batCacheid);
	return MAL_SUCCEED;
}
/*
 * @-
 * The drop_hash operation cleans up any hash indices on any of the tables columns.
 */
str
SQLdrop_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	BAT *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.drop_hash","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.drop_hash","42S02!Table missing");

	for (o = t->columns.set->h; o; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(m->session->tr, c, RDONLY);
		if (b == NULL) 
			throw(SQL,"sql.drop_hash","Can not access descriptor");
		HASHdestroy(b);
		BBPreleaseref(b->batCacheid);
	}
	return MAL_SUCCEED;
}

/*
 * Take a SQL table and compress its columns using the dictionary
 * compression scheme.
 */
static str
compression(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int compr)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_schema	*s;
	sql_table 	*t;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *o;
	char buf[BUFSIZ], *nme= buf;
	int ret;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.cluster","3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.cluster","42S02!Table missing");

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		BAT *b, *e;
		sql_delta *d;
		sql_column	*c = o->data;

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(SQL,"sql.compress","Can not access descriptor");
		e = BATnew(b->htype, b->ttype, 0);
		if( e == NULL){
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.compression", MAL_MALLOC_FAIL);
		}
		BATsetaccess(e, BAT_READ);
		d = c->data;
		if (d->bid)
			BBPdecref(d->bid, TRUE);
		if (d->ibid)
			BBPdecref(d->ibid, TRUE);
		d->bid = 0;
		d->ibase = 0;
		d->ibid = e->batCacheid; /* use the insert bat */
		c->base.wtime = tr->wstime;
		c->base.rtime = tr->stime;
		snprintf(buf,BUFSIZ,"%s/%s/%s/0", *sch, *tbl, c->base.name);
		if (compr)
			msg = DICTcompress(&ret, &nme, &b->batCacheid);
		else
			msg = DICTdecompress(&ret, &nme);
		BBPkeepref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
	}
	/* bat was cleared */
	t->cleared = 1;
	t->base.wtime = s->base.wtime = tr->wtime = tr->wstime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;
	return msg;
}

str
SQLnewDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return compression(cntxt, mb, stk, pci, 1);
}

str
SQLdropDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return compression(cntxt, mb, stk, pci, 0);
}

/*
 * LZ compression is inherited from the underlying stream implementation.
 */
static str
gzcompression(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,
	      str (*func)(int *, int *, str *), const char *name)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_schema	*s;
	sql_table 	*t;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *o;
	int ret,i;
	char buf[PATHLENGTH], *sbuf= buf;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,name,"3F000!Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,name,"42S02!Table missing");

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		BAT *b;
		sql_column	*c = o->data;

		for ( i= 0; i<3; i++) {
			b = store_funcs.bind_col(tr, c, i);
			if (b == NULL)
				throw(SQL,name,"Can not access descriptor");
			snprintf(buf,PATHLENGTH,"%s_%s_%s_%d", *sch, *tbl, c->base.name,i);
			msg = (*func)(&ret, &b->batCacheid, &sbuf);
			BBPreleaseref(b->batCacheid);
		}
	}
	return msg;
}

str
SQLgzcompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return gzcompression(cntxt, mb, stk, pci, CMDbbpcompress,
			     "sql.gzcompress");
}
str
SQLgzdecompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return gzcompression(cntxt, mb, stk, pci, CMDbbpdecompress,
			     "sql.gzdecompress");
}

str
SQLtruncate(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return gzcompression(cntxt, mb, stk, pci, CMDbbptruncate,
			     "sql.truncate");
}

str
SQLexpand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return gzcompression(cntxt, mb, stk, pci, CMDbbpexpand,
			     "sql.expand");
}

/*
 * @- Shredding RDF documents through SQL
 * Wrapper around the RDF shredder of the rdf module of M5.
 *
 * An rdf file can be now shredded with SQL command:
 * CALL rdf_shred('/path/to/location','graph name');
 *
 * The table rdf.graph will be updated with an entry of the form:
 * [graph name, graph id] -> [gname,gid].
 *
 * In addition all permutation of SPO for the specific rdf document will be
 * created. The name of the triple tables are rdf.pso$gid$, rdf.spo$gid$ etc.
 * For example if gid = 3 then rdf.spo3 is the triple table ordered on subject,
 * property, object. Finally, there is one more table called rdf.map$gid$ that
 * maps oids to strings (i.e., the lexical representation).
 */
str
SQLrdfShred(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
#ifdef HAVE_RAPTOR
	BAT *b[128];
	BAT *p, *s, *o;
	sql_schema *sch;
	sql_table *g_tbl;
	sql_column *gname, *gid;
#if STORE == TRIPLE_STORE
	sql_table *spo_tbl, *sop_tbl, *pso_tbl, *pos_tbl, *osp_tbl, *ops_tbl;
#elif STORE == MLA_STORE
	sql_table *spo_tbl;
#endif /* STORE */
	sql_table *map_tbl;
	sql_subtype tpe;
	str *location = (str *) getArgReference(stk,pci,1);
	str *name = (str *) getArgReference(stk,pci,2);
	str *schema = (str *) getArgReference(stk,pci,3);
	char buff[24];
	mvc *m = NULL;
	int id = 0;
	oid rid = oid_nil;
	str msg;

	rethrow("sql.rdfShred", msg, getSQLContext(cntxt, mb, &m, NULL));

	if ((sch = mvc_bind_schema(m, *schema)) == NULL)
		throw(SQL, "sql.rdfShred", "3F000!schema missing");

	g_tbl = mvc_bind_table(m, sch, "graph");
	gname = mvc_bind_column(m, g_tbl, "gname");
	gid = mvc_bind_column(m, g_tbl, "gid");

	rid = table_funcs.column_find_row(m->session->tr, gname, *name, NULL);
	if (rid != oid_nil)
		throw(SQL, "sql.rdfShred", "graph name already exists in rdf.graph");

	id = (int) store_funcs.count_col(m->session->tr, gname, 1);
	store_funcs.append_col(m->session->tr, gname, *name, TYPE_str);
	store_funcs.append_col(m->session->tr, gid, &id, TYPE_int);

	rethrow("sql.rdfShred", msg, RDFParser(b, location, name, schema));

	if (sizeof(oid) == 8) {
		sql_find_subtype(&tpe, "oid", 31, 0);
		/* todo for niels: if use int/bigint the @0 is serialized */
		/* sql_find_subtype(&tpe, "bigint", 64, 0); */
	} else {
		sql_find_subtype(&tpe, "oid", 31, 0);
		/* sql_find_subtype(&tpe, "int", 32, 0); */
	}
#if STORE == TRIPLE_STORE
	sprintf(buff, "spo%d", id);
	spo_tbl = mvc_create_table(m, sch, buff, tt_table, 0,
				   SQL_PERSIST, 0, 3);
	mvc_create_column(m, spo_tbl, "subject", &tpe);
	mvc_create_column(m, spo_tbl, "property", &tpe);
	mvc_create_column(m, spo_tbl, "object", &tpe);

	sprintf(buff, "sop%d", id);
	sop_tbl = mvc_create_table(m, sch, buff, tt_table, 0,
				   SQL_PERSIST, 0, 3);
	mvc_create_column(m, sop_tbl, "subject", &tpe);
	mvc_create_column(m, sop_tbl, "object", &tpe);
	mvc_create_column(m, sop_tbl, "property", &tpe);

	sprintf(buff, "pso%d", id);
	pso_tbl = mvc_create_table(m, sch, buff, tt_table, 0,
				   SQL_PERSIST, 0, 3);
	mvc_create_column(m, pso_tbl, "property", &tpe);
	mvc_create_column(m, pso_tbl, "subject", &tpe);
	mvc_create_column(m, pso_tbl, "object", &tpe);

	sprintf(buff, "pos%d", id);
	pos_tbl = mvc_create_table(m, sch, buff, tt_table, 0,
				   SQL_PERSIST, 0, 3);
	mvc_create_column(m, pos_tbl, "property", &tpe);
	mvc_create_column(m, pos_tbl, "object", &tpe);
	mvc_create_column(m, pos_tbl, "subject", &tpe);

	sprintf(buff, "osp%d", id);
	osp_tbl = mvc_create_table(m, sch, buff, tt_table, 0,
				   SQL_PERSIST, 0, 3);
	mvc_create_column(m, osp_tbl, "object", &tpe);
	mvc_create_column(m, osp_tbl, "subject", &tpe);
	mvc_create_column(m, osp_tbl, "property", &tpe);

	sprintf(buff, "ops%d", id);
	ops_tbl = mvc_create_table(m, sch, buff, tt_table, 0,
				   SQL_PERSIST, 0, 3);
	mvc_create_column(m, ops_tbl, "object", &tpe);
	mvc_create_column(m, ops_tbl, "property", &tpe);
	mvc_create_column(m, ops_tbl, "subject", &tpe);

#elif STORE == MLA_STORE
	sprintf(buff, "spo%d", id);
	spo_tbl = mvc_create_table(m, sch, buff, tt_table,
				   0, SQL_PERSIST, 0, 3);
	mvc_create_column(m, spo_tbl, "subject", &tpe);
	mvc_create_column(m, spo_tbl, "property", &tpe);
	mvc_create_column(m, spo_tbl, "object", &tpe);
#endif /* STORE */

	sprintf(buff, "map%d", id);
	map_tbl = mvc_create_table(m, sch, buff, tt_table, 0, SQL_PERSIST, 0, 2);
	mvc_create_column(m, map_tbl, "sid", &tpe);
	sql_find_subtype(&tpe, "varchar", 1024, 0);
	mvc_create_column(m, map_tbl, "lexical", &tpe);

	s = b[MAP_LEX];
	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, map_tbl, "lexical"),
			BATmirror(BATmark(BATmirror(s),0)), TYPE_bat);
	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, map_tbl, "sid"),
			BATmirror(BATmark(s, 0)),
			TYPE_bat);
	BBPunfix(s->batCacheid);

#if STORE == TRIPLE_STORE
	s = b[S_sort];
	p = b[P_PO];
	o = b[O_PO];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, spo_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, spo_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, spo_tbl, "object"),
			       o, TYPE_bat);
	s = b[S_sort];
	p = b[P_OP];
	o = b[O_OP];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, sop_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, sop_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, sop_tbl, "object"),
			       o, TYPE_bat);
	s = b[S_SO];
	p = b[P_sort];
	o = b[O_SO];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, pso_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, pso_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, pso_tbl, "object"),
			       o, TYPE_bat);
	s = b[S_OS];
	p = b[P_sort];
	o = b[O_OS];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, pos_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, pos_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, pos_tbl, "object"),
			       o, TYPE_bat);
	s = b[S_SP];
	p = b[P_SP];
	o = b[O_sort];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, osp_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, osp_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, osp_tbl, "object"),
			       o, TYPE_bat);
	s = b[S_PS];
	p = b[P_PS];
	o = b[O_sort];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, ops_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, ops_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, ops_tbl, "object"),
			       o, TYPE_bat);
#elif STORE == MLA_STORE
	s = b[S_sort];
	p = b[P_sort];
	o = b[O_sort];
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, spo_tbl, "subject"),
			       s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, spo_tbl, "property"),
			       p, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			       mvc_bind_column(m, spo_tbl, "object"),
			       o, TYPE_bat);
#endif /* STORE */

	/* unfix graph */
	for(id=0; b[id]; id++) {
		BBPunfix(b[id]->batCacheid);
	}
	return MAL_SUCCEED;
#else
	(void) cntxt; (void) mb; (void) stk; (void) pci;
	throw(SQL, "sql.rdfShred", "RDF support is missing from MonetDB5");
#endif /* RDF */
}

/* after an update on the optimizer catalog, we have to change
 * the internal optimizer pipe line administration
 * The minimal and default pipelines may not be changed.
*/
str SQLoptimizersUpdate(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getSQLContext(cntxt, mb, &m, NULL);

	if ( msg)
		return msg;
	/* find the optimizer pipeline */
	(void) stk;
	(void) pci;
	throw(SQL,"updateOptimizer",PROGRAM_NYI);
}

/*
 * @-
 * Inspection of the actual storage footprint is a recurring question of users.
 * This is modelled as a generic SQL table producing function.
 * create function storage()
 * returns table ("schema" string, "table" string, "column" string, "type" string, location string, "count" bigint, width int, columnsize bigint, heapsize bigint indices bigint, sorted int)
 * external name sql.storage;
 */
str
sql_storage(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *sch, *tab, *col, *type, *loc, *cnt, *atom, *size, *heap, *indices, *sort;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *nsch, *ntab, *ncol;
	int w;
	int *rsch = (int*) getArgReference(stk,pci,0);
	int *rtab = (int*) getArgReference(stk,pci,1);
	int *rcol = (int*) getArgReference(stk,pci,2);
	int *rtype = (int*) getArgReference(stk,pci,3);
	int *rloc = (int*) getArgReference(stk,pci,4);
	int *rcnt = (int*) getArgReference(stk,pci,5);
	int *ratom = (int*) getArgReference(stk,pci,6);
	int *rsize = (int*) getArgReference(stk,pci,7);
	int *rheap = (int*) getArgReference(stk,pci,8);
	int *rindices = (int*) getArgReference(stk,pci,9);
	int *rsort = (int*) getArgReference(stk,pci,10);

	if (msg)
		return msg;

	sch = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(sch, 0);
	tab = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(tab, 0);
	col = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(col, 0);
	type = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(type, 0);
	loc = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(loc, 0);
	cnt = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(cnt, 0);
	atom = BATnew(TYPE_void,TYPE_int, 0);
	BATseqbase(atom, 0);
	size = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(size, 0);
	heap = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(heap, 0);
	indices = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(indices, 0);
	sort = BATnew(TYPE_void,TYPE_bit, 0);
	BATseqbase(sort, 0);
	if ( sch == NULL || tab == NULL || col == NULL || type == NULL || loc == NULL || sort == NULL ||
		 cnt == NULL || atom == NULL || size == NULL || heap == NULL ||indices == NULL){
		if ( sch ) BBPreleaseref(sch->batCacheid);
		if ( tab ) BBPreleaseref(tab->batCacheid);
		if ( col ) BBPreleaseref(col->batCacheid);
		if ( loc ) BBPreleaseref(loc->batCacheid);
		if ( cnt ) BBPreleaseref(cnt->batCacheid);
		if ( type ) BBPreleaseref(type->batCacheid);
		if ( atom ) BBPreleaseref(atom->batCacheid);
		if ( size ) BBPreleaseref(size->batCacheid);
		if ( heap ) BBPreleaseref(heap->batCacheid);
		if ( indices ) BBPreleaseref(indices->batCacheid);
		if ( sort ) BBPreleaseref(sort->batCacheid);
		throw(SQL,"sql.storage", MAL_MALLOC_FAIL);
	}
	for( nsch= tr->schemas.set->h; nsch; nsch= nsch->next){
		sql_base *b= nsch->data;
		sql_schema *s= (sql_schema*) nsch->data;
		if ( isalpha((int)b->name[0]) )

		if (s->tables.set) 
		for(ntab= (s)->tables.set->h ;ntab; ntab= ntab->next){
			sql_base *bt= ntab->data;
			sql_table *t= (sql_table*) bt;
			if (isTable(t))
			if (t->columns.set) for (ncol= (t)->columns.set->h; ncol; ncol= ncol->next){
				sql_base *bc = ncol->data;
				sql_column *c= (sql_column *) ncol->data;
				BAT *bn = store_funcs.bind_col(tr, c, 0);
				lng sz;

				/*printf("schema %s.%s.%s" , b->name, bt->name, bc->name);*/
				sch = BUNappend(sch, b->name, FALSE);
				tab = BUNappend(tab, bt->name, FALSE);
				col = BUNappend(col, bc->name, FALSE);
				type = BUNappend(type, c->type.type->sqlname, FALSE);

				/*printf(" cnt "BUNFMT, BATcount(bn));*/
				sz= BATcount(bn);
				cnt = BUNappend(cnt, &sz, FALSE);

				/*printf(" loc %s", BBP_physical(bn->batCacheid));*/
				loc = BUNappend(loc, BBP_physical(bn->batCacheid), FALSE);
				/*printf(" width %d", bn->T->width);*/
				w= bn->T->width;
				if ( bn->ttype == TYPE_str){
					BUN p,q;
					double sum=0;
					BATiter bi = bat_iterator(bn);
					lng cnt1,cnt2= cnt1=(lng) BATcount(bn);
					
					/* just take a sample */
					if ( cnt1 > 512)
						cnt1 = cnt2 = 512;
					BATloop(bn,p,q){
						str s = BUNtail(bi,p);
						if( s != NULL && strcmp(s, str_nil))
							sum += (int) strlen(s);
						if ( --cnt1 <= 0)
							break;
					}
					if ( cnt2)
						w = (int) (sum/cnt2);
				}
				atom = BUNappend(atom, &w, FALSE);

				sz = tailsize(bn,BATcount(bn));
				sz += headsize(bn,BATcount(bn));
				size = BUNappend(size, &sz, FALSE);
				
				sz = bn->T->vheap? bn->T->vheap->size:0;
				sz += bn->H->vheap? bn->H->vheap->size:0;
				heap = BUNappend(heap, &sz, FALSE);

				sz =  bn->T->hash?bn->T->hash->heap->size:0;
				sz += bn->H->hash?bn->H->hash->heap->size:0;
				indices = BUNappend(indices, &sz, FALSE);
				/*printf(" indices "BUNFMT, bn->T->hash?bn->T->hash->heap->size:0);*/
				/*printf("\n");*/

				w =  BATtordered(bn);
				sort = BUNappend(sort, &w, FALSE);
				BBPunfix(bn->batCacheid);
			}

			if (isTable(t))
				if(t->idxs.set)
					for (ncol= (t)->idxs.set->h; ncol; ncol= ncol->next){
						sql_base *bc = ncol->data;
						sql_idx *c= (sql_idx *) ncol->data;
						if(c->type != no_idx){
							BAT *bn = store_funcs.bind_idx(tr, c, 0);
							lng sz;
			
							/*printf("schema %s.%s.%s" , b->name, bt->name, bc->name);*/
							sch = BUNappend(sch, b->name, FALSE);
							tab = BUNappend(tab, bt->name, FALSE);
							col = BUNappend(col, bc->name, FALSE);
							type = BUNappend(type, "oid", FALSE);
			
							/*printf(" cnt "BUNFMT, BATcount(bn));*/
							sz= BATcount(bn);
							cnt = BUNappend(cnt, &sz, FALSE);
			
							/*printf(" loc %s", BBP_physical(bn->batCacheid));*/
							loc = BUNappend(loc, BBP_physical(bn->batCacheid), FALSE);
							/*printf(" width %d", bn->T->width);*/
							w= bn->T->width;
							if ( bn->ttype == TYPE_str){
								BUN p,q;
								double sum=0;
								BATiter bi = bat_iterator(bn);
								lng cnt1, cnt2= cnt1 = BATcount(bn);
								
								/* just take a sample */
								if ( cnt1 > 512)
									cnt1 = cnt2 = 512;
								BATloop(bn,p,q){
									str s = BUNtail(bi,p);
									if( s != NULL && strcmp(s, str_nil))
										sum += (int) strlen(s);
									if ( --cnt1 <= 0)
										break;
								}
								if ( cnt2)
									w = (int) (sum/cnt2);
							}
							atom = BUNappend(atom, &w, FALSE);
							/*printf(" size "BUNFMT, tailsize(bn,BATcount(bn)) + (bn->T->vheap? bn->T->vheap->size:0));*/
							sz = tailsize(bn,BATcount(bn));
							sz += headsize(bn,BATcount(bn));
							size = BUNappend(size, &sz, FALSE);
							
							sz = bn->T->vheap? bn->T->vheap->size:0;
							sz += bn->H->vheap? bn->H->vheap->size:0;
							heap = BUNappend(heap, &sz, FALSE);

							sz =  bn->T->hash?bn->T->hash->heap->size:0;
							sz += bn->H->hash?bn->H->hash->heap->size:0;
							indices = BUNappend(indices, &sz, FALSE);
							/*printf(" indices "BUNFMT, bn->T->hash?bn->T->hash->heap->size:0);*/
							/*printf("\n");*/
							w =  BATtordered(bn);
							sort = BUNappend(sort, &w, FALSE);
							BBPunfix(bn->batCacheid);
						}
					}
		
		}
	}

	BBPkeepref(*rsch = sch->batCacheid);
	BBPkeepref(*rtab = tab->batCacheid);
	BBPkeepref(*rcol = col->batCacheid);
	BBPkeepref(*rloc = loc->batCacheid);
	BBPkeepref(*rtype = type->batCacheid);
	BBPkeepref(*rcnt = cnt->batCacheid);
	BBPkeepref(*ratom = atom->batCacheid);
	BBPkeepref(*rsize = size->batCacheid);
	BBPkeepref(*rheap = heap->batCacheid);
	BBPkeepref(*rindices = indices->batCacheid);
	BBPkeepref(*rsort = sort->batCacheid);
	return MAL_SUCCEED;
}

str 
RAstatement(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int pos = 0;
	str *expr = (str*) getArgReference(stk, pci, 1);
	bit *opt = (bit*) getArgReference(stk, pci, 2);
	backend *b = NULL;
	mvc *m = NULL;
	str msg = getSQLContext(cntxt, mb, &m, &b);
	sql_rel *rel;
	list *refs;

	if (!m->sa)
		m->sa = sa_create();
 	refs = sa_list(m->sa);
 	rel = rel_read(m, *expr, &pos, refs);
	if (rel) {
		int oldvtop = cntxt->curprg->def->vtop;
		int oldstop = cntxt->curprg->def->stop;
		stmt *s;
		char *msg;

		if (*opt) 
			rel = rel_optimizer(m, rel);
		s = output_rel_bin(m, rel);
		rel_destroy(rel);

		MSinitClientPrg(cntxt, "user", "test"); 

		/* generate MAL code */
		backend_callinline(b, cntxt, s );
		addQueryToCache(cntxt); 

		msg = (str) runMAL(cntxt, cntxt->curprg->def, 0, 0);
		if (!msg) { 
			resetMalBlk(cntxt->curprg->def, oldstop);
			freeVariables(cntxt,cntxt->curprg->def, cntxt->glb, oldvtop);
		}
	}
	return msg;
}

void
freeVariables(Client c, MalBlkPtr mb, MalStkPtr glb, int start)
{
	int i, j;

	for (i = start; i < mb->vtop;) {
		if (glb) {
			if (isVarCleanup(mb,i))
				garbageElement(c,&glb->stk[i]);
			/* clean stack entry */
			glb->stk[i].vtype = TYPE_int;
			glb->stk[i].val.ival = 0;
			glb->stk[i].len = 0;
		}
		clearVariable(mb, i);
		i++;
	}
	mb->vtop = start;
	for (i = j = 0; i < mb->ptop; i++) {
		if (mb->prps[i].var < start) {
			if (i > j)
				mb->prps[j] = mb->prps[i];
			j++;
		}
	}
	mb->ptop = j;
}

@mal
# assume nil's are removed
# (sum (e1 * e2) - (sum(e1) * sum(e2)/count(e1))) / count(e1)

@= analytic
function aggr.covar(e1:bat[:oid,:@1], e2:bat[:oid,:@1]):@1;
	e0:bat[:oid,:@1] := batcalc.*(e1,e2);
	s0:@1 := aggr.sum(e0);
	s1:@1 := aggr.sum(e1);
	s2:@1 := aggr.sum(e2);
	v2:@1 := calc.*(s1,s2);
	c := aggr.count(e1);
	n:@1 := calc.@1(c);
	v3:@1 := calc./(v2,n);
	v1:@1 := calc.-(s0,v3);
	v:@1 := calc./(v1,n);
	return v;
end aggr.covar;

function aggr.corr(e1:bat[:oid,:@1], e2:bat[:oid,:@1]):@1;
	cv:@1 := aggr.covar(e1,e2);
	sd1 := aggr.stdev(e1);
	sd2 := aggr.stdev(e2);
	sd := calc.*(sd1,sd2);
	r := calc./(cv,sd);
	res := calc.@1(r);
	return res;
end aggr.corr;

function aggr.covar(e1:bat[:oid,:@1], e2:bat[:oid,:@1], g:bat[:oid,:oid], e:bat[:oid,:any_2]):bat[:oid,:@1];
	e0:bat[:oid,:@1] := batcalc.*(e1,e2);
	s0:bat[:oid,:@1] := aggr.sum(e0,g,e);
	s1:bat[:oid,:@1] := aggr.sum(e1,g,e);
	s2:bat[:oid,:@1] := aggr.sum(e2,g,e);
	v2:bat[:oid,:@1] := batcalc.*(s1,s2);
	c := aggr.count(e1,g,e);
	n:bat[:oid,:@1] := batcalc.@1(c);
	v3:bat[:oid,:@1] := batcalc./(v2,n);
	v1:bat[:oid,:@1] := batcalc.-(s0,v3);
	v:bat[:oid,:@1] := batcalc./(v1,n);
	return v;
end aggr.covar;

function aggr.corr(e1:bat[:oid,:@1], e2:bat[:oid,:@1], g:bat[:oid,:oid],e:bat[:oid,:any_2]):bat[:oid,:@1];
	cv:bat[:oid,:@1] := aggr.covar(e1,e2,g,e);
	sd1 := aggr.stdevp(e1,g,e);
	sd2 := aggr.stdevp(e2,g,e);
	sd := batcalc.*(sd1,sd2);
	sdn := batcalc.==(sd,0:@1);
	sds := batcalc.ifthenelse(sdn,1:@1,sd);
	r := batcalc./(cv,sds);
	res := batcalc.@1(r);
	return res;
end aggr.corr;

function sql.sortTail( b:bat[:oid,:any_1]) :bat[:oid,:oid];
	s := algebra.sortTail(b);
	m := algebra.markT(s, 0:oid);
	return bat.reverse(m);
end sql.sortTail;

function sql.sortReverseTail( b:bat[:oid,:any_1]) :bat[:oid,:oid];
	s := algebra.sortReverseTail(b);
	m := algebra.markT(s, 0:oid);
	return bat.reverse(m);
end sql.sortReverseTail;

@mal
@:analytic(bte)@
@:analytic(sht)@
@:analytic(int)@
@:analytic(lng)@
@:analytic(flt)@
@:analytic(dbl)@

